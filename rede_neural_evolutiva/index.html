<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo de Pular Obstáculos com IA (ES)</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Alinha no topo */
            font-family: sans-serif;
            margin-top: 20px;
            background-color: #f0f0f0;
        }
        canvas {
            border: 1px solid black;
            background-color: #e0e0ff; /* Céu azul claro */
            margin: 5px;
        }
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #visContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-left: 20px;
        }
        #info {
            margin-bottom: 10px;
            font-size: 14px;
        }
        #graphContainer canvas {
             background-color: #ffffff;
        }
        h3 {
            margin-top: 15px;
            margin-bottom: 5px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="info">Geração: <span id="generation">1</span> | Melhor Pontuação da Geração: <span id="bestScore">0</span></div>
        <canvas id="gameCanvas" width="600" height="300"></canvas>
        <div id="graphContainer">
             <h3>Melhores Pontuações por Geração</h3>
             <canvas id="graphCanvas" width="600" height="350"></canvas>
        </div>
    </div>
    <div id="visContainer">
         <h3>Rede Neural (Jogador 0)</h3>
         <canvas id="nnCanvas" width="400" height="800"></canvas>
    </div>

    <script>
        // --- Configurações Globais ---
        const gameCanvas = document.getElementById('gameCanvas');
        const gameCtx = gameCanvas.getContext('2d');
        const nnCanvas = document.getElementById('nnCanvas');
        const nnCtx = nnCanvas.getContext('2d');
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');

        // Comment out or remove the old genesP1, as it's the wrong size now
        /*
        const genesP1 = [
            "-0.915",
            "0.799",
            "-0.754",
            "-0.092",
            "-0.086",
            "-0.680",
            "-0.593",
            "-0.585",
            "0.311",
            "0.608",
            "-0.143",
            "0.360",
            "0.087",
            "0.472",
            "0.217",
            "-0.262",
            "0.630",
            "-0.325",
            "-0.371",
            "0.248",
            "0.170"
        ];
        */
        let genesP1 = null; // Set to null or an empty array initially

        const GAME_WIDTH = gameCanvas.width;
        const GAME_HEIGHT = gameCanvas.height;
        const GROUND_Y = GAME_HEIGHT - 50;
        const GRAVITY = 0.6;
        const JUMP_STRENGTH = -13;
        const OBSTACLE_SPEED = 5;
        const OBSTACLE_COLOR = 'darkred';
        const PLAYER_COLORS = [
            'blue', 'green', 'orange', 'purple', 'red', 'magenta', 
            'yellow', 'black-green', 'pink', 'teal', 'crimson', 'indigo', 
            'coral', 'maroon', 'olive', 'navy', 'turquoise', 'gold', 
            'plum', 'sienna'
        ];

        const NUM_PLAYERS = 20; // Número de indivíduos na população da ES
        const MUTATION_RATE = 0.2; // Taxa de mutação
        const MUTATION_AMOUNT = 0.99; // Magnitude da mutação
        const HIDDEN_UNITS_1 = 8; // Renamed from HIDDEN_UNITS
        const HIDDEN_UNITS_2 = 4; // Size of the new second hidden layer
        const NUM_INPUTS = 3;
        const NUM_OUTPUTS = 1;

        let players = [];
        let obstacles = [];
        let frameCount = 0;
        let generation = 1;
        let activePlayers = NUM_PLAYERS;
        let nextObstacleFrame = 100; // Quando o próximo obstáculo aparece
        let evolutionaryStrategy;
        let bestScoresHistory = []; // Armazena as melhores pontuações de cada geração
        let worstScoresHistory = []; // Armazena as piores pontuações de cada geração

        // --- Classe Perceptron (Rede Neural) ---
        class MLP {
            constructor(numInputs, hiddenUnits1, hiddenUnits2, numOutputs) {
                // Use constants directly for consistency, ignore constructor args for now
                numInputs = NUM_INPUTS;
                hiddenUnits1 = HIDDEN_UNITS_1;
                hiddenUnits2 = HIDDEN_UNITS_2; // Use the new constant
                numOutputs = NUM_OUTPUTS;

                // Remove old single-layer properties if they exist
                // delete this.weights;
                // delete this.bias;
                // delete this.lastActivation;

                this.numInputs = numInputs;
                this.hiddenUnits1 = hiddenUnits1;
                this.hiddenUnits2 = hiddenUnits2; // Store the size
                this.numOutputs = numOutputs;

                // --- Initialization with Xavier ---
                const xavier = (fanIn, fanOut) => Math.sqrt(6 / (fanIn + fanOut));

                // Layer 1 (Input -> Hidden1)
                this.weights_in_h1 = Array.from({length: numInputs}, () =>
                    Array.from({length: hiddenUnits1}, () => (Math.random() * 2 - 1) * xavier(numInputs, hiddenUnits1)));
                this.bias_h1 = Array.from({length: hiddenUnits1}, () => (Math.random() * 2 - 1) * xavier(numInputs, hiddenUnits1) * 0.01);

                // Layer 2 (Hidden1 -> Hidden2)
                this.weights_h1_h2 = Array.from({length: hiddenUnits1}, () =>
                    Array.from({length: hiddenUnits2}, () => (Math.random() * 2 - 1) * xavier(hiddenUnits1, hiddenUnits2)));
                this.bias_h2 = Array.from({length: hiddenUnits2}, () => (Math.random() * 2 - 1) * xavier(hiddenUnits1, hiddenUnits2) * 0.01);

                // Layer 3 (Hidden2 -> Output)
                this.weights_h2_out = Array.from({length: hiddenUnits2}, () =>
                    Array.from({length: numOutputs}, () => (Math.random() * 2 - 1) * xavier(hiddenUnits2, numOutputs)));
                this.bias_out = Array.from({length: numOutputs}, () => (Math.random() * 2 - 1) * xavier(hiddenUnits2, numOutputs) * 0.01);


                // --- Store activations for visualization ---
                this.lastInputs = Array(numInputs).fill(0);
                this.hiddenActivations1 = Array(hiddenUnits1).fill(0);
                this.hiddenActivations2 = Array(hiddenUnits2).fill(0); // For the second hidden layer
                this.lastOutput = Array(numOutputs).fill(0);
            }

            // Usar ReLU para evitar vanishing gradient
            relu(x) {
                return Math.max(0, x);
            }

            sigmoid(x) {
                return 1 / (1 + Math.exp(-x));
            }

            feedForward(inputs) {
                if (inputs.length !== this.numInputs) {
                    console.error(`Input length mismatch: expected ${this.numInputs}, got ${inputs.length}`);
                    // Pad or truncate inputs as a fallback, or return an error/default value
                    inputs = inputs.slice(0, this.numInputs);
                    while (inputs.length < this.numInputs) inputs.push(0);
                }
                this.lastInputs = inputs;

                // Camada oculta 1 com ReLU
                this.hiddenActivations1 = this.bias_h1.map((bias, i) => {
                    const sum = inputs.reduce((acc, val, j) => acc + val * this.weights_in_h1[j][i], bias);
                    return this.relu(sum);
                });

                // Camada oculta 2 com ReLU
                this.hiddenActivations2 = this.bias_h2.map((bias, i) => {
                    const sum = this.hiddenActivations1.reduce((acc, val, j) => acc + val * this.weights_h1_h2[j][i], bias);
                    return this.relu(sum);
                });

                // Camada de saída com sigmoid
                const outputs = this.bias_out.map((bias, i) => {
                    // Use hiddenActivations2 as input for the output layer
                    const sum = this.hiddenActivations2.reduce((acc, val, j) => acc + val * this.weights_h2_out[j][i], bias);
                    return this.sigmoid(sum);
                });

                this.lastOutput = outputs; // Store the array
                // Return 1 if the first output neuron is > 0.5, else 0
                return (outputs.length > 0 && outputs[0] > 0.5) ? 1 : 0;
            }

            getGenes() {
                const genes = [];
                // Layer 1
                this.weights_in_h1.forEach(row => genes.push(...row));
                genes.push(...this.bias_h1);
                // Layer 2
                this.weights_h1_h2.forEach(row => genes.push(...row));
                genes.push(...this.bias_h2);
                // Layer 3
                this.weights_h2_out.forEach(row => genes.push(...row));
                genes.push(...this.bias_out);
                return genes;
            }

            setGenes(genes) {
                let idx = 0;
                try {
                    // Layer 1 (Input -> Hidden1)
                    for(let i = 0; i < this.numInputs; i++) {
                        for(let j = 0; j < this.hiddenUnits1; j++) {
                            if (idx >= genes.length) throw new Error("Gene array too short");
                            this.weights_in_h1[i][j] = parseFloat(genes[idx++]);
                        }
                    }
                    for(let i = 0; i < this.hiddenUnits1; i++) {
                         if (idx >= genes.length) throw new Error("Gene array too short");
                        this.bias_h1[i] = parseFloat(genes[idx++]);
                    }
                    // Layer 2 (Hidden1 -> Hidden2)
                    for(let i = 0; i < this.hiddenUnits1; i++) {
                        for(let j = 0; j < this.hiddenUnits2; j++) {
                             if (idx >= genes.length) throw new Error("Gene array too short");
                            this.weights_h1_h2[i][j] = parseFloat(genes[idx++]);
                        }
                    }
                    for(let i = 0; i < this.hiddenUnits2; i++) {
                         if (idx >= genes.length) throw new Error("Gene array too short");
                        this.bias_h2[i] = parseFloat(genes[idx++]);
                    }
                    // Layer 3 (Hidden2 -> Output)
                    for(let i = 0; i < this.hiddenUnits2; i++) {
                        for(let j = 0; j < this.numOutputs; j++) {
                             if (idx >= genes.length) throw new Error("Gene array too short");
                            this.weights_h2_out[i][j] = parseFloat(genes[idx++]);
                        }
                    }
                    for(let i = 0; i < this.numOutputs; i++) {
                         if (idx >= genes.length) throw new Error("Gene array too short");
                        this.bias_out[i] = parseFloat(genes[idx++]);
                    }

                     if (idx !== this.getNumGenes()) {
                         console.warn(`Gene count mismatch after setting: expected ${this.getNumGenes()}, processed ${idx}`);
                     }

                } catch (e) {
                    console.error("Error setting genes:", e, "Index:", idx, "Gene Array Length:", genes.length);
                     // Optionally reset weights to default random if loading fails critically
                }
            }

            getNumGenes() {
                const genesLayer1 = (this.numInputs * this.hiddenUnits1) + this.hiddenUnits1;
                const genesLayer2 = (this.hiddenUnits1 * this.hiddenUnits2) + this.hiddenUnits2;
                const genesLayer3 = (this.hiddenUnits2 * this.numOutputs) + this.numOutputs;
                return genesLayer1 + genesLayer2 + genesLayer3;
            }
        }

        // --- Classe Jogador ---
        class Player {
            constructor(color, brain, height) {
                this.width = Math.random() * 5 + 25;
                this.height = height ? height : Math.random() * 10 + 40;
                this.x = Math.random() * 2 + 48;
                this.y = GROUND_Y - this.height;
                this.velocityY = 0;
                this.isJumping = false;
                this.color = color;
                this.isAlive = true;
                this.score = 0;
                this.brain = brain; // Instância do Perceptron
            }

            getInputs(obstacles) {
                let closestObstacle = null;
                let minDistance = Infinity;

                for (const obstacle of obstacles) {
                    const distance = obstacle.x - (this.x + this.width);
                    if (distance >= 0 && distance < minDistance) {
                        minDistance = distance;
                        closestObstacle = obstacle;
                    }
                }

                if (!closestObstacle) {
                    return [1.0, 0.5, 0]; // Distância máxima, altura obstáculo e velocidade obstáculo 0
                }

                const inputDistance = minDistance / GAME_WIDTH;
                //const inputPlayerY = (GROUND_Y - (this.y + this.height)) / GROUND_Y;
                const inputObstacleHeight = closestObstacle.height / GROUND_Y;
                const inputObstacleSpeed = (closestObstacle.speed - 5) / 5; // Normaliza velocidade (0.5-0.9)

                return [inputDistance, inputObstacleHeight, inputObstacleSpeed];
            }

            think() {
                const inputs = this.getInputs(obstacles);
                const output = this.brain.feedForward(inputs);
                if (output === 1) {
                    this.jump();
                }
            }

            jump() {
                if (!this.isJumping) {
                    this.velocityY = JUMP_STRENGTH;
                    this.isJumping = true;
                }
            }

            update() {
                if (!this.isAlive) return;

                // Aplica gravidade
                this.velocityY += GRAVITY;
                this.y += this.velocityY;


                // Bonus por se manter próximo ao chão
                const groundBonus = (GROUND_Y - (this.y + this.height)) < 10 ? 0.5 : 0;

                // Penalidade por pular desnecessariamente
                const jumpPenalty = this.isJumping ? -0.6 : 0;

                const weightPenalty = this.brain.getGenes().reduce((sum, gene) => sum + Math.abs(gene), 0) * -0.02;
                this.score += 1 + groundBonus + jumpPenalty + weightPenalty;

                //console.log("Ativações ocultas:", this.brain.hiddenActivations);
                //console.log("Saída:", this.brain.lastOutput);


                // Verifica colisão com o chão
                if (this.y + this.height > GROUND_Y) {
                    this.y = GROUND_Y - this.height;
                    this.velocityY = 0;
                    this.isJumping = false;
                }

                // Lógica da IA para decidir pular
                this.think();
            }


            draw(ctx) {
                if (!this.isAlive) return;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }

            checkCollision(obstacle) {
                // Verificação simples de colisão AABB (Axis-Aligned Bounding Box)
                return (
                    this.x < obstacle.x + obstacle.width &&
                    this.x + this.width > obstacle.x &&
                    this.y < obstacle.y + obstacle.height &&
                    this.y + this.height > obstacle.y
                );
            }
        }

        // --- Classe Obstáculo ---
        class Obstacle {
            constructor() {
                this.height = 30 + Math.random() * 60; // Altura entre 30-100
                this.width = 20 + Math.random() * 40; // Largura entre 20-70
                this.speed = OBSTACLE_SPEED + Math.random() * 5; // Velocidade 5-7
                this.x = GAME_WIDTH;
                this.y = GROUND_Y - this.height; // Sempre no chão
                this.color = OBSTACLE_COLOR;
            }

            update() {
                this.x -= this.speed;
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }

            isOffscreen() {
                return this.x + this.width < 0;
            }
        }

        // --- Classe Estratégia Evolutiva (ES) ---
        class EvolutionaryStrategy {
            constructor(populationSize, mutationRate, mutationAmount, numGenes) {
                this.populationSize = populationSize;
                this.numGenes = numGenes;
                this.population = this.initializePopulation();
                this.mutationRate = mutationRate;
                this.mutationAmount = mutationAmount;
            }
            
            selection() {
                // Manter os 20% melhores (elitismo)
                const eliteCount = Math.ceil(this.populationSize * 0.2);
                return this.population.slice(0, eliteCount);
            }
            
            // Adicionar método de crossover (recombinação)
            crossover(parent1, parent2) {
                const childGenes = [];
                for (let i = 0; i < this.numGenes; i++) {
                    childGenes.push(Math.random() < 0.5 ? parent1.genes[i] : parent2.genes[i]);
                }
                return childGenes;
            }
            
            // Modificar o método de geração de nova população para incluir crossover
            generateNewPopulation() {
                // Reduzir mutação mais lentamente
                this.mutationAmount *= 0.995; // Decaimento de 0.5% por geração
                this.mutationRate *= 0.998; // Decaimento de 0.2% por geração
                
                // Limites mínimos mais altos
                this.mutationAmount = Math.max(0.15, this.mutationAmount);
                this.mutationRate = Math.max(0.08, this.mutationRate);
                
                // Selecionar pais
                const parents = this.selection();
                const newPopulation = [];
                
                // Adicionar elites diretamente (10% melhores sem mutação)
                const eliteCount = Math.ceil(this.populationSize * 0.1);
                for (let i = 0; i < eliteCount; i++) {
                    newPopulation.push(this.createIndividual([...this.population[i].genes]));
                }
                
                // Gerar o resto da população com crossover e mutação
                while (newPopulation.length < this.populationSize) {
                    // Selecionar dois pais aleatórios do grupo de selecionados
                    const parent1 = parents[Math.floor(Math.random() * parents.length)];
                    const parent2 = parents[Math.floor(Math.random() * parents.length)];
                    
                    // Aplicar crossover
                    let childGenes = this.crossover(parent1, parent2);
                    
                    // Aplicar mutação
                    childGenes = this.mutate(childGenes);
                    
                    // Adicionar à nova população
                    newPopulation.push(this.createIndividual(childGenes));
                }
                
                this.population = newPopulation;
            }

            // Inicializa a população com genes aleatórios [-1, 1]
            initializePopulation() {
                // O fitness é a pontuação que cada indivíduo (jogador) consegue no jogo
                // Quanto maior o fitness, melhor o jogador se saiu e mais chances ele tem
                // de passar seus genes para a próxima geração
                const pop = [];
                for (let i = 0; i < this.populationSize; i++) {
                    pop.push({
                        genes: Array(this.numGenes).fill(0).map(() => Math.random() * 2 - 1),
                        fitness: 0 // Começa com 0 pois ainda não jogou
                    });
                }
                return pop;
            }

            // Cria um novo indivíduo (usado na geração)
            createIndividual(genes) {
                return { genes: genes, fitness: 0 };
            }

            // Avalia a população com base nas pontuações (fitness)
            evaluate(fitnessScores) {
                if (fitnessScores.length !== this.populationSize) {
                    console.error("Tamanho do array de fitness não corresponde ao tamanho da população!");
                    // Se der erro, tenta usar os scores dos players que ainda existem
                    fitnessScores = players.map(p => p.score);
                    if(fitnessScores.length !== this.populationSize) {
                        console.error("Erro grave ao tentar recuperar scores.");
                        // Como último recurso, atribui fitness 0 a todos e espera a próxima geração
                        this.population.forEach(ind => ind.fitness = 0);
                        return;
                    }
                }
                for (let i = 0; i < this.populationSize; i++) {
                    // Garante que o indivíduo existe antes de atribuir fitness
                    if (this.population[i]) {
                        this.population[i].fitness = fitnessScores[i] || 0; // Usa 0 se score for undefined/null
                    } else {
                        console.warn(`Indivíduo ${i} não encontrado na população durante avaliação.`);
                    }
                }
                // Ordena a população por fitness (do maior para o menor)
                // Ordena a população em ordem decrescente de fitness (pontuação)
                // Para cada par de indivíduos a,b:
                // - Se b.fitness > a.fitness, retorna número positivo (b vem antes)
                // - Se b.fitness < a.fitness, retorna número negativo (a vem antes) 
                // - Se b.fitness = a.fitness, retorna 0 (mantém ordem)
                this.population.sort((a, b) => b.fitness - a.fitness);
                // Imprime o primeiro (melhor) e último (pior) indivíduo da população ordenada
                console.log("Melhor indivíduo:", {
                    fitness: this.population[0].fitness.toFixed(2),
                    genes: this.population[0].genes.map(g => g.toFixed(3))
                });
                console.log("Pior indivíduo:", {
                    fitness: this.population[this.population.length-1].fitness.toFixed(2), 
                    genes: this.population[this.population.length-1].genes.map(g => g.toFixed(3))
                });
            }

            // Aplica mutação a um conjunto de genes
            mutate(genes) {
                const mutatedGenes = [...genes];
                for (let i = 0; i < this.numGenes; i++) {
                    if (Math.random() < this.mutationRate) {
                        // Mutação adaptativa (maior impacto em genes extremos)
                        const scale = 1.2 - Math.abs(mutatedGenes[i]);
                        const mutation = (Math.random() * 1.4 - 1) * this.mutationAmount * scale;
                        const oldValue = mutatedGenes[i];
                        mutatedGenes[i] += mutation;
                        
                        // Limitar valores entre -2 e 2
                        mutatedGenes[i] = Math.max(-2, Math.min(2, mutatedGenes[i]));

                        //console.log(`Gene ${i}: ${oldValue.toFixed(4)} -> ${mutatedGenes[i].toFixed(4)} (mutation: ${mutation.toFixed(4)}, scale: ${scale.toFixed(4)})`);
                    }
                }
                return mutatedGenes;
            }

            // Retorna os genes de um indivíduo específico
            getIndividualGenes(index) {
                 if (index >= 0 && index < this.population.length) {
                     return this.population[index].genes;
                 } else {
                     console.error(`Índice de indivíduo inválido: ${index}`);
                     // Retorna genes aleatórios como fallback para evitar crash total
                     return Array(this.numGenes).fill(0).map(() => Math.random() * 2 - 1);
                 }
            }

            getBestFitness() {
                return this.population[0] ? this.population[0].fitness : 0;
            }
        }

        // --- Funções de Visualização ---

        function drawNeuralNetwork(ctx, nn) {
            // Check if the new activation property exists
            const hiddenActivations2 = nn.hiddenActivations2 || [];

            const layers = [
                { neurons: nn.lastInputs || [], labels: ["Distância", "Alt Obst", "Veloc Obst"] },
                { neurons: nn.hiddenActivations1 || [], labels: [] }, // Hidden Layer 1
                { neurons: hiddenActivations2, labels: [] },           // Hidden Layer 2 <-- NEW
                { neurons: nn.lastOutput || [0], labels: ["Pular?"] }   // Output Layer
            ];

            const neuronRadius = 12; // Slightly smaller radius
            const layerSpacing = 100; // Adjust spacing if needed
            const verticalPadding = 30;
            const maxNeuronsHeight = Math.max(...layers.map(l => l.neurons.length)) * 70; // Estimate height needed
            // Adjust canvas height dynamically or ensure it's large enough
            // ctx.canvas.height = Math.max(ctx.canvas.height, maxNeuronsHeight + 2 * verticalPadding);


            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            // Desenha neurônios e conexões
            layers.forEach((layer, layerIdx) => {
                const x = 30 + layerIdx * layerSpacing;
                // Filter out potential undefined/null values if activation arrays weren't initialized properly
                const neurons = layer.neurons.filter(n => typeof n === 'number');
                const numNeuronsInLayer = neurons.length;
                // Calculate vertical spacing to center the layer
                const totalLayerHeight = (numNeuronsInLayer - 1) * 70; // 70px vertical spacing between neurons
                const startY = (ctx.canvas.height - totalLayerHeight) / 2;


                neurons.forEach((neuron, neuronIdx) => {
                    const y = startY + (neuronIdx * 70);

                    // Draw neuron
                    ctx.beginPath();
                    ctx.arc(x, y, neuronRadius, 0, Math.PI * 2);
                    ctx.fillStyle = '#aaddff';
                    ctx.fill();
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1; // Reset line width
                    ctx.stroke();

                    // Text value
                    ctx.fillStyle = 'black';
                    ctx.font = '9px Arial'; // Smaller font
                    ctx.textAlign = 'center';
                    ctx.fillText(neuron.toFixed(2), x, y + 4);

                    // Labels
                    if (layer.labels && layer.labels[neuronIdx]) {
                         ctx.font = '10px Arial';
                         ctx.fillText(layer.labels[neuronIdx], x, y - (neuronRadius + 5));
                    }

                    // Connections to the *next* layer
                    if (layerIdx < layers.length - 1) {
                        const nextLayer = layers[layerIdx + 1];
                        const numNeuronsInNextLayer = nextLayer.neurons.length;
                        const nextLayerTotalHeight = (numNeuronsInNextLayer - 1) * 70;
                        const nextLayerStartY = (ctx.canvas.height - nextLayerTotalHeight) / 2;


                        nextLayer.neurons.forEach((_, nextNeuronIdx) => {
                            const nextX = x + layerSpacing;
                            const nextY = nextLayerStartY + (nextNeuronIdx * 70);

                            ctx.beginPath();
                            ctx.moveTo(x + neuronRadius, y);
                            ctx.lineTo(nextX - neuronRadius, nextY);

                            // --- Determine weight value for color/thickness (Example) ---
                            let weight = 0;
                            try {
                                if (layerIdx === 0) weight = nn.weights_in_h1[neuronIdx][nextNeuronIdx];
                                else if (layerIdx === 1) weight = nn.weights_h1_h2[neuronIdx][nextNeuronIdx];
                                else if (layerIdx === 2) weight = nn.weights_h2_out[neuronIdx][nextNeuronIdx];
                            } catch (e) { /* Ignore potential errors if weights aren't structured as expected */ }

                            // --- Style based on weight ---
                            const absWeight = Math.abs(weight);
                            ctx.lineWidth = Math.max(0.2, Math.min(absWeight * 1.5, 2.0)); // Thickness based on weight magnitude
                            ctx.strokeStyle = weight > 0 ? `rgba(0, 150, 0, ${0.2 + absWeight * 0.6})` // Green for positive
                                            : `rgba(150, 0, 0, ${0.2 + absWeight * 0.6})`; // Red for negative

                            ctx.stroke();
                        });
                    }
                });
            });
        }


        function drawFitnessGraph(ctx, bestHistory, worstHistory) {
             const canvasWidth = ctx.canvas.width;
             const canvasHeight = ctx.canvas.height;
             ctx.clearRect(0, 0, canvasWidth, canvasHeight);

             // --- Slice both histories to get the last 50 points ---
             const pointsToShow = 50;
             const startBestIndex = Math.max(1, bestHistory.length - pointsToShow);
             const startWorstIndex = Math.max(1, worstHistory.length - pointsToShow); // Should be same as best

             const slicedBestHistory = bestHistory.slice(startBestIndex);
             const slicedWorstHistory = worstHistory.slice(startWorstIndex); // Slice worst scores too

             const historyLength = slicedBestHistory.length; // Use length of sliced data

             if (historyLength === 0) return;

             const padding = 30;
             const chartWidth = canvasWidth - 2 * padding;
             const chartHeight = canvasHeight - 2 * padding;

             // Calculate overall max score from the visible best scores for scaling
             const maxScore = Math.max(...slicedBestHistory, 1);

             // --- Adjust bar width and spacing for two bars ---
             const totalBarSpace = Math.max(1, chartWidth / historyLength); // Total space per generation pair
             const barGap = 3; // Gap between generations
             const barWidth = Math.max(1, (totalBarSpace - barGap) / 2); // Width for each bar (best/worst)

             // Desenha Eixos (same as before)
             ctx.strokeStyle = '#aaa';
             ctx.lineWidth = 1;
             ctx.beginPath(); ctx.moveTo(padding, padding); ctx.lineTo(padding, canvasHeight - padding); ctx.stroke(); // Y Axis
             ctx.beginPath(); ctx.moveTo(padding, canvasHeight - padding); ctx.lineTo(canvasWidth - padding, canvasHeight - padding); ctx.stroke(); // X Axis

             // Desenha Barras (Best and Worst)
             for (let i = 0; i < historyLength; i++) {
                 const currentBestScore = slicedBestHistory[i];
                 const currentWorstScore = slicedWorstHistory[i];

                 const bestBarHeight = currentBestScore;
                 const worstBarHeight = currentWorstScore;

                 // X position for the start of this generation's bars
                 const xStart = padding + i * totalBarSpace;
                 const yBest = canvasHeight - padding - bestBarHeight;
                 const yWorst = canvasHeight - padding - worstBarHeight;

                 // Draw Best Score Bar
                 ctx.fillStyle = '#3498db'; // Blue
                 ctx.fillRect(xStart, yBest, barWidth, bestBarHeight);

                 // Draw Worst Score Bar (next to best bar)
                 ctx.fillStyle = '#e74c3c'; // Red
                 ctx.fillRect(xStart + barWidth, yWorst, barWidth, worstBarHeight); // Position it right after the blue bar

                 // Adiciona rótulo da geração (adjust index based on startIndex)
                 const generationNumber = startBestIndex + i + 1;
                 // Label less frequently if many bars are shown
                 const labelFrequency = (historyLength > 30) ? 10 : 5;
                 if (i % labelFrequency === 0 || i === historyLength - 1) {
                     ctx.fillStyle = '#555';
                     ctx.font = '10px Arial';
                     ctx.textAlign = 'center';
                     // Center label under the pair of bars
                     ctx.fillText(generationNumber, xStart + barWidth, canvasHeight - padding + 15);
                 }
             }

              // Label Eixo Y (Max Score of visible data)
             ctx.fillStyle = '#555';
             ctx.font = '10px Arial';
             ctx.textAlign = 'right';
             ctx.fillText(maxScore.toFixed(0), padding - 5, padding + 5);
             ctx.fillText('0', padding - 5, canvasHeight - padding + 5);
             ctx.textAlign = 'start'; // Reset alignment
        }

        // --- Lógica Principal do Jogo ---

        function spawnObstacle() {
            obstacles.push(new Obstacle());
            // Intervalo entre obstáculos proporcional à pontuação
            const minInterval = Math.max(40, 100 - players[0].score / 10);
            nextObstacleFrame = frameCount + minInterval + Math.random() * 50;
        }

        function resetGame() {
            console.log(`Fim da Geração ${generation}. Avaliando...`);

            // 1. Coleta Fitness (Scores)
            const fitnessScores = players.map(p => p.score);

            // Armazena a melhor e pior pontuação desta geração para os gráficos
            const bestFitnessThisGen = Math.max(...fitnessScores, 1); // Use 0 if empty
            const worstFitnessThisGen = Math.min(...fitnessScores, 1); // Use 0 if empty
            bestScoresHistory.push(bestFitnessThisGen);
            worstScoresHistory.push(worstFitnessThisGen);
            document.getElementById('bestScore').textContent = bestFitnessThisGen.toFixed(0);

            // Atualiza o gráfico (passando ambos os históricos)
            drawFitnessGraph(graphCtx, bestScoresHistory, worstScoresHistory);

            // 2. Avalia e Gera Nova População na ES
            evolutionaryStrategy.evaluate(fitnessScores);
            evolutionaryStrategy.generateNewPopulation();


            // 3. Reseta o estado do jogo
            obstacles = [];
            frameCount = 0;
            activePlayers = NUM_PLAYERS;
            generation++;
            document.getElementById('generation').textContent = generation;
            nextObstacleFrame = 100; // Reseta timer do obstáculo

            // const numOutputs = NUM_OUTPUTS; // Already defined globally
            // Create a template brain to get the correct number of genes
            const brainTemplate = new MLP(NUM_INPUTS, HIDDEN_UNITS_1, HIDDEN_UNITS_2, NUM_OUTPUTS);
            const numGenes = brainTemplate.getNumGenes();

            // Initialize ES with the correct number of genes
            evolutionaryStrategy = new EvolutionaryStrategy(
                NUM_PLAYERS, MUTATION_RATE, MUTATION_AMOUNT, numGenes
            );

            // 4. Cria novos jogadores com os genes da nova população
            players = [];
            for (let i = 0; i < NUM_PLAYERS; i++) {
                // Pass all required hidden layer sizes to the constructor
                const brain = new MLP(NUM_INPUTS, HIDDEN_UNITS_1, HIDDEN_UNITS_2, NUM_OUTPUTS);
                var genes = evolutionaryStrategy.getIndividualGenes(i);

                // Comment out the pre-trained gene loading for now
                /*
                if (i === 0 && genesP1) { // Check if genesP1 exists
                    // Ensure genesP1 has the correct length before trying to set
                    if(genesP1.length === numGenes) {
                        genes = genesP1;
                    } else {
                        console.warn("genesP1 has incorrect length for the new network structure. Using random genes.");
                    }
                }
                */

                brain.setGenes(genes);
                players.push(new Player(PLAYER_COLORS[i % PLAYER_COLORS.length], brain));
            }

            // Comment out the specific P1 brain creation for now
            /*
            const brainP1 = new MLP(NUM_INPUTS, HIDDEN_UNITS_1, HIDDEN_UNITS_2, NUM_OUTPUTS);
            if(genesP1 && genesP1.length === numGenes) {
                brainP1.setGenes(genesP1);
                //players[NUM_PLAYERS -1]=new Player("black", brainP1, 45);
            } else {
                 console.warn("Cannot create specific P1 player, genesP1 invalid.");
            }
            */

            console.log(`Iniciando Geração ${generation} com nova população.`);
        }

        function update() {
            frameCount++;
            activePlayers = 0; // Recalcula a cada frame

            // Atualiza Jogadores
            players.forEach(player => {
                if (player.isAlive) {
                    player.update();
                    activePlayers++;
                }
            });

            // Atualiza Obstáculos
            if (frameCount >= nextObstacleFrame && activePlayers > 0) {
                spawnObstacle();
            }

            // Move e remove obstáculos fora da tela
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].update();
                if (obstacles[i].isOffscreen()) {
                    obstacles.splice(i, 1);
                }
            }

            // Verifica Colisões
            players.forEach(player => {
                if (!player.isAlive) return; // Não verifica colisão se já estiver morto

                for (const obstacle of obstacles) {
                    if (player.checkCollision(obstacle)) {
                        player.isAlive = false;
                        // Não decrementa activePlayers aqui, será contado no próximo frame
                        break; // Um obstáculo é suficiente para matar
                    }
                }
            });

            // Verifica se todos os jogadores morreram
            if (activePlayers === 0) {
                resetGame();
            }
        }

        function draw() {
            // Limpa o Canvas do Jogo
            gameCtx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // Desenha Céu (opcional, pode usar o background do canvas)
            gameCtx.fillStyle = '#e0e0ff';
            gameCtx.fillRect(0, 0, GAME_WIDTH, GROUND_Y);

            // Desenha o Chão
            gameCtx.fillStyle = '#654321'; // Marrom
            gameCtx.fillRect(0, GROUND_Y, GAME_WIDTH, GAME_HEIGHT - GROUND_Y);

            // Desenha Obstáculos
            obstacles.forEach(obstacle => obstacle.draw(gameCtx));

            // Desenha Jogadores
            players.forEach(player => player.draw(gameCtx));

            // Desenha a Rede Neural do Jogador 0 (se ele existir e tiver cérebro)
            if (players.length > 0 && players[0].brain) {
                // Passa o contexto, a instância do Perceptron do jogador 0
                    // Encontra o jogador com maior pontuação
                    let bestPlayer = players[0];
                    for (let i = 1; i < players.length; i++) {
                        if (players[i].score > bestPlayer.score) {
                            bestPlayer = players[i];
                        }
                    }
                    drawNeuralNetwork(nnCtx, bestPlayer.brain);
            } else {
                // Limpa o canvas da NN se não houver jogador 0
                nnCtx.clearRect(0, 0, nnCanvas.width, nnCanvas.height);
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop); // Chama o próximo frame
        }

        // --- Inicialização ---
        function init() {
            // const numOutputs = NUM_OUTPUTS; // Already defined globally
            const brainTemplate = new MLP(NUM_INPUTS, HIDDEN_UNITS_1, HIDDEN_UNITS_2, NUM_OUTPUTS);
            const numGenes = brainTemplate.getNumGenes();
            
            evolutionaryStrategy = new EvolutionaryStrategy(
                NUM_PLAYERS, MUTATION_RATE, MUTATION_AMOUNT, numGenes
            );

             // Cria os jogadores iniciais com genes da primeira população aleatória
            players = [];
            for (let i = 0; i < NUM_PLAYERS; i++) {
                 // Pass all required hidden layer sizes to the constructor
                const brain = new MLP(NUM_INPUTS, HIDDEN_UNITS_1, HIDDEN_UNITS_2, NUM_OUTPUTS);
                var genes = evolutionaryStrategy.getIndividualGenes(i);

                // Comment out pre-trained gene loading
                /*
                if (i === 0 && genesP1) {
                    if(genesP1.length === numGenes) {
                        genes = genesP1;
                    } else {
                         console.warn("genesP1 has incorrect length for the new network structure. Using random genes.");
                    }
                }
                */

                brain.setGenes(genes);
                players.push(new Player(PLAYER_COLORS[i % PLAYER_COLORS.length], brain));
            }

            // Comment out specific P1 creation
            /*
            const brainP1 = new MLP(NUM_INPUTS, HIDDEN_UNITS_1, HIDDEN_UNITS_2, NUM_OUTPUTS);
            // brainP1.x -= 12; // Cannot set x on brain
            // brainP1.color = 'black'; // Cannot set color on brain
            if(genesP1 && genesP1.length === numGenes) {
                brainP1.setGenes(genesP1);
                // players[NUM_PLAYERS -1]=new Player("black", brainP1, 55);
            } else {
                 console.warn("Cannot create specific P1 player, genesP1 invalid.");
            }
            */

            activePlayers = NUM_PLAYERS;
            frameCount = 0;
            generation = 1;
            bestScoresHistory = []; // Limpa histórico no início
            worstScoresHistory = []; // <-- ADD THIS LINE: Clear worst history too

            document.getElementById('generation').textContent = generation;
            document.getElementById('bestScore').textContent = '0';


            // Limpa o gráfico inicial
            graphCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);
            drawFitnessGraph(graphCtx, [], []); // <-- MODIFY THIS CALL: Pass empty worst history

             console.log("Jogo inicializado. Iniciando Geração 1.");
            // Inicia o loop do jogo
            gameLoop();
        }

        // Inicia o jogo quando a página carregar
        window.onload = init;

    </script>
</body>
</html>