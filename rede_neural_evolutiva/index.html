<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo de Pular Obstáculos com IA (ES)</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Alinha no topo */
            font-family: sans-serif;
            margin-top: 20px;
            background-color: #f0f0f0;
        }
        canvas {
            border: 1px solid black;
            background-color: #e0e0ff; /* Céu azul claro */
            margin: 5px;
        }
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #visContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-left: 20px;
        }
        #info {
            margin-bottom: 10px;
            font-size: 14px;
        }
        #graphContainer canvas {
             background-color: #ffffff;
        }
        h3 {
            margin-top: 15px;
            margin-bottom: 5px;
            text-align: center;
        }
        /* Estilos para syntax highlighting do JSON */
        #savedJsonContent .string { color: green; }
        #savedJsonContent .number { color: darkorange; }
        #savedJsonContent .boolean { color: blue; }
        #savedJsonContent .null { color: magenta; }
        #savedJsonContent .key { color: red; }
        
        /* Estilo para o contêiner da visualização do JSON */
        #jsonViewer {
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-top: 20px;
            padding: 10px;
        }
        
        #savedJsonInfo {
            background-color: #f9f9f9;
            padding: 5px;
            border-radius: 3px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="info">Geração: <span id="generation">1</span> | Melhor Pontuação da Geração: <span id="bestScore">0</span>
            <button id="saveBestBtn" style="margin-left: 10px; background-color: #4CAF50; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">Copiar Melhor</button>
            <button id="loadBestBtn" style="margin-left: 5px; background-color: #2980b9; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">Adicionar Salvo</button>
        </div>
        <div id="eliteInfo" style="font-size: 14px; margin-bottom: 5px;">Jogadores Elite: 0 ouro, 0 prata</div>
        <canvas id="gameCanvas" width="600" height="300"></canvas>
        <div id="graphContainer">
             <h3>Melhores Pontuações por Geração</h3>
             <canvas id="graphCanvas" width="600" height="350"></canvas>
        </div>
    </div>
    <div id="visContainer">
         <h3>Rede Neural (Jogador 0)</h3>
         <canvas id="nnCanvas" width="400" height="800"></canvas>
         
         <div id="jsonViewer" style="margin-top: 20px; width: 400px;">
             <h3>Melhor Indivíduo Salvo</h3>
             <div id="savedJsonInfo" style="margin-bottom: 10px; font-size: 12px; color: #666;">Carregando...</div>
             <pre id="savedJsonContent" style="background: #f5f5f5; padding: 10px; border: 1px solid #ddd; border-radius: 4px; height: 300px; overflow: auto; font-size: 11px; line-height: 1.3;"></pre>
         </div>
    </div>

    <script>
        // --- Configurações Globais ---
        const gameCanvas = document.getElementById('gameCanvas');
        const gameCtx = gameCanvas.getContext('2d');
        const nnCanvas = document.getElementById('nnCanvas');
        const nnCtx = nnCanvas.getContext('2d');
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');

        // Comment out or remove the old genesP1, as it's the wrong size now
        /*
        const genesP1 = [
            "-0.915",
            "0.799",
            "-0.754",
            "-0.092",
            "-0.086",
            "-0.680",
            "-0.593",
            "-0.585",
            "0.311",
            "0.608",
            "-0.143",
            "0.360",
            "0.087",
            "0.472",
            "0.217",
            "-0.262",
            "0.630",
            "-0.325",
            "-0.371",
            "0.248",
            "0.170"
        ];
        */
        let genesP1 = null; // Set to null or an empty array initially

        const GAME_WIDTH = gameCanvas.width;
        const GAME_HEIGHT = gameCanvas.height;
        const GROUND_Y = GAME_HEIGHT - 50;
        const GRAVITY = 0.6;
        const JUMP_STRENGTH = -13;
        const OBSTACLE_SPEED = 5;
        const OBSTACLE_COLOR = 'darkred';
        const PLAYER_COLORS = [
            'blue', 'green', 'orange', 'purple', 'red', 'magenta', 
            'yellow', 'black-green', 'pink', 'teal', 'crimson', 'indigo', 
            'coral', 'maroon', 'olive', 'navy', 'turquoise', 'gold', 
            'plum', 'sienna'
        ];

        const NUM_PLAYERS = 20; // Número de indivíduos na população da ES
        const MUTATION_RATE = 0.2; // Taxa de mutação
        const MUTATION_AMOUNT = 0.99; // Magnitude da mutação
        const HIDDEN_UNITS_1 = 8; // Renamed from HIDDEN_UNITS
        const HIDDEN_UNITS_2 = 4; // Size of the new second hidden layer
        const NUM_INPUTS = 3;
        const NUM_OUTPUTS = 1;

        let players = [];
        let obstacles = [];
        let frameCount = 0;
        let generation = 1;
        let activePlayers = NUM_PLAYERS;
        let nextObstacleFrame = 100; // Quando o próximo obstáculo aparece
        let evolutionaryStrategy;
        let bestScoresHistory = []; // Armazena as melhores pontuações de cada geração
        let worstScoresHistory = []; // Armazena as piores pontuações de cada geração

        // Variáveis para armazenar o melhor indivíduo
        let bestEverFitness = 0;
        let bestEverNeuralNetwork = null;
        let bestEverGeneration = 0;

        // --- Classe Perceptron (Rede Neural) ---
        class MLP {
            constructor(numInputs, hiddenUnits1, hiddenUnits2, numOutputs) {
                // Use constants directly for consistency, ignore constructor args for now
                numInputs = NUM_INPUTS;
                hiddenUnits1 = HIDDEN_UNITS_1;
                hiddenUnits2 = HIDDEN_UNITS_2; // Use the new constant
                numOutputs = NUM_OUTPUTS;

                // Remove old single-layer properties if they exist
                // delete this.weights;
                // delete this.bias;
                // delete this.lastActivation;

                this.numInputs = numInputs;
                this.hiddenUnits1 = hiddenUnits1;
                this.hiddenUnits2 = hiddenUnits2; // Store the size
                this.numOutputs = numOutputs;

                // --- Initialization with Xavier ---
                const xavier = (fanIn, fanOut) => Math.sqrt(6 / (fanIn + fanOut));

                // Layer 1 (Input -> Hidden1)
                this.weights_in_h1 = Array.from({length: numInputs}, () =>
                    Array.from({length: hiddenUnits1}, () => (Math.random() * 2 - 1) * xavier(numInputs, hiddenUnits1)));
                this.bias_h1 = Array.from({length: hiddenUnits1}, () => (Math.random() * 2 - 1) * xavier(numInputs, hiddenUnits1) * 0.01);

                // Layer 2 (Hidden1 -> Hidden2)
                this.weights_h1_h2 = Array.from({length: hiddenUnits1}, () =>
                    Array.from({length: hiddenUnits2}, () => (Math.random() * 2 - 1) * xavier(hiddenUnits1, hiddenUnits2)));
                this.bias_h2 = Array.from({length: hiddenUnits2}, () => (Math.random() * 2 - 1) * xavier(hiddenUnits1, hiddenUnits2) * 0.01);

                // Layer 3 (Hidden2 -> Output)
                this.weights_h2_out = Array.from({length: hiddenUnits2}, () =>
                    Array.from({length: numOutputs}, () => (Math.random() * 2 - 1) * xavier(hiddenUnits2, numOutputs)));
                this.bias_out = Array.from({length: numOutputs}, () => (Math.random() * 2 - 1) * xavier(hiddenUnits2, numOutputs) * 0.01);


                // --- Store activations for visualization ---
                this.lastInputs = Array(numInputs).fill(0);
                this.hiddenActivations1 = Array(hiddenUnits1).fill(0);
                this.hiddenActivations2 = Array(hiddenUnits2).fill(0); // For the second hidden layer
                this.lastOutput = Array(numOutputs).fill(0);
            }

            // Usar ReLU para evitar vanishing gradient
            relu(x) {
                return Math.max(0, x);
            }

            sigmoid(x) {
                return 1 / (1 + Math.exp(-x));
            }

            feedForward(inputs) {
                if (inputs.length !== this.numInputs) {
                    console.error(`Input length mismatch: expected ${this.numInputs}, got ${inputs.length}`);
                    // Pad or truncate inputs as a fallback, or return an error/default value
                    inputs = inputs.slice(0, this.numInputs);
                    while (inputs.length < this.numInputs) inputs.push(0);
                }
                this.lastInputs = inputs;

                // Camada oculta 1 com ReLU
                this.hiddenActivations1 = this.bias_h1.map((bias, i) => {
                    const sum = inputs.reduce((acc, val, j) => acc + val * this.weights_in_h1[j][i], bias);
                    return this.relu(sum);
                });

                // Camada oculta 2 com ReLU
                this.hiddenActivations2 = this.bias_h2.map((bias, i) => {
                    const sum = this.hiddenActivations1.reduce((acc, val, j) => acc + val * this.weights_h1_h2[j][i], bias);
                    return this.relu(sum);
                });

                // Camada de saída com sigmoid
                const outputs = this.bias_out.map((bias, i) => {
                    // Use hiddenActivations2 as input for the output layer
                    const sum = this.hiddenActivations2.reduce((acc, val, j) => acc + val * this.weights_h2_out[j][i], bias);
                    return this.sigmoid(sum);
                });

                this.lastOutput = outputs; // Store the array
                // Return 1 if the first output neuron is > 0.5, else 0
                return (outputs.length > 0 && outputs[0] > 0.5) ? 1 : 0;
            }

            getGenes() {
                const genes = [];
                // Layer 1
                this.weights_in_h1.forEach(row => genes.push(...row));
                genes.push(...this.bias_h1);
                // Layer 2
                this.weights_h1_h2.forEach(row => genes.push(...row));
                genes.push(...this.bias_h2);
                // Layer 3
                this.weights_h2_out.forEach(row => genes.push(...row));
                genes.push(...this.bias_out);
                return genes;
            }

            setGenes(genes) {
                let idx = 0;
                try {
                    // Layer 1 (Input -> Hidden1)
                    for(let i = 0; i < this.numInputs; i++) {
                        for(let j = 0; j < this.hiddenUnits1; j++) {
                            if (idx >= genes.length) throw new Error("Gene array too short");
                            this.weights_in_h1[i][j] = parseFloat(genes[idx++]);
                        }
                    }
                    for(let i = 0; i < this.hiddenUnits1; i++) {
                         if (idx >= genes.length) throw new Error("Gene array too short");
                        this.bias_h1[i] = parseFloat(genes[idx++]);
                    }
                    // Layer 2 (Hidden1 -> Hidden2)
                    for(let i = 0; i < this.hiddenUnits1; i++) {
                        for(let j = 0; j < this.hiddenUnits2; j++) {
                             if (idx >= genes.length) throw new Error("Gene array too short");
                            this.weights_h1_h2[i][j] = parseFloat(genes[idx++]);
                        }
                    }
                    for(let i = 0; i < this.hiddenUnits2; i++) {
                         if (idx >= genes.length) throw new Error("Gene array too short");
                        this.bias_h2[i] = parseFloat(genes[idx++]);
                    }
                    // Layer 3 (Hidden2 -> Output)
                    for(let i = 0; i < this.hiddenUnits2; i++) {
                        for(let j = 0; j < this.numOutputs; j++) {
                             if (idx >= genes.length) throw new Error("Gene array too short");
                            this.weights_h2_out[i][j] = parseFloat(genes[idx++]);
                        }
                    }
                    for(let i = 0; i < this.numOutputs; i++) {
                         if (idx >= genes.length) throw new Error("Gene array too short");
                        this.bias_out[i] = parseFloat(genes[idx++]);
                    }

                     if (idx !== this.getNumGenes()) {
                         console.warn(`Gene count mismatch after setting: expected ${this.getNumGenes()}, processed ${idx}`);
                     }

                } catch (e) {
                    console.error("Error setting genes:", e, "Index:", idx, "Gene Array Length:", genes.length);
                     // Optionally reset weights to default random if loading fails critically
                }
            }

            getNumGenes() {
                // Este método calcula o número total de genes (pesos e vieses) na rede neural
                
                // Cálculo para a primeira camada:
                // - Pesos entre camada de entrada e primeira camada oculta: numInputs * hiddenUnits1
                // - Vieses da primeira camada oculta: hiddenUnits1
                const genesLayer1 = (this.numInputs * this.hiddenUnits1) + this.hiddenUnits1;
                
                // Cálculo para a segunda camada:
                // - Pesos entre primeira e segunda camada oculta: hiddenUnits1 * hiddenUnits2
                // - Vieses da segunda camada oculta: hiddenUnits2
                const genesLayer2 = (this.hiddenUnits1 * this.hiddenUnits2) + this.hiddenUnits2;
                
                // Cálculo para a camada de saída:
                // - Pesos entre segunda camada oculta e camada de saída: hiddenUnits2 * numOutputs
                // - Vieses da camada de saída: numOutputs
                const genesLayer3 = (this.hiddenUnits2 * this.numOutputs) + this.numOutputs;
                
                // Retorna o número total de genes somando todas as camadas
                // Isso é essencial para o algoritmo evolutivo saber quantos genes precisa gerar
                return genesLayer1 + genesLayer2 + genesLayer3;
            }
        }

        // --- Classe Jogador ---
        class Player {
            constructor(color, brain, height) {
                this.width = Math.random() * 5 + 25;
                this.height = height ? height : Math.random() * 10 + 40;
                this.x = Math.random() * 2 + 48;
                this.y = GROUND_Y - this.height;
                this.velocityY = 0;
                this.isJumping = false;
                this.color = color;
                this.isAlive = true;
                this.score = 0;
                this.brain = brain; // Instância do Perceptron
            }

            getInputs(obstacles) {
                let closestObstacle = null;
                let minDistance = Infinity;

                for (const obstacle of obstacles) {
                    const distance = obstacle.x - (this.x + this.width);
                    if (distance >= 0 && distance < minDistance) {
                        minDistance = distance;
                        closestObstacle = obstacle;
                    }
                }

                if (!closestObstacle) {
                    return [1.0, 0.5, 0]; // Distância máxima, altura obstáculo e velocidade obstáculo 0
                }

                const inputDistance = minDistance / GAME_WIDTH;
                //const inputPlayerY = (GROUND_Y - (this.y + this.height)) / GROUND_Y;
                const inputObstacleHeight = closestObstacle.height / GROUND_Y;
                const inputObstacleSpeed = (closestObstacle.speed - 5) / 5; // Normaliza velocidade (0.5-0.9)

                return [inputDistance, inputObstacleHeight, inputObstacleSpeed];
            }

            think() {
                const inputs = this.getInputs(obstacles);
                const output = this.brain.feedForward(inputs);
                if (output === 1) {
                    this.jump();
                }
            }

            jump() {
                if (!this.isJumping) {
                    this.velocityY = JUMP_STRENGTH;
                    this.isJumping = true;
                }
            }

            update() {
                if (!this.isAlive) return;

                // Aplica gravidade
                this.velocityY += GRAVITY;
                this.y += this.velocityY;


                // Bonus por se manter próximo ao chão
                const groundBonus = (GROUND_Y - (this.y + this.height)) < 10 ? 0.5 : 0;

                // Penalidade por pular desnecessariamente
                const jumpPenalty = this.isJumping ? -0.6 : 0;

                const weightPenalty = this.brain.getGenes().reduce((sum, gene) => sum + Math.abs(gene), 0) * -0.02;
                this.score += 1 + groundBonus + jumpPenalty + weightPenalty;

                //console.log("Ativações ocultas:", this.brain.hiddenActivations);
                //console.log("Saída:", this.brain.lastOutput);


                // Verifica colisão com o chão
                if (this.y + this.height > GROUND_Y) {
                    this.y = GROUND_Y - this.height;
                    this.velocityY = 0;
                    this.isJumping = false;
                }

                // Lógica da IA para decidir pular
                this.think();
            }


            draw(ctx) {
                if (!this.isAlive) return;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }

            checkCollision(obstacle) {
                // Verificação simples de colisão AABB (Axis-Aligned Bounding Box)
                return (
                    this.x < obstacle.x + obstacle.width &&
                    this.x + this.width > obstacle.x &&
                    this.y < obstacle.y + obstacle.height &&
                    this.y + this.height > obstacle.y
                );
            }
        }

        // --- Classe Obstáculo ---
        class Obstacle {
            constructor() {
                this.height = 30 + Math.random() * 60; // Altura entre 30-100
                this.width = 20 + Math.random() * 40; // Largura entre 20-70
                this.speed = OBSTACLE_SPEED + Math.random() * 5; // Velocidade 5-7
                this.x = GAME_WIDTH;
                this.y = GROUND_Y - this.height; // Sempre no chão
                this.color = OBSTACLE_COLOR;
            }

            update() {
                this.x -= this.speed;
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }

            isOffscreen() {
                return this.x + this.width < 0;
            }
        }

        // --- Classe Estratégia Evolutiva (ES) ---
        class EvolutionaryStrategy {
            constructor(populationSize, mutationRate, mutationAmount, numGenes) {
                this.populationSize = populationSize;
                this.numGenes = numGenes;
                this.population = this.initializePopulation();
                this.mutationRate = mutationRate;
                this.mutationAmount = mutationAmount;
            }
            
            selection() {
                // Manter os 20% melhores (elitismo)
                const eliteCount = Math.ceil(this.populationSize * 0.2);
                return this.population.slice(0, eliteCount);
            }
            
            // Adicionar método de crossover (recombinação)
            crossover(parent1, parent2) {
                const childGenes = [];
                for (let i = 0; i < this.numGenes; i++) {
                    childGenes.push(Math.random() < 0.5 ? parent1.genes[i] : parent2.genes[i]);
                }
                return childGenes;
            }
            
            // Modificar o método de geração de nova população para incluir crossover
            generateNewPopulation() {
                // Reduzir mutação mais lentamente
                this.mutationAmount *= 0.995; // Decaimento de 0.5% por geração
                this.mutationRate *= 0.998; // Decaimento de 0.2% por geração
                
                // Limites mínimos mais altos
                this.mutationAmount = Math.max(0.15, this.mutationAmount);
                this.mutationRate = Math.max(0.08, this.mutationRate);
                
                // Selecionar pais
                const parents = this.selection();
                const newPopulation = [];
                
                // Adicionar elites diretamente (10% melhores sem mutação)
                const eliteCount = Math.ceil(this.populationSize * 0.1);
                for (let i = 0; i < eliteCount; i++) {
                    newPopulation.push(this.createIndividual([...this.population[i].genes]));
                }
                
                // Gerar o resto da população com crossover e mutação
                while (newPopulation.length < this.populationSize) {
                    // Selecionar dois pais aleatórios do grupo de selecionados
                    const parent1 = parents[Math.floor(Math.random() * parents.length)];
                    const parent2 = parents[Math.floor(Math.random() * parents.length)];
                    
                    // Aplicar crossover
                    let childGenes = this.crossover(parent1, parent2);
                    
                    // Aplicar mutação
                    childGenes = this.mutate(childGenes);
                    
                    // Adicionar à nova população
                    newPopulation.push(this.createIndividual(childGenes));
                }
                
                this.population = newPopulation;
            }

            // Inicializa a população com genes aleatórios [-1, 1]
            initializePopulation() {
                // O fitness é a pontuação que cada indivíduo (jogador) consegue no jogo
                // Quanto maior o fitness, melhor o jogador se saiu e mais chances ele tem
                // de passar seus genes para a próxima geração
                const pop = [];
                for (let i = 0; i < this.populationSize; i++) {
                    pop.push({
                        genes: Array(this.numGenes).fill(0).map(() => Math.random() * 2 - 1),
                        fitness: 0 // Começa com 0 pois ainda não jogou
                    });
                }
                return pop;
            }

            // Cria um novo indivíduo (usado na geração)
            createIndividual(genes) {
                return { genes: genes, fitness: 0 };
            }

            // Avalia a população com base nas pontuações (fitness)
            evaluate(fitnessScores) {
                // Verificar se os dados de fitness são válidos
                if (!fitnessScores || fitnessScores.length === 0) {
                    console.error("Array de fitness inválido ou vazio");
                    return;
                }
                
                // Verificar compatibilidade de tamanho
                if (fitnessScores.length !== this.populationSize) {
                    console.warn(`Tamanho do array de fitness (${fitnessScores.length}) não corresponde ao tamanho da população (${this.populationSize})!`);
                    // Ajustar o tamanho do array de fitness se necessário
                    fitnessScores = fitnessScores.slice(0, this.populationSize);
                    while (fitnessScores.length < this.populationSize) {
                        fitnessScores.push(0); // Preencher com zeros se faltar
                    }
                }
                
                // Atribuir fitness aos indivíduos
                for (let i = 0; i < this.populationSize; i++) {
                    // Garante que o indivíduo existe antes de atribuir fitness
                    if (this.population[i]) {
                        this.population[i].fitness = fitnessScores[i] || 0; // Usa 0 se score for undefined/null
                    } else {
                        console.warn(`Indivíduo ${i} não encontrado na população durante avaliação.`);
                    }
                }
                
                // Ordena a população por fitness (do maior para o menor)
                this.population.sort((a, b) => b.fitness - a.fitness);
                
                // Imprime o primeiro (melhor) e último (pior) indivíduo da população ordenada
                if (this.population.length > 0) {
                    console.log("Melhor indivíduo:", {
                        fitness: this.population[0].fitness.toFixed(2),
                        genes: this.population[0].genes.map(g => g.toFixed(3))
                    });
                    
                    if (this.population.length > 1) {
                        console.log("Pior indivíduo:", {
                            fitness: this.population[this.population.length-1].fitness.toFixed(2), 
                            genes: this.population[this.population.length-1].genes.map(g => g.toFixed(3))
                        });
                    }
                }
            }

            // Aplica mutação a um conjunto de genes
            mutate(genes) {
                const mutatedGenes = [...genes];
                for (let i = 0; i < this.numGenes; i++) {
                    if (Math.random() < this.mutationRate) {
                        // Mutação adaptativa (maior impacto em genes extremos)
                        const scale = 1.2 - Math.abs(mutatedGenes[i]);
                        const mutation = (Math.random() * 1.4 - 1) * this.mutationAmount * scale;
                        const oldValue = mutatedGenes[i];
                        mutatedGenes[i] += mutation;
                        
                        // Limitar valores entre -2 e 2
                        mutatedGenes[i] = Math.max(-2, Math.min(2, mutatedGenes[i]));

                        //console.log(`Gene ${i}: ${oldValue.toFixed(4)} -> ${mutatedGenes[i].toFixed(4)} (mutation: ${mutation.toFixed(4)}, scale: ${scale.toFixed(4)})`);
                    }
                }
                return mutatedGenes;
            }

            // Retorna os genes de um indivíduo específico
            getIndividualGenes(index) {
                 if (index >= 0 && index < this.population.length) {
                     return this.population[index].genes;
                 } else {
                     console.error(`Índice de indivíduo inválido: ${index}`);
                     // Retorna genes aleatórios como fallback para evitar crash total
                     return Array(this.numGenes).fill(0).map(() => Math.random() * 2 - 1);
                 }
            }

            getBestFitness() {
                return this.population[0] ? this.population[0].fitness : 0;
            }
        }

        // --- Funções de Visualização ---

        function drawNeuralNetwork(ctx, nn) {
            // Check if the new activation property exists
            const hiddenActivations2 = nn.hiddenActivations2 || [];

            const layers = [
                { neurons: nn.lastInputs || [], labels: ["Distância", "Alt Obst", "Veloc Obst"] },
                { neurons: nn.hiddenActivations1 || [], labels: [] }, // Hidden Layer 1
                { neurons: hiddenActivations2, labels: [] },           // Hidden Layer 2 <-- NEW
                { neurons: nn.lastOutput || [0], labels: ["Pular?"] }   // Output Layer
            ];

            const neuronRadius = 12; // Slightly smaller radius
            const layerSpacing = 100; // Adjust spacing if needed
            const verticalPadding = 30;
            const maxNeuronsHeight = Math.max(...layers.map(l => l.neurons.length)) * 70; // Estimate height needed
            // Adjust canvas height dynamically or ensure it's large enough
            // ctx.canvas.height = Math.max(ctx.canvas.height, maxNeuronsHeight + 2 * verticalPadding);


            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            // Desenha neurônios e conexões
            layers.forEach((layer, layerIdx) => {
                const x = 30 + layerIdx * layerSpacing;
                // Filter out potential undefined/null values if activation arrays weren't initialized properly
                const neurons = layer.neurons.filter(n => typeof n === 'number');
                const numNeuronsInLayer = neurons.length;
                // Calculate vertical spacing to center the layer
                const totalLayerHeight = (numNeuronsInLayer - 1) * 70; // 70px vertical spacing between neurons
                const startY = (ctx.canvas.height - totalLayerHeight) / 2;


                neurons.forEach((neuron, neuronIdx) => {
                    const y = startY + (neuronIdx * 70);

                    // Draw neuron
                    ctx.beginPath();
                    ctx.arc(x, y, neuronRadius, 0, Math.PI * 2);
                    ctx.fillStyle = '#aaddff';
                    ctx.fill();
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1; // Reset line width
                    ctx.stroke();

                    // Text value
                    ctx.fillStyle = 'black';
                    ctx.font = '9px Arial'; // Smaller font
                    ctx.textAlign = 'center';
                    ctx.fillText(neuron.toFixed(2), x, y + 4);

                    // Labels
                    if (layer.labels && layer.labels[neuronIdx]) {
                         ctx.font = '10px Arial';
                         ctx.fillText(layer.labels[neuronIdx], x, y - (neuronRadius + 5));
                    }

                    // Connections to the *next* layer
                    if (layerIdx < layers.length - 1) {
                        const nextLayer = layers[layerIdx + 1];
                        const numNeuronsInNextLayer = nextLayer.neurons.length;
                        const nextLayerTotalHeight = (numNeuronsInNextLayer - 1) * 70;
                        const nextLayerStartY = (ctx.canvas.height - nextLayerTotalHeight) / 2;


                        nextLayer.neurons.forEach((_, nextNeuronIdx) => {
                            const nextX = x + layerSpacing;
                            const nextY = nextLayerStartY + (nextNeuronIdx * 70);

                            ctx.beginPath();
                            ctx.moveTo(x + neuronRadius, y);
                            ctx.lineTo(nextX - neuronRadius, nextY);

                            // --- Determine weight value for color/thickness (Example) ---
                            let weight = 0;
                            try {
                                if (layerIdx === 0) weight = nn.weights_in_h1[neuronIdx][nextNeuronIdx];
                                else if (layerIdx === 1) weight = nn.weights_h1_h2[neuronIdx][nextNeuronIdx];
                                else if (layerIdx === 2) weight = nn.weights_h2_out[neuronIdx][nextNeuronIdx];
                            } catch (e) { /* Ignore potential errors if weights aren't structured as expected */ }

                            // --- Style based on weight ---
                            const absWeight = Math.abs(weight);
                            ctx.lineWidth = Math.max(0.2, Math.min(absWeight * 1.5, 2.0)); // Thickness based on weight magnitude
                            ctx.strokeStyle = weight > 0 ? `rgba(0, 150, 0, ${0.2 + absWeight * 0.6})` // Green for positive
                                            : `rgba(150, 0, 0, ${0.2 + absWeight * 0.6})`; // Red for negative

                            ctx.stroke();
                        });
                    }
                });
            });
        }


        function drawFitnessGraph(ctx, bestHistory, worstHistory) {
             const canvasWidth = ctx.canvas.width;
             const canvasHeight = ctx.canvas.height;
             ctx.clearRect(0, 0, canvasWidth, canvasHeight);

             // Verificar se há dados de histórico
             if (!bestHistory || bestHistory.length === 0) {
                 ctx.fillStyle = '#555';
                 ctx.font = '12px Arial';
                 ctx.textAlign = 'center';
                 ctx.fillText('Sem dados de histórico disponíveis', canvasWidth / 2, canvasHeight / 2);
                 return;
             }

             // Garantir que worstHistory tem o mesmo tamanho que bestHistory
             if (!worstHistory || worstHistory.length !== bestHistory.length) {
                 console.warn('worstHistory inválido ou com tamanho diferente de bestHistory');
                 worstHistory = bestHistory.map(() => 0); // Preencher com zeros
             }

             // --- Slice both histories to get the last 50 points ---
             const pointsToShow = 50;
             const startBestIndex = Math.max(0, bestHistory.length - pointsToShow);
             
             const slicedBestHistory = bestHistory.slice(startBestIndex);
             const slicedWorstHistory = worstHistory.slice(startBestIndex);

             const historyLength = slicedBestHistory.length;

             if (historyLength === 0) return;

             const padding = 30;
             const chartWidth = canvasWidth - 2 * padding;
             const chartHeight = canvasHeight - 2 * padding;

             // Calculate overall max score from the visible best scores for scaling
             const maxScore = Math.max(...slicedBestHistory, 1);

             // --- Adjust bar width and spacing for two bars ---
             const totalBarSpace = Math.max(1, chartWidth / historyLength);
             const barGap = 3;
             const barWidth = Math.max(1, (totalBarSpace - barGap) / 2);

             // Desenha Eixos
             ctx.strokeStyle = '#aaa';
             ctx.lineWidth = 1;
             ctx.beginPath(); ctx.moveTo(padding, padding); ctx.lineTo(padding, canvasHeight - padding); ctx.stroke(); // Y Axis
             ctx.beginPath(); ctx.moveTo(padding, canvasHeight - padding); ctx.lineTo(canvasWidth - padding, canvasHeight - padding); ctx.stroke(); // X Axis

             // Desenha Barras (Best and Worst)
             for (let i = 0; i < historyLength; i++) {
                 const currentBestScore = slicedBestHistory[i] || 0;
                 const currentWorstScore = slicedWorstHistory[i] || 0;

                 // Normaliza os valores para escala do gráfico
                 const bestBarHeight = (currentBestScore / maxScore) * chartHeight;
                 const worstBarHeight = (currentWorstScore / maxScore) * chartHeight;

                 // X position for the start of this generation's bars
                 const xStart = padding + i * totalBarSpace;
                 const yBest = canvasHeight - padding - bestBarHeight;
                 const yWorst = canvasHeight - padding - worstBarHeight;

                 // Draw Best Score Bar
                 ctx.fillStyle = '#3498db'; // Blue
                 ctx.fillRect(xStart, yBest, barWidth, bestBarHeight);

                 // Draw Worst Score Bar (next to best bar)
                 ctx.fillStyle = '#e74c3c'; // Red
                 ctx.fillRect(xStart + barWidth, yWorst, barWidth, worstBarHeight);

                 // Adiciona rótulo da geração
                 const generationNumber = startBestIndex + i + 1;
                 const labelFrequency = (historyLength > 30) ? 10 : 5;
                 if (i % labelFrequency === 0 || i === historyLength - 1) {
                     ctx.fillStyle = '#555';
                     ctx.font = '10px Arial';
                     ctx.textAlign = 'center';
                     ctx.fillText(generationNumber, xStart + barWidth, canvasHeight - padding + 15);
                 }
             }

             // Label Eixo Y
             ctx.fillStyle = '#555';
             ctx.font = '10px Arial';
             ctx.textAlign = 'right';
             ctx.fillText(maxScore.toFixed(0), padding - 5, padding + 5);
             ctx.fillText('0', padding - 5, canvasHeight - padding + 5);
             ctx.textAlign = 'start';
        }

        // --- Lógica Principal do Jogo ---

        function spawnObstacle() {
            obstacles.push(new Obstacle());
            // Intervalo entre obstáculos proporcional à pontuação
            const minInterval = Math.max(40, 100 - players[0].score / 10);
            nextObstacleFrame = frameCount + minInterval + Math.random() * 50;
        }

        function resetGame() {
            console.log(`Fim da Geração ${generation}. Avaliando...`);

            // 1. Identificar os 2 melhores jogadores da geração atual
            const bestPlayers = [...players]
                .sort((a, b) => b.score - a.score) // Ordenar por pontuação (maior primeiro)
                .slice(0, 2); // Pegar os 2 primeiros (melhores)
            
            // Salvar os dados dos cérebros dos melhores jogadores
            const bestPlayersBrains = bestPlayers.map(player => ({
                brain: brainToStructuredFormat(player.brain),
                score: player.score
            }));
            
            // 2. Coleta Fitness (Scores) - Usar apenas os primeiros NUM_PLAYERS jogadores
            // para evitar "tamanho do array de fitness não corresponde ao tamanho da população"
            const fitnessScores = players.slice(0, NUM_PLAYERS).map(p => p.score);

            // Armazena a melhor e pior pontuação desta geração para os gráficos
            const bestFitnessThisGen = Math.max(...fitnessScores, 1); // Use 1 if empty
            const worstFitnessThisGen = Math.min(...fitnessScores, 1); // Use 1 if empty
            bestScoresHistory.push(bestFitnessThisGen);
            worstScoresHistory.push(worstFitnessThisGen);
            document.getElementById('bestScore').textContent = bestFitnessThisGen.toFixed(0);

            // Atualiza o gráfico (passando ambos os históricos)
            drawFitnessGraph(graphCtx, bestScoresHistory, worstScoresHistory);

            // 3. Avalia e Gera Nova População na ES
            evolutionaryStrategy.evaluate(fitnessScores);
            evolutionaryStrategy.generateNewPopulation();

            // 4. Reseta o estado do jogo
            obstacles = [];
            frameCount = 0;
            generation++;
            document.getElementById('generation').textContent = generation;
            nextObstacleFrame = 100; // Reseta timer do obstáculo

            // Create a template brain to get the correct number of genes
            const brainTemplate = new MLP(NUM_INPUTS, HIDDEN_UNITS_1, HIDDEN_UNITS_2, NUM_OUTPUTS);
            const numGenes = brainTemplate.getNumGenes();

            // Initialize ES with the correct number of genes
            evolutionaryStrategy = new EvolutionaryStrategy(
                NUM_PLAYERS, MUTATION_RATE, MUTATION_AMOUNT, numGenes
            );

            // 5. Cria novos jogadores com os genes da nova população
            players = [];
            for (let i = 0; i < NUM_PLAYERS; i++) {
                // Pass all required hidden layer sizes to the constructor
                const brain = new MLP(NUM_INPUTS, HIDDEN_UNITS_1, HIDDEN_UNITS_2, NUM_OUTPUTS);
                var genes = evolutionaryStrategy.getIndividualGenes(i);
                brain.setGenes(genes);
                players.push(new Player(PLAYER_COLORS[i % PLAYER_COLORS.length], brain));
            }
            
            // Inicializa activePlayers com a população base
            activePlayers = NUM_PLAYERS;
            
            // 6. NOVO: Adiciona os 2 melhores jogadores da geração anterior
            if (bestPlayersBrains.length > 0) {
                // Para cada um dos melhores jogadores
                bestPlayersBrains.forEach((playerData, index) => {
                    // Criar um novo cérebro e aplicar os pesos do melhor indivíduo
                    const eliteBrain = new MLP(NUM_INPUTS, HIDDEN_UNITS_1, HIDDEN_UNITS_2, NUM_OUTPUTS);
                    applyStructuredFormatToBrain(eliteBrain, playerData.brain);
                    
                    // Criar cor personalizada para distinguir os indivíduos elite
                    // Primeiro dourado, segundo prata
                    const eliteColor = index === 0 ? 'gold' : 'silver';
                    
                    // Criar o novo jogador elite
                    const elitePlayer = new Player(eliteColor, eliteBrain);
                    
                    // Adicionar ao array de jogadores
                    players.push(elitePlayer);
                    activePlayers++; // Incrementar o contador de jogadores ativos
                    
                    console.log(`Adicionado jogador elite #${index+1} da geração anterior (pontuação: ${playerData.score.toFixed(2)})`);
                });
            }

            console.log(`Iniciando Geração ${generation} com nova população.`);

            // Atualiza a visualização dos jogadores de elite
            updateEliteStatusDisplay();
            
            // Atualiza a visualização do JSON do melhor jogador
            updateJsonViewer();
        }

        function updateEliteStatusDisplay() {
            // Contar quantos jogadores dourados e prateados existem
            const goldCount = players.filter(p => p.color === 'gold').length;
            const silverCount = players.filter(p => p.color === 'silver').length;
            
            // Verificar se o elemento existe
            const infoElement = document.getElementById('eliteInfo');
            
            if (infoElement) {
                // Atualizar o texto do elemento existente
                infoElement.textContent = `Jogadores Elite: ${goldCount} ouro, ${silverCount} prata`;
            } else {
                // Criar um novo elemento para mostrar a informação
                const infoDiv = document.createElement('div');
                infoDiv.id = 'eliteInfo';
                infoDiv.style.fontSize = '14px';
                infoDiv.style.marginBottom = '5px';
                infoDiv.textContent = `Jogadores Elite: ${goldCount} ouro, ${silverCount} prata`;
                
                // Inserir após a div 'info'
                const infoElement = document.getElementById('info');
                if (infoElement && infoElement.parentNode) {
                    infoElement.parentNode.insertBefore(infoDiv, infoElement.nextSibling);
                }
            }
        }

        function update() {
            frameCount++;
            activePlayers = 0; // Recalcula a cada frame

            // Atualiza Jogadores
            players.forEach(player => {
                if (player.isAlive) {
                    player.update();
                    activePlayers++;
                }
            });

            // Atualiza Obstáculos
            if (frameCount >= nextObstacleFrame && activePlayers > 0) {
                spawnObstacle();
            }

            // Move e remove obstáculos fora da tela
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].update();
                if (obstacles[i].isOffscreen()) {
                    obstacles.splice(i, 1);
                }
            }

            // Verifica Colisões
            players.forEach(player => {
                if (!player.isAlive) return; // Não verifica colisão se já estiver morto

                for (const obstacle of obstacles) {
                    if (player.checkCollision(obstacle)) {
                        player.isAlive = false;
                        // Não decrementa activePlayers aqui, será contado no próximo frame
                        break; // Um obstáculo é suficiente para matar
                    }
                }
            });

            // Verifica se todos os jogadores morreram
            if (activePlayers === 0) {
                resetGame();
            }
        }

        function draw() {
            // Limpa o Canvas do Jogo
            gameCtx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // Desenha Céu (opcional, pode usar o background do canvas)
            gameCtx.fillStyle = '#e0e0ff';
            gameCtx.fillRect(0, 0, GAME_WIDTH, GROUND_Y);

            // Desenha o Chão
            gameCtx.fillStyle = '#654321'; // Marrom
            gameCtx.fillRect(0, GROUND_Y, GAME_WIDTH, GAME_HEIGHT - GROUND_Y);

            // Desenha Obstáculos
            obstacles.forEach(obstacle => obstacle.draw(gameCtx));

            // Desenha Jogadores
            players.forEach(player => player.draw(gameCtx));

            // Desenha a Rede Neural do Jogador 0 (se ele existir e tiver cérebro)
            if (players.length > 0 && players[0].brain) {
                // Passa o contexto, a instância do Perceptron do jogador 0
                    // Encontra o jogador com maior pontuação
                    let bestPlayer = players[0];
                    for (let i = 1; i < players.length; i++) {
                        if (players[i].score > bestPlayer.score) {
                            bestPlayer = players[i];
                        }
                    }
                    drawNeuralNetwork(nnCtx, bestPlayer.brain);
            } else {
                // Limpa o canvas da NN se não houver jogador 0
                nnCtx.clearRect(0, 0, nnCanvas.width, nnCanvas.height);
            }

            // NOVO: Atualiza informações de jogadores elite a cada frame
            updateEliteStatusDisplay();
        }

        // Controle de FPS
        let lastFrameTime = 0;
        const targetFPS = 120; // FPS alvo (pode ser ajustado)
        const frameInterval = 1000 / targetFPS; // Intervalo entre frames em ms

        function gameLoop(timestamp) {
            // Calcula o tempo desde o último frame
            const deltaTime = timestamp - lastFrameTime;
            
            // Verifica se é hora de renderizar um novo frame
            if (deltaTime >= frameInterval) {
                // Atualiza o tempo do último frame
                lastFrameTime = timestamp - (deltaTime % frameInterval);
                
                // Atualiza e desenha o jogo
                update();
                draw();
            }
            
            // Agenda o próximo frame
            requestAnimationFrame(gameLoop);
        }

        // --- Inicialização ---
        function init() {
            // const numOutputs = NUM_OUTPUTS; // Already defined globally
            const brainTemplate = new MLP(NUM_INPUTS, HIDDEN_UNITS_1, HIDDEN_UNITS_2, NUM_OUTPUTS);
            const numGenes = brainTemplate.getNumGenes();
            
            evolutionaryStrategy = new EvolutionaryStrategy(
                NUM_PLAYERS, MUTATION_RATE, MUTATION_AMOUNT, numGenes
            );

             // Cria os jogadores iniciais com genes da primeira população aleatória
            players = [];
            for (let i = 0; i < NUM_PLAYERS; i++) {
                 // Pass all required hidden layer sizes to the constructor
                const brain = new MLP(NUM_INPUTS, HIDDEN_UNITS_1, HIDDEN_UNITS_2, NUM_OUTPUTS);
                var genes = evolutionaryStrategy.getIndividualGenes(i);

                // Comment out pre-trained gene loading
                /*
                if (i === 0 && genesP1) {
                    if(genesP1.length === numGenes) {
                        genes = genesP1;
                    } else {
                         console.warn("genesP1 has incorrect length for the new network structure. Using random genes.");
                    }
                }
                */

                brain.setGenes(genes);
                players.push(new Player(PLAYER_COLORS[i % PLAYER_COLORS.length], brain));
            }

            // Comment out specific P1 creation
            /*
            const brainP1 = new MLP(NUM_INPUTS, HIDDEN_UNITS_1, HIDDEN_UNITS_2, NUM_OUTPUTS);
            // brainP1.x -= 12; // Cannot set x on brain
            // brainP1.color = 'black'; // Cannot set color on brain
            if(genesP1 && genesP1.length === numGenes) {
                brainP1.setGenes(genesP1);
                // players[NUM_PLAYERS -1]=new Player("black", brainP1, 55);
            } else {
                 console.warn("Cannot create specific P1 player, genesP1 invalid.");
            }
            */

            activePlayers = NUM_PLAYERS;
            frameCount = 0;
            generation = 1;
            bestScoresHistory = []; // Limpa histórico no início
            worstScoresHistory = []; // <-- ADD THIS LINE: Clear worst history too

            document.getElementById('generation').textContent = generation;
            document.getElementById('bestScore').textContent = '0';


            // Limpa o gráfico inicial
            graphCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);
            drawFitnessGraph(graphCtx, [], []); // <-- MODIFY THIS CALL: Pass empty worst history

             console.log("Jogo inicializado. Iniciando Geração 1.");
            // Inicia o loop do jogo
            gameLoop();
            
            // Configurar os botões
            setupButtons();
            
            // Atualizar visualização do JSON
            updateJsonViewer();
        }

        // Função para converter o cérebro da rede neural para o formato estruturado
        function brainToStructuredFormat(brain) {
            return {
                // Pesos e biases da primeira camada oculta
                hiddenLayer1: {
                    weights: Array.from({ length: NUM_INPUTS }, (_, i) => 
                        Array.from({ length: HIDDEN_UNITS_1 }, (_, j) => brain.weights_in_h1[i][j])
                    ),
                    biases: [...brain.bias_h1]
                },
                // Pesos e biases da segunda camada oculta
                hiddenLayer2: {
                    weights: Array.from({ length: HIDDEN_UNITS_1 }, (_, i) => 
                        Array.from({ length: HIDDEN_UNITS_2 }, (_, j) => brain.weights_h1_h2[i][j])
                    ),
                    biases: [...brain.bias_h2]
                },
                // Pesos e biases da camada de saída
                outputLayer: {
                    weights: Array.from({ length: HIDDEN_UNITS_2 }, (_, i) => 
                        Array.from({ length: NUM_OUTPUTS }, (_, j) => brain.weights_h2_out[i][j])
                    ),
                    biases: [...brain.bias_out]
                }
            };
        }

        // Função para aplicar os pesos estruturados a um cérebro
        function applyStructuredFormatToBrain(brain, data) {
            // Camada oculta 1
            for (let i = 0; i < NUM_INPUTS; i++) {
                for (let j = 0; j < HIDDEN_UNITS_1; j++) {
                    brain.weights_in_h1[i][j] = data.hiddenLayer1.weights[i][j];
                }
            }
            for (let i = 0; i < HIDDEN_UNITS_1; i++) {
                brain.bias_h1[i] = data.hiddenLayer1.biases[i];
            }
            
            // Camada oculta 2
            for (let i = 0; i < HIDDEN_UNITS_1; i++) {
                for (let j = 0; j < HIDDEN_UNITS_2; j++) {
                    brain.weights_h1_h2[i][j] = data.hiddenLayer2.weights[i][j];
                }
            }
            for (let i = 0; i < HIDDEN_UNITS_2; i++) {
                brain.bias_h2[i] = data.hiddenLayer2.biases[i];
            }
            
            // Camada de saída
            for (let i = 0; i < HIDDEN_UNITS_2; i++) {
                for (let j = 0; j < NUM_OUTPUTS; j++) {
                    brain.weights_h2_out[i][j] = data.outputLayer.weights[i][j];
                }
            }
            for (let i = 0; i < NUM_OUTPUTS; i++) {
                brain.bias_out[i] = data.outputLayer.biases[i];
            }
        }

        // Função para salvar e copiar o melhor indivíduo (sem adicionar no jogo)
        function saveBestIndividual() {
            // Encontrar o melhor jogador vivo
            let bestPlayer = null;
            let bestScore = -Infinity;
            
            // Primeiro, procura entre jogadores vivos
            for (const player of players) {
                if (player.isAlive && player.score > bestScore) {
                    bestScore = player.score;
                    bestPlayer = player;
                }
            }
            
            // Se não tiver jogadores vivos, procurar entre todos
            if (!bestPlayer) {
                for (const player of players) {
                    if (player.score > bestScore) {
                        bestScore = player.score;
                        bestPlayer = player;
                    }
                }
            }
            
            if (!bestPlayer) {
                alert('Nenhum jogador encontrado para salvar!');
                return;
            }
            
            // Converter o cérebro para o formato estruturado
            const neuralNetworkData = brainToStructuredFormat(bestPlayer.brain);
            
            // Salvar no localStorage com metadados
            const saveData = {
                neuralNetworkData: neuralNetworkData,
                fitness: bestPlayer.score,
                generation: generation,
                timestamp: new Date().toISOString()
            };
            
            localStorage.setItem('bestIndividual', JSON.stringify(saveData));
            
            // Atualizar variáveis globais
            bestEverFitness = bestPlayer.score;
            bestEverNeuralNetwork = neuralNetworkData;
            bestEverGeneration = generation;
            
            // Exibir mensagem de confirmação e copiar para a área de transferência
            const dataString = JSON.stringify(neuralNetworkData, null, 2);
            navigator.clipboard.writeText(dataString)
                .then(() => {
                    alert(`Melhor indivíduo salvo e copiado para a área de transferência!\nPontuação: ${bestPlayer.score.toFixed(2)}`);
                })
                .catch(() => {
                    alert(`Melhor indivíduo salvo com sucesso!\nPontuação: ${bestPlayer.score.toFixed(2)}\nVeja o console para detalhes.`);
                    console.log('Dados do melhor indivíduo:', dataString);
                });
            
            // Atualizar visualização do JSON
            updateJsonViewer();
        }

        // Nova função para carregar e adicionar um jogador a partir do localStorage
        function loadAndAddSavedIndividual() {
            const savedData = localStorage.getItem('bestIndividual');
            if (!savedData) {
                alert('Nenhum indivíduo salvo encontrado no localStorage!');
                return;
            }
            
            try {
                const data = JSON.parse(savedData);
                
                // Criar um novo cérebro e aplicar os pesos do indivíduo salvo
                const newBrain = new MLP(NUM_INPUTS, HIDDEN_UNITS_1, HIDDEN_UNITS_2, NUM_OUTPUTS);
                applyStructuredFormatToBrain(newBrain, data.neuralNetworkData);
                
                // Criar o novo jogador com cor dourada para destacar
                const newPlayer = new Player('darkgoldenrod', newBrain);
                newPlayer.x -= 12;
                
                // Adicionar ao array de jogadores
                players.push(newPlayer);
                activePlayers++; // Incrementar o contador de jogadores ativos
                
                alert(`Indivíduo adicionado com sucesso!\nGeração original: ${data.generation}\nPontuação original: ${data.fitness.toFixed(2)}`);
                
                // Atualizar visualização do JSON
                updateJsonViewer();
                
            } catch (e) {
                console.error("Erro ao adicionar indivíduo do localStorage:", e);
                alert('Erro ao adicionar indivíduo. Verifique o console para detalhes.');
            }
        }

        // Função para carregar o melhor indivíduo do localStorage (apenas para referência, não adiciona ao jogo)
        function loadBestIndividual() {
            const savedData = localStorage.getItem('bestIndividual');
            if (savedData) {
                try {
                    const data = JSON.parse(savedData);
                    bestEverFitness = data.fitness;
                    bestEverNeuralNetwork = data.neuralNetworkData;
                    bestEverGeneration = data.generation;
                    
                    console.log(`Melhor indivíduo carregado na memória! Fitness: ${bestEverFitness.toFixed(2)}, Geração: ${bestEverGeneration}`);
                    
                    // Atualizar visualização do JSON
                    updateJsonViewer();
                    
                    return data.neuralNetworkData;
                } catch (e) {
                    console.error("Erro ao carregar o melhor indivíduo:", e);
                    return null;
                }
            }
            return null;
        }

        // Atualize a função setupSaveButton para configurar ambos os botões
        function setupButtons() {
            // Configurar botão de salvar/copiar
            const saveButton = document.getElementById('saveBestBtn');
            if (saveButton) {
                saveButton.addEventListener('click', saveBestIndividual);
            } else {
                console.error('Botão de salvar não encontrado!');
            }
            
            // Configurar botão de carregar/adicionar
            const loadButton = document.getElementById('loadBestBtn');
            if (loadButton) {
                loadButton.addEventListener('click', loadAndAddSavedIndividual);
            } else {
                console.error('Botão de carregar não encontrado!');
            }
            
            // Carregar o melhor indivíduo para referência (não adiciona ao jogo)
            loadBestIndividual();
            
            // Atualizar visualização do JSON
            updateJsonViewer();
        }

        // Função para atualizar a visualização do JSON salvo
        function updateJsonViewer() {
            const savedJsonInfo = document.getElementById('savedJsonInfo');
            const savedJsonContent = document.getElementById('savedJsonContent');
            
            if (!savedJsonInfo || !savedJsonContent) return;
            
            const savedData = localStorage.getItem('bestIndividual');
            
            if (!savedData) {
                savedJsonInfo.textContent = "Nenhum indivíduo salvo encontrado.";
                savedJsonContent.textContent = "";
                return;
            }
            
            try {
                const data = JSON.parse(savedData);
                
                // Mostrar informações resumidas
                savedJsonInfo.innerHTML = `
                    <strong>Geração:</strong> ${data.generation} | 
                    <strong>Fitness:</strong> ${data.fitness.toFixed(2)} | 
                    <strong>Data:</strong> ${new Date(data.timestamp).toLocaleString()}
                `;
                
                // Exibir em formato JSON com indentação e cores
                const jsonString = JSON.stringify(data, null, 2);
                savedJsonContent.innerHTML = formatJsonWithColors(jsonString);
                
            } catch (e) {
                savedJsonInfo.textContent = "Erro ao carregar os dados salvos.";
                savedJsonContent.textContent = "Erro: " + e.message;
                console.error("Erro ao atualizar visualização do JSON:", e);
            }
        }

        // Função para formatar JSON com cores (opcional)
        function formatJsonWithColors(json) {
            if (!json) return '';
            
            // Substitui valores por cores
            return json
                .replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
                    let cls = 'number';
                    if (/^"/.test(match)) {
                        if (/:$/.test(match)) {
                            cls = 'key';
                        } else {
                            cls = 'string';
                        }
                    } else if (/true|false/.test(match)) {
                        cls = 'boolean';
                    } else if (/null/.test(match)) {
                        cls = 'null';
                    }
                    
                    // Retorna valores com span colorido
                    return '<span class="' + cls + '">' + match + '</span>';
                });
        }

        // Inicia o jogo quando a página carregar
        window.onload = init;

    </script>
</body>
</html>