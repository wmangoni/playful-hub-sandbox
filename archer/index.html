<!DOCTYPE html>
<html lang="pt-br">
<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KM6SHZXP');</script>
    <!-- End Google Tag Manager -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéØ The Archer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            /* Phase 1: Improved Background Gradient */
            background: linear-gradient(to bottom, #87CEEB 0%, #a1dff7 60%, #bdebff 100%);
            overflow: hidden;
            /* Use a cleaner sans-serif for general text */
            font-family: 'Lato', Arial, sans-serif;
        }

        /* Thematic font for specific elements */
        #score-container, #arrows-left, #game-over h2, button {
            font-family: 'Cinzel Decorative', cursive;
        }

        /* 12. UI Container Styling */
        #score-container, #arrows-left, #instructions {
            position: absolute;
            /* Parchment background using gradient */
            background: linear-gradient(to bottom, rgba(245, 222, 179, 0.85) 0%, rgba(238, 210, 165, 0.85) 100%); /* Wheat/Beige tones */
            padding: 10px 15px; /* Slightly more padding */
            border-radius: 3px; /* Sharper corners */
            border: 1px solid #b8860b; /* Dark Goldenrod border */
            box-shadow: inset 0 0 5px rgba(0,0,0,0.1), 2px 2px 4px rgba(0,0,0,0.2); /* Inner and outer shadow */
            color: #502d0e; /* Dark brown text */
            font-size: 14px;
            font-weight: bold;
        }

        #score-container { top: 10px; left: 10px; }
        #arrows-left { top: 55px; /* Adjust if needed based on score container height */ left: 10px; }
        #instructions {
            top: 10px; right: 10px;
            max-width: 190px; /* Adjust width */
            text-align: left;
            font-family: 'Lato', Arial, sans-serif; /* Use cleaner font for instructions */
            font-size: 13px;
            font-weight: normal; /* Normal weight for instructions */
            line-height: 1.4;
        }
        #instructions p { margin: 4px 0; } /* Adjust spacing */


        #game-container {
            position: relative;
            width: 800px;
            height: 500px;
            background-color: transparent; /* Let body gradient show through */
            border: 3px solid #654321; /* Darker wood-like border */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3); /* Add depth */
            overflow: hidden;
        }

        /* --- Phase 1: Clouds (Add cloud divs in HTML) --- */
        .cloud {
            position: absolute;
            background-color: #ffffff;
            opacity: 0.85;
            border-radius: 50% 60% 40% 70% / 60% 50% 70% 40%; /* Irregular shape */
            filter: blur(1px); /* Slightly soft edges */
            animation: slideCloud 40s linear infinite; /* Cloud movement */
        }
        /* Unique properties for different clouds */
        #cloud1 { width: 120px; height: 50px; top: 50px; left: 10%; animation-duration: 50s; }
        #cloud2 { width: 90px; height: 40px; top: 100px; left: 70%; animation-duration: 65s; opacity: 0.7; }
        #cloud3 { width: 150px; height: 60px; top: 80px; left: 40%; animation-duration: 55s; }

        /* Composite cloud shapes using pseudo-elements */
        .cloud::before, .cloud::after {
            content: '';
            position: absolute;
            background-color: inherit; /* Same color as parent */
            border-radius: 50%;
            opacity: inherit;
            filter: inherit;
        }
        .cloud::before { /* Smaller blob on one side */
            width: 60%; height: 70%; top: -25%; left: 10%;
        }
        .cloud::after { /* Another smaller blob */
            width: 50%; height: 60%; top: 10%; right: 5%;
        }

        @keyframes slideCloud {
            from { transform: translateX(-10%); }
            to { transform: translateX(10%); } /* Adjust based on desired drift */
            /* Use different to/from for different clouds if needed */
             /* Example: 0% {transform: translateX(-200px);} 100% {transform: translateX(900px);} */
        }
        /* --- End Clouds --- */


        #archer {
            position: absolute;
            bottom: 50px;
            left: 100px;
            width: 50px;
            height: 80px;
            background: none;
        }

        /* SVG specific styles if needed */
        #archer svg {
            width: 100%;
            height: 100%;
            display: block; /* Prevent extra space below SVG */
        }

        #bow {
            position: absolute;
            /* Phase 1: Adjust position/size for curved bow SVG */
            bottom: 60px; /* Raise slightly to align better with archer SVG */
            left: 140px; /* Adjust horizontal position */
            width: 20px; /* Narrower div, SVG will provide visual width */
            height: 90px; /* Taller to contain the SVG curve */
            background: none; /* SVG provides visuals */
            transform-origin: center 75%; /* Rotate near the handle */
        }
        /* SVG specific styles */
         #bow svg {
             width: 100%; /* Control overall SVG container size */
             height: 100%;
             display: block;
             overflow: visible; /* Allow stroke to potentially exceed viewbox slightly if needed */
         }

        #arrow {
            position: absolute;
            bottom: 90px; /* Align with bow handle */
            left: 145px; /* Align with bow handle */
            width: 35px; /* Slightly longer */
            height: 2px;
            background-color: #444; /* Darker shaft */
            display: none;
            transform-origin: 5px center; /* Pivot slightly ahead of base */
            z-index: 1; /* Arrow above bow potentially */
        }

        /* Phase 1: Arrow Feathers (Fletching) */
        #arrow::before, #arrow::after {
            content: '';
            position: absolute;
            width: 10px;
            height: 5px;
            background-color: #A0522D; /* Feather color (Sienna) */
            right: -2px; /* Position at the back */
            transform-origin: right center;
        }
        #arrow::before {
            top: -4px;
            transform: rotate(-35deg) skewX(-20deg);
        }
        #arrow::after {
            bottom: -4px;
            transform: rotate(35deg) skewX(20deg);
        }

        #arrowhead {
            position: absolute;
            left: 35px; /* Match new arrow width */
            top: -4px;
            width: 0;
            height: 0;
            border-left: 8px solid #333; /* Darker head */
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
        }

        #balloon {
            position: absolute;
            width: 40px;
            height: 50px;
            /* Phase 1: Gradient for 3D effect */
            background: radial-gradient(circle at 30% 30%, #ff8888, #ff0000 60%, #cc0000 95%);
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            bottom: 250px;
            right: 100px;
            box-shadow: inset -3px -3px 5px rgba(0,0,0,0.2); /* Inner shadow */
        }
        /* Phase 1: Balloon Knot */
        #balloon::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            background: #aa0000; /* Darker red */
            border-radius: 50%;
            bottom: -3px; /* Position at the bottom */
            left: 50%;
            transform: translateX(-50%);
        }

        #balloon-string {
            position: absolute;
            width: 1px; /* Thinner */
            height: 30px;
            background-color: #555; /* Dark Grey */
            bottom: 220px;
            right: 119px; /* Adjusted slightly */
            z-index: -1; /* Behind balloon knot */
        }

        #ground {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 50px;
            /* Phase 1: Gradient for ground */
            background: linear-gradient(to bottom, #6B8E23 0%, #556B2F 80%); /* Olive green gradient */
            border-top: 2px solid #4A442A; /* Darker top edge */
        }

        /* Game Over Screen Styling */
        #game-over {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            /* Similar parchment style */
            background: linear-gradient(to bottom, rgba(245, 222, 179, 0.95) 0%, rgba(238, 210, 165, 0.95) 100%);
            padding: 30px 40px;
            border-radius: 5px;
            border: 2px solid #8B4513; /* Saddle Brown */
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            text-align: center;
            display: none; /* Controlled by JS */
            color: #654321; /* Darker brown text */
        }
        #game-over h2 {
            font-size: 2em;
            color: #8B0000; /* Dark Red */
            margin-bottom: 15px;
            font-weight: 700; /* Bolder */
        }
        #game-over p {
            font-size: 1.1em;
            margin-bottom: 20px;
            font-family: 'Lato', sans-serif;
        }
        #final-score {
            font-weight: bold;
            font-size: 1.2em;
            color: #006400; /* Dark Green */
        }
        
        /* Button Styling */
        button {
            padding: 10px 25px;
            background: linear-gradient(to bottom, #8B4513, #A0522D); /* Brown gradient */
            color: #fff8dc; /* Cornsilk white */
            border: 1px solid #654321;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            font-size: 1.1em;
            font-weight: bold;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.4);
            transition: transform 0.1s ease, box-shadow 0.1s ease;
            box-shadow: 0 2px 3px rgba(0,0,0,0.3);
        }
        button:hover {
            background: linear-gradient(to bottom, #A0522D, #8B4513); /* Invert gradient */
            box-shadow: 0 3px 5px rgba(0,0,0,0.4);
        }
         button:active {
             transform: translateY(1px);
             box-shadow: 0 1px 2px rgba(0,0,0,0.3);
         }
        
        /* 13. Power Indicator Rework (Vertical) */
        #power-indicator {
            position: absolute;
            /* Position vertically next to archer */
            bottom: 60px;
            left: 70px; /* Adjust to be left of the archer */
            width: 12px; /* Narrow width */
            height: 100px; /* Taller height */
            background-color: rgba(50, 50, 50, 0.6); /* Dark semi-transparent background */
            border: 1px solid #000;
            border-radius: 3px;
            display: none; /* Controlled by JS */
            overflow: hidden; /* Keep gradient contained */
             /* Optional: Add pulse while charging */
            animation: pulseIndicator 1s infinite alternate;
        }

        /* Pulse Animation (Optional) */
        @keyframes pulseIndicator {
            from { box-shadow: 0 0 3px #fff; }
            to   { box-shadow: 0 0 8px #ff0; }
        }
        
        #power-bar {
            width: 100%; /* Fill width */
            height: 0%; /* Start at 0% height */
            /* Gradient Fill */
            background: linear-gradient(to top, #ff0000, #ffcc00, #00ff00); /* Red -> Yellow -> Green */
            position: absolute; /* Position within indicator */
            bottom: 0; /* Align to bottom */
            left: 0;
            transition: height 0.05s linear; /* Smooth height transition */
        }
        
        #debug-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 5px;
            border-radius: 5px;
            font-size: 12px;
            display: none;
        }

        /* 7. Balloon Animation */
        #balloon, #balloon-string {
            /* Add animation */
            animation: bobbingBalloon 3s ease-in-out infinite alternate;
        }
        #balloon {
            /* Slight delay difference for variation */
            animation-delay: -0.5s;
        }

        @keyframes bobbingBalloon {
            from { transform: translateY(0px) rotate(-1deg); }
            to   { transform: translateY(-5px) rotate(1deg); }
        }

        /* 8. Bow String Visual */
        #bow-string-visual {
            position: absolute;
            width: 1px; /* String thickness */
            height: 90%; /* Span most of the bow height */
            background-color: #ccc; /* Light grey string */
            top: 5%; /* Align vertically */
            left: 50%; /* Center horizontally initially */
            transform: translateX(-50%); /* Accurate centering */
            border-radius: 1px;
            z-index: 0; /* Behind arrow */
            /* Smooth transitions when released */
            transition: transform 0.1s ease-out;
        }

        /* 9. Arrow Launch Effect */
        .launch-spark {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: yellow;
            border-radius: 50%;
            opacity: 0.8;
            transform: scale(1);
            pointer-events: none; /* Ignore mouse events */
            z-index: 2; /* Above bow/arrow */
            animation: launchEffect 0.2s ease-out forwards;
        }

        @keyframes launchEffect {
            0% { opacity: 0.8; transform: scale(1); }
            100% { opacity: 0; transform: scale(2.5); }
        }

        /* 10. Arrow Trail */
        .arrow-trail-dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background-color: rgba(255, 255, 200, 0.7); /* Light yellow */
            border-radius: 50%;
            pointer-events: none;
            z-index: 0; /* Behind arrow maybe? */
            opacity: 1;
            animation: fadeOutTrail 0.5s linear forwards;
        }

        @keyframes fadeOutTrail {
            from { opacity: 0.7; transform: scale(1); }
            to   { opacity: 0; transform: scale(0.3); }
        }

        /* 11. Balloon Pop Effect */
        .balloon-fragment {
            position: absolute;
            width: 8px;
            height: 8px;
            background: radial-gradient(circle, #ff8888, #ff0000 70%); /* Match balloon color */
            border-radius: 2px; /* Small squares or circles */
            /* border-radius: 50%; */
            pointer-events: none;
            opacity: 1;
            /* Define animation with custom properties for direction */
            animation: popFragment 0.6s ease-out forwards;
        }

        @keyframes popFragment {
            0% {
                opacity: 1;
                transform: translate(0, 0) scale(1) rotate(0deg);
            }
            100% {
                opacity: 0;
                /* Use CSS variables for dynamic direction */
                transform: translate(var(--tx, 0), var(--ty, 0)) scale(0) rotate(var(--rot, 0deg));
            }
        }

        /* --- End Phase 2 --- */

        /* Existing styles below... ensure elements like arrow position/origin are correct */
        #arrow {
             /* ... existing styles ... */
             bottom: 90px;
             left: 145px;
             transform-origin: 5px center; /* Make sure this is reasonable */
             z-index: 1;
         }
         #bow {
             /* ... existing styles ... */
             transform-origin: center 75%; /* Pivot near the handle */
             z-index: 0; /* Behind Arrow */
         }
    </style>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KM6SHZXP"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    
    <div id="game-container">
        <div id="score-container">üéØ Pontos: <span id="score">0</span></div>
        <div id="arrows-left">‚ûµ Flechas: <span id="arrows-counter">5</span></div>
        <div id="instructions">
            <p>Clique e arraste para atirar</p>
            <p>Solte para lan√ßar a flecha</p>
            <p>Acerte o bal√£o vermelho!</p>
        </div>
        <!-- Phase 1: Add Cloud Elements -->
        <div class="cloud" id="cloud1"></div>
        <div class="cloud" id="cloud2"></div>
        <div class="cloud" id="cloud3"></div>
        <!-- End Clouds -->

        <div id="ground"></div>
        <div id="archer">
            <!-- Phase 1: Simple Archer SVG -->
            <svg viewBox="0 0 50 80" xmlns="http://www.w3.org/2000/svg">
                <!-- Head -->
                <circle cx="25" cy="15" r="10" fill="#E0AC69"/>
                <!-- Body -->
                <rect x="15" y="25" width="20" height="40" fill="#8B4513" rx="3"/>
                <!-- Simple legs -->
                <rect x="17" y="65" width="6" height="15" fill="#654321" />
                <rect x="27" y="65" width="6" height="15" fill="#654321" />
            </svg>
        </div>
        
        <div id="bow">
            <!-- Phase 1: Simple Curved Bow SVG -->
            <svg viewBox="-5 -5 30 100" xmlns="http://www.w3.org/2000/svg">
                <path d="M 10 0 Q 30 45 10 90"
                      stroke="#8B4513"
                      stroke-width="5"
                      stroke-linecap="round"
                      fill="none" />
            </svg>
            <div id="bow-string-visual"></div>
        </div>

        <div id="arrow">
            <div id="arrowhead"></div>
        </div>
        <div id="power-indicator">
            <div id="power-bar"></div>
        </div>
        <div id="balloon"></div>
        <div id="balloon-string"></div>
        <div id="game-over">
            <h2>Fim de Jogo!</h2>
            <p>Sua pontua√ß√£o final: <span id="final-score">0</span></p>
            <button id="restart-button">Jogar Novamente</button>
        </div>
        <div id="debug-info"></div>
    </div>

    <script>
        // Elementos do jogo
        const gameContainer = document.getElementById('game-container');
        const bow = document.getElementById('bow');
        const arrow = document.getElementById('arrow');
        const balloon = document.getElementById('balloon');
        const balloonString = document.getElementById('balloon-string');
        const scoreElement = document.getElementById('score');
        const arrowsCounter = document.getElementById('arrows-counter');
        const finalScoreElement = document.getElementById('final-score');
        const gameOverElement = document.getElementById('game-over');
        const restartButton = document.getElementById('restart-button');
        const powerIndicator = document.getElementById('power-indicator');
        const powerBar = document.getElementById('power-bar');
        const debugInfo = document.getElementById('debug-info');
        
        // Vari√°veis do jogo
        let score = 0;
        let arrowsLeft = 5;
        let arrowFired = false;
        let arrowAngle = 0;
        let arrowSpeed = 0;
        let arrowVelocityX = 0;
        let arrowVelocityY = 0;
        let arrowX = 50;
        let arrowY = 0;
        let gravity = 0.25;
        let isDragging = false;
        let startX, startY;
        let gameOver = false;
        let powerFactor = 0.2;
        let debugMode = true;  // Ativar/desativar informa√ß√µes de debug

        const bowStringVisual = document.getElementById('bow-string-visual');
        // Track frame count for trail timing
        let frameCount = 0;


        function handleAimMove(clientX, clientY) {
            const dx = startX - clientX;
            const dy = clientY - startY; // Keep inverted dy

            const maxPull = 150;
            const distance = Math.min(Math.sqrt(dx * dx + dy * dy), maxPull);
            arrowAngle = Math.atan2(dy, dx);

            // Visual Rotation
            bow.style.transform = `rotate(${arrowAngle}rad)`;
            arrow.style.transform = `rotate(${arrowAngle}rad)`;

            // Bow string pull animation etc...
            const stringPullDistance = -distance * 0.4;
            bowStringVisual.style.transform = `translateX(calc(-50% + ${stringPullDistance}px))`;
            const arrowPullOffset = stringPullDistance + 5;
            arrow.style.left = (145 + arrowPullOffset) + 'px';
            arrowSpeed = distance * powerFactor;

            // --- Update Vertical Power Bar ---
            const powerPercentage = (distance / maxPull) * 100;
            powerBar.style.height = powerPercentage + '%'; // <<< Set height instead

            // Remove old color changing logic, gradient handles it
            /*
            if (powerPercentage < 33) powerBar.style.backgroundColor = 'green';
            else if (powerPercentage < 66) powerBar.style.backgroundColor = 'yellow';
            else powerBar.style.backgroundColor = 'red';
            */

            // Optional: Add/Remove pulse animation class while dragging
            // if (!powerIndicator.classList.contains('charging')) {
            //     powerIndicator.classList.add('charging'); // You'd need a .charging class with the animation
            // }
        }

        gameContainer.addEventListener('mousemove', function(e) {
            if (!isDragging || gameOver) return;
            handleAimMove(e.clientX, e.clientY);
        });
        gameContainer.addEventListener('touchmove', function(e) {
            if (!isDragging || gameOver) return;
            e.preventDefault();
            const touch = e.touches[0];
            handleAimMove(touch.clientX, touch.clientY);
        });

        // --- Modify mouseup/touchend event listener ---
        function handleFire() {
            if (!isDragging || gameOver) return;
            isDragging = false;
            bowStringVisual.style.transform = `translateX(-50%)`;

            const initialVx = Math.cos(arrowAngle) * arrowSpeed;
            const initialVy = Math.sin(arrowAngle) * arrowSpeed;

            arrowVelocityX = initialVx;
            arrowVelocityY = -initialVy;

            // Double-check logging
            console.log(`
                Angle: ${arrowAngle.toFixed(2)}
                rad (${(arrowAngle * 180/Math.PI).toFixed(1)}deg)
                Speed: ${arrowSpeed.toFixed(2)}
                Vx: ${arrowVelocityX.toFixed(2)}
                Vy: ${arrowVelocityY.toFixed(2)}`);


            createLaunchSpark();

            arrowFired = true;
            frameCount = 0;
            updateArrow();
            setTimeout(() => {
                powerIndicator.style.display = 'none';
                powerBar.style.height = '0%'; // Reset height
                // powerIndicator.classList.remove('charging'); // Remove pulse class
            }, 100);
        }


        gameContainer.addEventListener('mouseup', handleFire);
        gameContainer.addEventListener('touchend', function(e) {
            e.preventDefault(); // Prevent potential click event after touch
            handleFire();
        });

        // --- Modify mouseleave/touchcancel event listener ---
        function handleAimCancel() {
            if (isDragging && !arrowFired && !gameOver) {
                isDragging = false;
                // Reset bow string visual
                bowStringVisual.style.transform = `translateX(-50%)`;

                arrow.style.left = '145px';
                arrow.style.transform = 'rotate(0rad)';
                bow.style.transform = 'rotate(0rad)';
                arrow.style.display = 'none';
                powerIndicator.style.display = 'none';
                powerBar.style.height = '0%'; // Reset height
                arrowSpeed = 0;
            }
        }
        gameContainer.addEventListener('mouseleave', handleAimCancel);
        // Optional: Add touchcancel for robustness
        // gameContainer.addEventListener('touchcancel', handleAimCancel);


        // Phase 2: Function to create launch spark
        function createLaunchSpark() {
            const spark = document.createElement('div');
            spark.className = 'launch-spark';
            // Position near bow handle/arrow start
            const bowRect = bow.getBoundingClientRect();
            const containerRect = gameContainer.getBoundingClientRect();
            spark.style.left = (bowRect.left - containerRect.left + bowRect.width * 0.5) + 'px'; // Centered horizontally on bow approx
            spark.style.bottom = (containerRect.bottom - bowRect.top - bowRect.height * 0.25) + 'px'; // Near upper part of handle approx
            gameContainer.appendChild(spark);

            // Remove spark after animation
            setTimeout(() => {
                if (spark.parentNode === gameContainer) { // Check if it hasn't been removed already
                    gameContainer.removeChild(spark);
                }
            }, 200); // Match animation duration
        }


        // --- Modify updateArrow function ---
        function updateArrow() {
            if (!arrowFired) return;
            frameCount++; // Increment frame count

            // Apply gravity...
            arrowVelocityY -= gravity;

            // Update position...
            arrowX += arrowVelocityX;
            arrowY += arrowVelocityY;
            const currentBottom = 90 + arrowY;
            const currentLeft = 145 + arrowX; // Base position + delta X (since origin changed)

            arrow.style.bottom = currentBottom + 'px';
            arrow.style.left = currentLeft + 'px';

            // Calculate angle...
            const currentAngle = Math.atan2(arrowVelocityY, arrowVelocityX);
            arrow.style.transform = `rotate(${currentAngle}rad)`;

            // Phase 2: Create Trail Dot periodically
             if (frameCount % 3 === 0) { // Adjust frequency (lower number = more dots)
                 createTrailDot(currentLeft + 15, currentBottom + 1); // Position near arrow center/tip
             }


            // Check collision...
            const hitBalloon = checkCollision();

            // Check bounds...
            const arrowRect = arrow.getBoundingClientRect();
            const containerRect = gameContainer.getBoundingClientRect();
            const outOfBounds =
                arrowRect.right < containerRect.left - 50 || // Give some leeway
                arrowRect.left > containerRect.right + 50 ||
                arrowRect.bottom < containerRect.top - 50 ||
                arrowRect.top > containerRect.bottom + 50; // Check if way out, not just touching edge

            if (outOfBounds) {
                resetArrow();
                arrowsLeft--;
                arrowsCounter.textContent = arrowsLeft;
                if (arrowsLeft <= 0 && !gameOver) endGame(); // Check !gameOver prevents multiple calls
            } else if (hitBalloon) {
                // Let checkCollision handle balloon pop effects
                resetArrow();
            } else {
                requestAnimationFrame(updateArrow);
            }
        }

        // Phase 2: Function to create a trail dot
        function createTrailDot(x, y) {
             const dot = document.createElement('div');
             dot.className = 'arrow-trail-dot';
             dot.style.left = x + 'px';
             dot.style.bottom = y + 'px';
             gameContainer.appendChild(dot);

             // Remove dot after animation (match CSS duration)
             setTimeout(() => {
                if (dot.parentNode === gameContainer) {
                     gameContainer.removeChild(dot);
                }
             }, 500);
         }


        // --- Modify checkCollision function ---
        function checkCollision() {
            const arrowRect = arrow.getBoundingClientRect();
            const balloonRect = balloon.getBoundingClientRect();

            // Optimization: Check if balloon is even visible before checking bounds
             if (balloon.style.display === 'none') return false;


            if (
                arrowRect.left < balloonRect.right &&
                arrowRect.right > balloonRect.left &&
                arrowRect.top < balloonRect.bottom &&
                arrowRect.bottom > balloonRect.top
            ) {
                score += 100;
                scoreElement.textContent = score;

                // Phase 2: Trigger Balloon Pop Effect
                createBalloonPopEffect(balloonRect);

                // Hide original balloon immediately
                balloon.style.display = 'none';
                balloonString.style.display = 'none';

                // Respawn after a delay
                setTimeout(positionBalloon, 1500); // Slightly longer delay after pop

                return true;
            }
            return false;
        }

        // Phase 2: Function to create balloon pop effect
        function createBalloonPopEffect(balloonRect) {
            const containerRect = gameContainer.getBoundingClientRect();
            const popX = balloonRect.left - containerRect.left + balloonRect.width / 2;
            const popY = balloonRect.top - containerRect.top + balloonRect.height / 2;

            const fragmentCount = 8; // Number of fragments
            for (let i = 0; i < fragmentCount; i++) {
                const fragment = document.createElement('div');
                fragment.className = 'balloon-fragment';
                fragment.style.left = popX + 'px';
                fragment.style.top = popY + 'px'; // Use top instead of bottom for easier translate calc

                // Calculate random direction and distance for animation
                const angle = Math.random() * Math.PI * 2;
                const distance = 40 + Math.random() * 40; // Fly out 40-80px
                const rotation = Math.random() * 360; // Random end rotation

                // Set CSS custom properties for the animation
                fragment.style.setProperty('--tx', `${Math.cos(angle) * distance}px`);
                fragment.style.setProperty('--ty', `${Math.sin(angle) * distance}px`);
                fragment.style.setProperty('--rot', `${rotation}deg`);

                gameContainer.appendChild(fragment);

                // Remove fragment after animation (match CSS duration)
                setTimeout(() => {
                    if (fragment.parentNode === gameContainer) {
                         gameContainer.removeChild(fragment);
                    }
                 }, 600);
            }
            // Optional: Play pop sound here if you add audio later
        }

        // --- Modify resetArrow function ---
        function resetArrow() {
            arrowFired = false;
            arrowX = 0; // Reset relative X
            arrowY = 0;
            arrowVelocityX = 0;
            arrowVelocityY = 0;
            arrow.style.display = 'none';
            arrow.style.left = '145px'; // Reset initial position
            arrow.style.bottom = '90px';
            arrow.style.transform = 'rotate(0rad)'; // Reset rotation
            // powerIndicator.style.display = 'none'; // Hide power indicator (already hidden after fire timeout)
            bowStringVisual.style.transform = 'translateX(-50%)'; // Ensure string is reset visually
            // bowStringVisual.style.height = '90%';
            // Optional: Clear any remaining trail dots? Might not be necessary with timeouts.

            if (powerIndicator.style.display !== 'none') {
                powerIndicator.style.display = 'none';
                powerBar.style.height = '0%';
                // powerIndicator.classList.remove('charging');
            }
         }

        // Make sure initGame calls resetArrow initially or sets default styles
        function initGame() {
            score = 0;
            arrowsLeft = 5;
            gameOver = false;
            scoreElement.textContent = score;
            arrowsCounter.textContent = arrowsLeft;
            gameOverElement.style.display = 'none';
            resetArrow(); // This now resets the power bar height too
            powerIndicator.style.display = 'none'; // Explicitly hide at start
            powerBar.style.height = '0%';
            positionBalloon();
        }
        
        // Posiciona o bal√£o aleatoriamente
        function positionBalloon() {
            const minRight = 100;
            const maxRight = 400;  // Aumentado para usar mais √°rea
            const minBottom = 150;
            const maxBottom = 400;  // Aumentado para usar mais √°rea
            
            const rightPos = Math.floor(Math.random() * (maxRight - minRight + 1)) + minRight;
            const bottomPos = Math.floor(Math.random() * (maxBottom - minBottom + 1)) + minBottom;
            
            balloon.style.right = rightPos + 'px';
            balloon.style.bottom = bottomPos + 'px';
            balloonString.style.right = (rightPos + 19) + 'px';
            balloonString.style.bottom = (bottomPos - 30) + 'px';
            
            balloon.style.display = 'block';
            balloonString.style.display = 'block';
        }
        
        
        // Reinicia o jogo
        function restartGame() {
            initGame();
        }
        
        // Verifica colis√£o entre a flecha e o bal√£o
        function checkCollision() {
            const arrowRect = arrow.getBoundingClientRect();
            const balloonRect = balloon.getBoundingClientRect();
            
            if (
                arrowRect.left < balloonRect.right &&
                arrowRect.right > balloonRect.left &&
                arrowRect.top < balloonRect.bottom &&
                arrowRect.bottom > balloonRect.top
            ) {
                // Colis√£o detectada
                score += 100;
                scoreElement.textContent = score;
                
                // Esconde o bal√£o e reposiciona
                balloon.style.display = 'none';
                balloonString.style.display = 'none';
                
                setTimeout(positionBalloon, 1000);
                
                return true;
            }
            
            return false;
        }
        
        // Atualiza a posi√ß√£o da flecha
        function updateArrow() {
            if (!arrowFired) return;
            
            // Aplica a gravidade √† velocidade vertical
            arrowVelocityY -= gravity;
            
            // Atualiza a posi√ß√£o da flecha
            arrowX += arrowVelocityX;
            arrowY += arrowVelocityY;
            
            arrow.style.bottom = (90 + arrowY) + 'px';
            arrow.style.left = (100 + arrowX) + 'px';
            
            // Calcula o √¢ngulo com base na trajet√≥ria atual
            const currentAngle = Math.atan2(arrowVelocityY, arrowVelocityX);
            arrow.style.transform = `rotate(${currentAngle * -1}rad)`;
            
            // Exibe informa√ß√µes de debug se estiver ativado
            if (debugMode) {
                debugInfo.textContent = `√Çngulo: ${(currentAngle * 180 / Math.PI).toFixed(2)}¬∞, 
                                         VelX: ${arrowVelocityX.toFixed(2)}, 
                                         VelY: ${arrowVelocityY.toFixed(2)}`;
            }
            
            // Verifica colis√£o
            const hitBalloon = checkCollision();
            
            // Verifica se a flecha saiu da tela
            const arrowRect = arrow.getBoundingClientRect();
            const containerRect = gameContainer.getBoundingClientRect();
            
            if (
                arrowRect.left > containerRect.right ||
                arrowRect.bottom < containerRect.top ||
                arrowRect.top > containerRect.bottom
            ) {
                resetArrow();
                arrowsLeft--;
                arrowsCounter.textContent = arrowsLeft;
                
                // Verifica se o jogo acabou
                if (arrowsLeft <= 0) {
                    endGame();
                }
            } else if (hitBalloon) {
                resetArrow();
            } else {
                // Continua atualizando a posi√ß√£o
                requestAnimationFrame(updateArrow);
            }
        }
        
        // Reseta a flecha para atirar novamente
        function resetArrow() {
            arrowFired = false;
            arrowX = 50;
            arrowY = 0;
            arrowVelocityX = 0;
            arrowVelocityY = 0;
            arrow.style.display = 'none';
            arrow.style.left = '150px';
            arrow.style.bottom = '90px';
            arrow.style.transform = 'rotate(0deg)';
            powerIndicator.style.display = 'none';
        }
        
        // Finaliza o jogo
        function endGame() {
            gameOver = true;
            finalScoreElement.textContent = score;
            gameOverElement.style.display = 'block';
        }
        
        // Eventos de mouse/touch
        gameContainer.addEventListener('mousedown', function(e) {
            if (gameOver || arrowFired) return;
            
            isDragging = true;
            startX = e.clientX;
            startY = e.clientY;
            
            // Mostra a flecha e o indicador de pot√™ncia
            arrow.style.display = 'block';
            powerIndicator.style.display = 'block';
        });
        
        gameContainer.addEventListener('mousemove', function(e) {
            if (!isDragging || gameOver) return;
            
            const dx = startX - e.clientX;
            const dy = startY - e.clientY;
            
            // Limita o quanto pode puxar o arco
            const maxPull = 150;
            const distance = Math.min(Math.sqrt(dx * dx + dy * dy), maxPull);
            
            // Calcula o √¢ngulo
            arrowAngle = Math.atan2(dy, dx);
            
            // Permite um √¢ngulo mais amplo
            if (arrowAngle > Math.PI / 2) {  // Limita √¢ngulo superior (90 graus)
                arrowAngle = Math.PI / 2;
            } else if (arrowAngle < -Math.PI * 0.7) {  // Limita √¢ngulo inferior (-126 graus)
                arrowAngle = -Math.PI * 0.7;
            }
            
            // Ajusta o arco e a flecha para visualiza√ß√£o durante mira
            bow.style.transform = `rotate(${arrowAngle}rad)`;
            arrow.style.transform = `rotate(${arrowAngle}rad)`;
            
            // Calcula a velocidade baseada na dist√¢ncia e √¢ngulo
            arrowSpeed = distance * powerFactor;
            
            // Atualiza o indicador de pot√™ncia
            const powerPercentage = (distance / maxPull) * 100;
            //powerBar.style.width = powerPercentage + '%';
            
            if (powerPercentage < 33) {
                powerBar.style.backgroundColor = 'green';
            } else if (powerPercentage < 66) {
                powerBar.style.backgroundColor = 'yellow';
            } else {
                powerBar.style.backgroundColor = 'red';
            }
        });
        
        gameContainer.addEventListener('mouseup', function() {
            if (!isDragging || gameOver) return;
            
            isDragging = false;
            
            // Decomp√µe a velocidade em componentes X e Y de acordo com o √¢ngulo
            arrowVelocityX = Math.cos(arrowAngle *-1) * arrowSpeed;
            arrowVelocityY = Math.sin(arrowAngle *-1) * arrowSpeed;
            
            // Atira a flecha
            arrowFired = true;
            updateArrow();
        });
        
        // Evitar arrastar o mouse para fora
        gameContainer.addEventListener('mouseleave', function() {
            if (isDragging && !arrowFired && !gameOver) {
                isDragging = false;
                if (arrowSpeed > 0) {
                    // Decomp√µe a velocidade em componentes X e Y
                    arrowVelocityX = Math.cos(arrowAngle) * arrowSpeed;
                    arrowVelocityY = Math.sin(arrowAngle) * arrowSpeed;
                    
                    arrowFired = true;
                    updateArrow();
                }
            }
        });
        
        // Eventos de toque para dispositivos m√≥veis
        gameContainer.addEventListener('touchstart', function(e) {
            if (gameOver || arrowFired) return;
            
            e.preventDefault();
            isDragging = true;
            const touch = e.touches[0];
            startX = touch.clientX;
            startY = touch.clientY;
            
            // Mostra a flecha e o indicador de pot√™ncia
            arrow.style.display = 'block';
            powerIndicator.style.display = 'block';
        });
        
        gameContainer.addEventListener('touchmove', function(e) {
            if (!isDragging || gameOver) return;
            
            e.preventDefault();
            const touch = e.touches[0];
            const dx = startX - touch.clientX;
            const dy = startY - touch.clientY;
            
            // Limita o quanto pode puxar o arco
            const maxPull = 150;
            const distance = Math.min(Math.sqrt(dx * dx + dy * dy), maxPull);
            
            // Calcula o √¢ngulo
            arrowAngle = Math.atan2(dy, dx);
            
            // Permite um √¢ngulo mais amplo
            if (arrowAngle > Math.PI / 2) {
                arrowAngle = Math.PI /.2;
            } else if (arrowAngle < -Math.PI * 0.7) {
                arrowAngle = -Math.PI * 0.7;
            }
            
            // Ajusta o arco e a flecha
            bow.style.transform = `rotate(${arrowAngle * -1}rad)`;
            arrow.style.transform = `rotate(${arrowAngle * -1}rad)`;
            
            // Calcula a velocidade com base na dist√¢ncia puxada
            arrowSpeed = distance * powerFactor;
            
            // Atualiza o indicador de pot√™ncia
            const powerPercentage = (distance / maxPull) * 100;
            //powerBar.style.width = powerPercentage + '%';
            
            if (powerPercentage < 33) {
                powerBar.style.backgroundColor = 'green';
            } else if (powerPercentage < 66) {
                powerBar.style.backgroundColor = 'yellow';
            } else {
                powerBar.style.backgroundColor = 'red';
            }
        });
        
        gameContainer.addEventListener('touchend', function(e) {
            if (!isDragging || gameOver) return;
            
            e.preventDefault();
            isDragging = false;
            
            // Decomp√µe a velocidade em componentes X e Y
            arrowVelocityX = Math.cos(arrowAngle) * arrowSpeed;
            arrowVelocityY = Math.sin(arrowAngle) * arrowSpeed;
            
            // Atira a flecha
            arrowFired = true;
            updateArrow();
        });
        
        // Ativa/desativa modo de debug com a tecla 'd'
        document.addEventListener('keydown', function(e) {
            if (e.key === 'd' || e.key === 'D') {
                debugMode = !debugMode;
                debugInfo.style.display = debugMode ? 'block' : 'none';
            }
        });
        
        // Bot√£o de reiniciar
        restartButton.addEventListener('click', restartGame);
        
        // Inicializa o jogo
        initGame();
    </script>
</body>
</html>