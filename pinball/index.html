<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KM6SHZXP');</script>
    <!-- End Google Tag Manager -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pimbal - Enhanced Pinball</title>
    <style>
        body {
            background-color: #1a1a1a; /* Darker background */
            color: #e0e0e0; /* Lighter text */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Cleaner font */
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            flex-direction: column;
        }

        #gameCanvas {
            background: linear-gradient(to bottom, #101015, #000000); /* Subtle gradient */
            border: 4px solid #555; /* Thicker border */
            border-radius: 15px; /* More rounded */
            box-shadow: 0 0 25px rgba(255, 255, 255, 0.1); /* Outer glow */
        }

        #gameInfo {
            margin-top: 15px;
            font-size: 20px;
            display: flex;
            gap: 30px; /* Increased gap */
            color: #ccc;
            text-shadow: 1px 1px 2px #000;
        }
        #gameInfo span {
            color: #fff;
            font-weight: bold;
        }

        h1 {
            margin-bottom: 15px;
            color: #FFD700; /* Gold */
            font-size: 2.5em;
            text-shadow: 0 0 8px #FF8C00, 0 0 15px #FF5733; /* Enhanced glow */
            letter-spacing: 2px;
        }

        /* Define color classes if needed for specific zone text, but often drawn on canvas */
    </style>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KM6SHZXP"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <h1>PIMBAL</h1>
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    <div id="gameInfo">
        <div>Score: <span id="score">0</span></div>
        <div>Lives: <span id="lives">3</span></div>
        <div>Multiplier: <span id="multiplier">1x</span></div>
    </div>

    <script>
        // Game Canvas Setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;

        // Game variables
        let score = 0;
        let lives = 3;
        let currentMultiplier = 1;
        let gameActive = true;
        let gameStarted = false;
        let particles = []; // For visual effects

        // --- Variáveis de Segurança da Bola ---
        let ballStuckTimer = 0; // Timer para bola parada
        const MAX_STUCK_TIME_SECONDS = 6; // Tempo máximo parada (em segundos)
        const STUCK_VELOCITY_THRESHOLD = 0.15; // Velocidade abaixo da qual é considerada parada

        // --- Constants ---
        const BALL_RADIUS = 8;
        const GRAVITY = 0.2;
        const FRICTION = 0.995; // Air resistance / rolling friction
        const BUMPER_BOUNCE = 1.05; // How much speed increases on bumper hit
        const FLIPPER_STRENGTH = 10; // Base upward speed boost from flipper
        const FLIPPER_SIDE_STRENGTH = 4; // Sideways boost

        const LEFT_FLIPPER_REST_ANGLE = Math.PI / 6; // Point slightly up when resting
        const LEFT_FLIPPER_ACTIVE_ANGLE = -Math.PI / 4; // Angle when flipped up
        const RIGHT_FLIPPER_REST_ANGLE = Math.PI - Math.PI / 6; // Mirror rest angle
        const RIGHT_FLIPPER_ACTIVE_ANGLE = Math.PI + Math.PI / 4; // Mirror active angle

        // Ball properties
        const ball = {
            xInitial: canvasWidth - 24,
            yInitial: canvasHeight - 89,
            x: canvasWidth - 24, // Start in launcher lane
            y: canvasHeight - 89,
            radius: BALL_RADIUS,
            speedX: 0,
            speedY: 0,
            isLaunched: false
        };

        // Launcher properties
        const launcher = {
            x: canvasWidth - 25, // Positioned in the launcher lane
            y: canvasHeight - 80, // Bottom position
            width: 15,
            height: 70, // Total visual height
            pullDistance: 0, // How far it's pulled back
            maxPull: 60, // Max pixels it can be pulled
            springStiffness: 0.4, // Power based on pull distance
            charging: false
        };

        // Flipper properties - Revised for Pivot Rotation
        const flipperHeight = 10;
        const flipperWidth = 70; // Adjusted size

        const leftFlipper = {
            pivotX: 110, // Pivot X (closer to center)
            pivotY: canvasHeight - 60, // Pivot Y
            width: flipperWidth,
            height: flipperHeight,
            restAngle: LEFT_FLIPPER_REST_ANGLE,
            activeAngle: LEFT_FLIPPER_ACTIVE_ANGLE,
            currentAngle: LEFT_FLIPPER_REST_ANGLE,
            angularVelocity: 0, // For smooth animation
            isActivating: false, // Is the key pressed?
            isUp: false, // Is it fully up? (Used for state checking)
            color: '#E0E0E0',
            isLeft: false
        };

        const rightFlipper = {
            pivotX: canvasWidth - 110, // Pivot X (mirror)
            pivotY: canvasHeight - 60, // Pivot Y
            width: flipperWidth,
            height: flipperHeight,
            restAngle: RIGHT_FLIPPER_REST_ANGLE,
            activeAngle: RIGHT_FLIPPER_ACTIVE_ANGLE,
            currentAngle: RIGHT_FLIPPER_REST_ANGLE,
            angularVelocity: 0,
            isActivating: false,
            isUp: false,
            color: '#E0E0E0',
            isLeft: false
        };
        const FLIPPER_ROTATE_SPEED = 0.5; // Radians per frame step (adjust for speed)

        // Obstacles - Bumpers
        const bumpers = [
            // Add hit state and cooldown for visual effects
            { x: 100, y: 150, radius: 18, points: 10, color: '#FF5733', hitColor: '#FFC300', isHit: false, hitTimer: 0 },
            { x: 200, y: 200, radius: 22, points: 15, color: '#FF5733', hitColor: '#FFC300', isHit: false, hitTimer: 0 },
            { x: 300, y: 150, radius: 18, points: 10, color: '#FF5733', hitColor: '#FFC300', isHit: false, hitTimer: 0 },
            { x: 150, y: 300, radius: 15, points: 5, color: '#33FF57', hitColor: '#90EE90', isHit: false, hitTimer: 0 },
            { x: 250, y: 300, radius: 15, points: 5, color: '#33FF57', hitColor: '#90EE90', isHit: false, hitTimer: 0 }
        ];
        const BUMPER_HIT_DURATION = 8; // Frames the hit color shows

        // Multiplier zones
        const multiplierZones = [
            { x: 50, y: 100, width: 60, height: 60, multiplier: 2, color: 'rgba(255, 87, 51, 0.2)', borderColor: 'rgba(255, 87, 51, 0.8)' },
            { x: 290, y: 100, width: 60, height: 60, multiplier: 2, color: 'rgba(255, 87, 51, 0.2)', borderColor: 'rgba(255, 87, 51, 0.8)' },
            { x: 170, y: 100, width: 60, height: 60, multiplier: 3, color: 'rgba(51, 255, 87, 0.2)', borderColor: 'rgba(51, 255, 87, 0.8)' },
            { x: 170, y: 250, width: 60, height: 60, multiplier: 5, color: 'rgba(51, 87, 255, 0.2)', borderColor: 'rgba(51, 87, 255, 0.8)' }
        ];

        // Walls and boundaries - Defined as line segments for better collision
        const walls = [
            // Outer Walls
            { x1: 10, y1: 10, x2: 10, y2: canvasHeight - 80 }, // Left straight
            { x1: canvasWidth - 10, y1: 10, x2: canvasWidth - 10, y2: canvasHeight }, // Right straight (full height for launcher lane)
            { x1: 350, y1: 0, x2: canvasWidth - 10, y2: 50 }, // Top diagonal straight
            { x1: 10, y1: 0, x2: canvasWidth - 10, y2: 0 }, // Top straight

            // Bottom Diagonal Walls
            { x1: 10, y1: canvasHeight - 80, x2: leftFlipper.pivotX - flipperWidth/3, y2: leftFlipper.pivotY + 10 }, // Bottom Left Diagonal
            { x1: canvasWidth - 10, y1: canvasHeight - 80, x2: rightFlipper.pivotX + flipperWidth/3, y2: rightFlipper.pivotY + 10 }, // Bottom Right Diagonal (adjusted start y)

            // Walls around flippers leading to drain (adjust points carefully)
            { x1: leftFlipper.pivotX + flipperWidth/1.5, y1: leftFlipper.pivotY+15, x2: canvasWidth/2 - 10, y2: canvasHeight}, // Left side of drain
            { x1: rightFlipper.pivotX - flipperWidth/1.5, y1: rightFlipper.pivotY+15, x2: canvasWidth/2 + 10, y2: canvasHeight}, // Right side of drain

            // Launcher lane wall
            { x1: canvasWidth - 45, y1: 100, x2: canvasWidth - 45, y2: canvasHeight - launcher.height - 10 } // Inner wall of launcher lane
        ];

        // Event listeners
        document.addEventListener('keydown', function(e) {
            if (e.key === ' ' || e.key === 'Spacebar') {
                launcher.charging = true;
            }
            if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'z') {
                leftFlipper.isActivating = true;
            }
            if (e.key === 'ArrowRight' || e.key === '/') { // Forward slash often used
                rightFlipper.isActivating = true;
            }
            if (e.key === 'Enter' && !gameActive) {
                resetGame();
            }
        });

        document.addEventListener('keyup', function(e) {
            if (e.key === ' ' || e.key === 'Spacebar') {
                if (launcher.charging && !ball.isLaunched) {
                    launchBall();
                }
                launcher.charging = false;
                launcher.pullDistance = 0; // Reset pull on release
            }
            if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'z') {
                leftFlipper.isActivating = false;
            }
            if (e.key === 'ArrowRight' || e.key === '/') {
                rightFlipper.isActivating = false;
            }
        });

        // Game functions
        function resetGame() {
            score = 0;
            lives = 3;
            currentMultiplier = 1;
            gameActive = true;
            gameStarted = false; // Needs to be started again by launching
            particles = [];

            resetBall(); // Reset ball position and state
            leftFlipper.currentAngle = leftFlipper.restAngle;
            rightFlipper.currentAngle = rightFlipper.restAngle;
            leftFlipper.isActivating = false;
            rightFlipper.isActivating = false;

            updateScoreDisplay();
        }

         function resetBallPosition() {
            console.log("Resetting ball position (stuck or out of bounds)");
            ball.x = ball.xInitial; // Posição inicial no lançador
            ball.y = ball.yInitial;
            ball.speedX = 0;
            ball.speedY = 0;
            ball.isLaunched = false; // Precisa ser lançada novamente
            launcher.pullDistance = 0; // Reseta o lançador também
            ballStuckTimer = 0; // Reseta o timer de parada
            // NÃO mexe em lives ou currentMultiplier
             createParticles(ball.x, ball.y, 5, '#8888FF'); // Efeito visual de reset
        }

        function checkBallStuckOrOutOfBounds(deltaTime) {
            if (!ball.isLaunched || !gameActive) {
                ballStuckTimer = 0; // Reseta timer se não lançada ou jogo inativo
                return; // Só valida após lançar e enquanto o jogo está ativo
            }

            // --- Verificar se está parada ---
            const currentSpeedSq = ball.speedX * ball.speedX + ball.speedY * ball.speedY;
            if (currentSpeedSq < STUCK_VELOCITY_THRESHOLD * STUCK_VELOCITY_THRESHOLD) {
                ballStuckTimer += deltaTime; // Incrementa usando delta time
            } else {
                ballStuckTimer = 0; // Reseta o timer se a bola está se movendo
            }

            if (ballStuckTimer > MAX_STUCK_TIME_SECONDS) {
                console.warn(`Ball stuck for ${ballStuckTimer.toFixed(1)}s, resetting.`);
                resetBallPosition();
                return; // Sai da função após resetar
            }

            // --- Verificar se está fora dos limites seguros (antes de cair no dreno) ---
            // Define limites seguros (um pouco dentro das paredes e acima da área de perigo dos flippers)
            const safeMinX = 10 + ball.radius;
            const safeMaxX = canvasWidth - 10 - ball.radius; // Ajustar se a lane do lançador for diferente
            const safeMinY = 10 + ball.radius;
            const safeMaxY = canvasHeight - 20; // Acima da área onde o dreno normal ocorre

            if (ball.x < safeMinX || ball.x > safeMaxX || ball.y < safeMinY)
            {
                // Considera fora de bounds APENAS se NÃO estiver na área do lançador inicial
                // E se não estiver caindo na área do dreno (o check de dreno normal cuidará disso)
                const isInLauncherArea = ball.x > canvasWidth - 45 - ball.radius && ball.y > canvasHeight - launcher.height - 10 - ball.radius;

                if (!isInLauncherArea && ball.y < safeMaxY) { // Só reseta se estiver acima da área de perigo
                     console.warn(`Ball out of safe bounds (${ball.x.toFixed(0)}, ${ball.y.toFixed(0)}), resetting.`);
                     resetBallPosition();
                     return;
                 }
            }
            // Nota: Não precisamos checar ball.y > safeMaxY aqui,
            // pois a lógica de perda de vida já cuida da queda total.
        }

        function resetBall() {
            ball.x = ball.xInitial; // Posição inicial no lançador
            ball.y = ball.yInitial;
            ball.speedX = 0;
            ball.speedY = 0;
            ball.isLaunched = false;
            launcher.pullDistance = 0;
            currentMultiplier = 1; // Reset multiplier on losing a ball
        }

        function launchBall() {
            if (!ball.isLaunched && launcher.pullDistance > 5) { // Require some pull
                ball.isLaunched = true;
                // Calculate launch speed based on pull distance
                ball.speedY = -(launcher.pullDistance * launcher.springStiffness * 1.4);
                ball.speedX = -1 - Math.random(); // Slight random angle leftwards
                launcher.pullDistance = 0;
                if (!gameStarted) gameStarted = true; // Mark game as started
                createParticles(ball.x, ball.y + 10, 10, '#FFFF88'); // Launch sparks
            }
            launcher.charging = false; // Stop charging after launch/release
        }

        function updateScoreDisplay() {
            document.getElementById('score').textContent = score;
            document.getElementById('lives').textContent = lives;
            document.getElementById('multiplier').textContent = currentMultiplier + 'x';
        }

        // --- Drawing Functions ---
        function drawBall() {
            // Add gradient for 3D look
            const gradient = ctx.createRadialGradient(ball.x - ball.radius * 0.3, ball.y - ball.radius * 0.3, ball.radius * 0.1, ball.x, ball.y, ball.radius);
            gradient.addColorStop(0, '#FFFFFF'); // Highlight
            gradient.addColorStop(0.8, '#E0E0E0'); // Main color
            gradient.addColorStop(1, '#AAAAAA'); // Shadow edge

            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            // Add a subtle shadow beneath the ball
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 5;
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 2;
            ctx.fill();
            ctx.closePath();
            // Reset shadow for other elements
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }

        function drawLauncher() {
            ctx.save();
            // Base plate for launcher
             ctx.fillStyle = '#333';
             ctx.fillRect(canvasWidth - 45, canvasHeight - launcher.height - 10, 35, launcher.height + 10);


            // Spring simulation based on pullDistance
            const currentHeight = launcher.height - launcher.pullDistance;
            const springBaseY = launcher.y + launcher.height; // Bottom of spring path

            // Draw the visible plunger part
            ctx.fillStyle = '#999';
            ctx.fillRect(launcher.x - launcher.width / 2, springBaseY - currentHeight, launcher.width, currentHeight);
            // Draw plunger top cap
            ctx.fillStyle = '#CCC';
            ctx.fillRect(launcher.x - launcher.width / 2 - 2, springBaseY - currentHeight - 5, launcher.width + 4, 5);


            // Draw Spring visualization (compressed part)
            ctx.strokeStyle = '#AAA';
            ctx.lineWidth = 3;
            ctx.beginPath();
            const startY = springBaseY - currentHeight; // Top of visible plunger
            const endY = springBaseY; // Bottom fixed point
            const visibleSpringLength = endY - startY;
            const waves = Math.max(2, Math.floor(8 * (visibleSpringLength / launcher.height))); // Fewer waves when compressed

            ctx.moveTo(launcher.x, startY); // Start at plunger top center
            for (let i = 0; i < waves; i++) {
                // Zigzag pattern
                const waveX = launcher.x + (i % 2 === 0 ? 1 : -1) * launcher.width * 0.6;
                const waveY = startY + (i + 0.5) * (visibleSpringLength / waves);
                ctx.lineTo(waveX, waveY);
            }
            ctx.lineTo(launcher.x, endY); // End at base center
            ctx.stroke();


            // Draw Power Meter next to launcher (visual only)
            const meterX = canvasWidth - 60;
            const meterY = canvasHeight - launcher.height - 10;
            const meterWidth = 8;
            const meterHeight = launcher.height;
            ctx.fillStyle = '#444';
            ctx.fillRect(meterX, meterY, meterWidth, meterHeight);
            const powerHeight = (launcher.pullDistance / launcher.maxPull) * meterHeight;
            // Gradient for power fill
            const powerGrad = ctx.createLinearGradient(meterX, meterY + meterHeight, meterX, meterY);
            powerGrad.addColorStop(0, '#00FF00'); // Green at bottom
            powerGrad.addColorStop(0.5, '#FFFF00'); // Yellow middle
            powerGrad.addColorStop(1, '#FF0000'); // Red at top
            ctx.fillStyle = powerGrad;
            ctx.fillRect(meterX, meterY + meterHeight - powerHeight, meterWidth, powerHeight);
            ctx.strokeStyle = '#888';
            ctx.strokeRect(meterX, meterY, meterWidth, meterHeight);

            ctx.restore();
        }

        function drawFlipper(flipper) {
            ctx.save();
            // Translate to the PIVOT point
            ctx.translate(flipper.pivotX, flipper.pivotY);
            ctx.rotate(flipper.currentAngle);

            // Draw the flipper rectangle relative to the pivot
            // If it's the left flipper, its visual body extends to the left of the pivot
            // If right, it extends to the right. Pivot is at one end.
            const drawX = flipper.isLeft ? -flipper.width : 0;

             // Add gradient and shadow for better look
             const gradient = ctx.createLinearGradient(drawX, -flipper.height / 2, drawX, flipper.height / 2);
             gradient.addColorStop(0, '#FFFFFF');
             gradient.addColorStop(0.5, '#E0E0E0');
             gradient.addColorStop(1, '#C0C0C0');
             ctx.fillStyle = gradient;
             ctx.strokeStyle = '#555'; // Outline
             ctx.lineWidth = 1;

             ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
             ctx.shadowBlur = 4;
             ctx.shadowOffsetX = 1;
             ctx.shadowOffsetY = 2;

             ctx.beginPath();
             ctx.rect(drawX, -flipper.height / 2, flipper.width, flipper.height);
             ctx.fill();
             ctx.stroke();
             ctx.closePath();

             // Reset shadow
             ctx.shadowColor = 'transparent';

            // Draw pivot point visually (optional)
             ctx.fillStyle = '#444';
             ctx.beginPath();
             ctx.arc(0, 0, flipper.height/1.5, 0, Math.PI * 2); // Circle at pivot
             ctx.fill();


            ctx.restore();
        }

        function drawBumpers() {
            bumpers.forEach(bumper => {
                const displayColor = bumper.isHit ? bumper.hitColor : bumper.color;

                // Add gradient for 3D effect
                const gradient = ctx.createRadialGradient(
                    bumper.x - bumper.radius * 0.4, bumper.y - bumper.radius * 0.4, bumper.radius * 0.1, // Inner lighter spot
                    bumper.x, bumper.y, bumper.radius
                );
                gradient.addColorStop(0, shadeColor(displayColor, 40)); // Lighter highlight
                gradient.addColorStop(0.7, displayColor);
                gradient.addColorStop(1, shadeColor(displayColor, -40)); // Darker edge

                ctx.beginPath();
                ctx.arc(bumper.x, bumper.y, bumper.radius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;

                // Add glow effect when hit
                if (bumper.isHit) {
                    ctx.shadowColor = bumper.hitColor;
                    ctx.shadowBlur = 15 + Math.random() * 10; // Pulsing glow
                } else {
                    ctx.shadowColor = displayColor;
                    ctx.shadowBlur = 8;
                }
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;

                ctx.fill();

                 // Reset shadow
                 ctx.shadowColor = 'transparent';
                 ctx.shadowBlur = 0;


                 // Outline (optional)
                 ctx.strokeStyle = shadeColor(displayColor, -60); // Darker outline
                 ctx.lineWidth = 2;
                 ctx.stroke();
                 ctx.closePath();
            });
        }

        function drawMultiplierZones() {
            multiplierZones.forEach(zone => {
                ctx.beginPath();
                ctx.rect(zone.x, zone.y, zone.width, zone.height);
                // Fill with semi-transparent color
                ctx.fillStyle = zone.color;
                ctx.fill();
                // Draw a more prominent border
                ctx.strokeStyle = zone.borderColor;
                ctx.lineWidth = 2;
                // Dashed line effect for border
                 ctx.setLineDash([5, 5]); // Pattern: 5 pixels drawn, 5 pixels gap
                ctx.stroke();
                ctx.setLineDash([]); // Reset to solid line for other drawings
                ctx.closePath();

                // Draw multiplier text (make it stand out more)
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 20px Arial'; // Larger, bolder font
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 1;
                ctx.shadowOffsetY = 1;
                ctx.fillText(`${zone.multiplier}x`, zone.x + zone.width / 2, zone.y + zone.height / 2 + 8); // Adjust Y offset for font size
                 // Reset shadow
                 ctx.shadowColor = 'transparent';
            });
        }

        function drawWalls() {
            ctx.strokeStyle = '#777'; // Grey color for walls
            ctx.lineWidth = 5; // Make walls thicker
             ctx.lineCap = 'round'; // Rounded ends

            walls.forEach(wall => {
                ctx.beginPath();
                ctx.moveTo(wall.x1, wall.y1);
                ctx.lineTo(wall.x2, wall.y2);
                ctx.stroke();
            });
             ctx.lineCap = 'butt'; // Reset line cap
        }

        function drawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${p.r}, ${p.g}, ${p.b}, ${p.alpha})`;
                ctx.fill();

                // Update particle
                p.x += p.vx;
                p.y += p.vy;
                p.alpha -= p.decay;
                p.size *= 0.98; // Shrink slightly

                if (p.alpha <= 0 || p.size < 0.5) {
                    particles.splice(i, 1); // Remove dead particles
                }
            }
        }


        // --- Collision Detection ---

        // Helper: Calculate distance between two points squared (faster than sqrt)
        function distSq(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            return dx * dx + dy * dy;
        }

        // Helper: Closest point on a line segment to a point
        function closestPointOnSegment(px, py, x1, y1, x2, y2) {
            const lineLenSq = distSq(x1, y1, x2, y2);
            if (lineLenSq < 0.0001) return { x: x1, y: y1, t: 0 }; // Segment is a point

            // Project point onto the line containing the segment
            const t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / lineLenSq;

            if (t < 0) return { x: x1, y: y1, t: 0 }; // Closest point is p1
            if (t > 1) return { x: x2, y: y2, t: 1 }; // Closest point is p2

            // Closest point is within the segment
            const closestX = x1 + t * (x2 - x1);
            const closestY = y1 + t * (y2 - y1);
            return { x: closestX, y: closestY, t: t };
        }

         // Helper: Reflect velocity vector off a normal vector
         function reflectVelocity(vx, vy, normalX, normalY) {
             const speed = Math.sqrt(vx*vx + vy*vy);
             const dot = vx * normalX + vy * normalY;
             // Reflect velocity vector: v' = v - 2 * (v . n) * n
             const reflectVx = vx - 2 * dot * normalX;
             const reflectVy = vy - 2 * dot * normalY;
             // Optionally normalize and scale, or just return reflected components
             // Normalizing and scaling by original speed might prevent weird speed changes
             const reflectSpeed = Math.sqrt(reflectVx*reflectVx + reflectVy*reflectVy);
             if (reflectSpeed === 0) return {x: 0, y: 0}; // Avoid division by zero
             return { x: (reflectVx / reflectSpeed) * speed, y: (reflectVy / reflectSpeed) * speed };
         }

         function checkWallCollisions() {
             const restitution = 0.5; // Bounciness factor

             walls.forEach(wall => {
                 const { x: closestX, y: closestY } = closestPointOnSegment(ball.x, ball.y, wall.x1, wall.y1, wall.x2, wall.y2);
                 const distanceSquared = distSq(ball.x, ball.y, closestX, closestY);

                 if (distanceSquared < ball.radius * ball.radius) {
                    // Collision occurred
                     // Move ball out of collision slightly to prevent sticking
                     const overlap = ball.radius - Math.sqrt(distanceSquared);
                     const dx = ball.x - closestX;
                     const dy = ball.y - closestY;
                     const collisionDist = Math.sqrt(dx*dx + dy*dy);
                     // Avoid division by zero if somehow distance is zero
                    const moveX = collisionDist < 0.01 ? 0 : (dx / collisionDist) * overlap;
                    const moveY = collisionDist < 0.01 ? 0 : (dy / collisionDist) * overlap;
                     ball.x += moveX;
                     ball.y += moveY;


                     // Calculate the normal vector of the wall segment
                     let wallDx = wall.x2 - wall.x1;
                     let wallDy = wall.y2 - wall.y1;
                     // Normal vector (perpendicular, pointing "outward" from the wall)
                     // Need consistent winding or knowledge of which side is "inside"
                     // Simple approach: Use normal pointing away from ball center
                     let normalX = -(wallDy);
                     let normalY = wallDx;
                     // Ensure normal points away from ball
                     if ((ball.x - closestX) * normalX + (ball.y - closestY) * normalY < 0) {
                         normalX *= -1;
                         normalY *= -1;
                     }
                     const normalLen = Math.sqrt(normalX*normalX + normalY*normalY);
                     if (normalLen > 0.01) {
                        normalX /= normalLen;
                        normalY /= normalLen;
                     } else { // Segment is a point, use direction from ball? Not ideal. Default normal?
                         normalX = moveX / overlap; // Use penetration direction if normal fails
                         normalY = moveY / overlap;
                     }


                     // Reflect velocity using the calculated normal
                     const reflected = reflectVelocity(ball.speedX, ball.speedY, normalX, normalY);
                     ball.speedX = reflected.x * restitution;
                     ball.speedY = reflected.y * restitution;
                      // Optional: Add small sound effect here
                      createParticles(closestX, closestY, 3, '#AAAAAA'); // Wall sparks
                 }
            });

             // Drain check (moved out of wall loop for clarity)
             if (ball.y > canvasHeight + ball.radius * 2) { // Check slightly below canvas bottom
                if (lives > 1) {
                    lives--;
                    resetBall(); // Use reset function
                 } else {
                    lives = 0;
                    gameActive = false;
                 }
                 updateScoreDisplay();
             }
        }

        function checkBumperCollisions() {
            bumpers.forEach(bumper => {
                 if (bumper.hitTimer > 0) bumper.hitTimer--; // Decrement hit timer
                 else bumper.isHit = false;

                 const distanceSquared = distSq(ball.x, ball.y, bumper.x, bumper.y);
                 const radiiSumSquared = (ball.radius + bumper.radius) * (ball.radius + bumper.radius);

                if (distanceSquared < radiiSumSquared) {
                    // Collision!
                    const distance = Math.sqrt(distanceSquared);
                    const overlap = (ball.radius + bumper.radius) - distance;

                     // Normal of collision (from bumper center to ball center)
                     const normalX = (ball.x - bumper.x) / distance;
                     const normalY = (ball.y - bumper.y) / distance;

                     // Move ball out of collision
                     ball.x += normalX * overlap;
                     ball.y += normalY * overlap;

                     // Reflect velocity (basic reflection off the normal)
                     const reflected = reflectVelocity(ball.speedX, ball.speedY, normalX, normalY);

                     // Apply bounce factor and ensure minimum speed away from bumper
                     const currentSpeed = Math.sqrt(ball.speedX**2 + ball.speedY**2);
                     const minBounceSpeed = 5; // Minimum speed after hit
                     const bounceSpeed = Math.max(minBounceSpeed, currentSpeed * BUMPER_BOUNCE);

                     const speedFactor = bounceSpeed / Math.sqrt(reflected.x**2 + reflected.y**2);

                     ball.speedX = reflected.x * speedFactor;
                     ball.speedY = reflected.y * speedFactor;


                    // Score and visual feedback
                    if (!bumper.isHit) { // Prevent scoring multiple times on one hit
                         score += bumper.points * currentMultiplier;
                         updateScoreDisplay();
                         bumper.isHit = true;
                         bumper.hitTimer = BUMPER_HIT_DURATION;
                          createParticles(ball.x, ball.y, 15, bumper.hitColor); // Bumper hit sparks
                           // Optional: Play bumper sound
                     }
                }
            });
        }

        function checkMultiplierZoneCollisions() {
             multiplierZones.forEach(zone => {
                 if (ball.x + ball.radius > zone.x && ball.x - ball.radius < zone.x + zone.width &&
                     ball.y + ball.radius > zone.y && ball.y - ball.radius < zone.y + zone.height) {
                     // Ball is inside the zone, update multiplier if it's higher
                      if(zone.multiplier > currentMultiplier) {
                           currentMultiplier = zone.multiplier;
                           updateScoreDisplay();
                           // Optional: Visual/Sound effect for entering zone
                       }
                 }
            });
         }

         function checkFlipperCollisions() {
            checkSingleFlipperCollision(leftFlipper);
            checkSingleFlipperCollision(rightFlipper);
        }

        function checkSingleFlipperCollision(flipper) {
            const ballRadiusSq = ball.radius * ball.radius;

            // 1. Define the flipper rectangle vertices in world space based on current angle
             const angle = flipper.currentAngle;
             const cos = Math.cos(angle);
             const sin = Math.sin(angle);
             const halfHeight = flipper.height / 2;
             const drawX = flipper.isLeft ? -flipper.width : 0; // Start X relative to pivot

             // Calculate corner positions relative to pivot, then add pivot world coords
             const corners = [
                { x: drawX, y: -halfHeight },         // Top-start corner
                { x: drawX + flipper.width, y: -halfHeight }, // Top-end corner
                { x: drawX + flipper.width, y: halfHeight },  // Bottom-end corner
                { x: drawX, y: halfHeight }           // Bottom-start corner
            ].map(p => ({
                x: flipper.pivotX + p.x * cos - p.y * sin,
                y: flipper.pivotY + p.x * sin + p.y * cos
            }));

            // 2. Check collision with the four line segments of the flipper rectangle
            for (let i = 0; i < 4; i++) {
                const p1 = corners[i];
                const p2 = corners[(i + 1) % 4]; // Next corner, wraps around
                 const { x: closestX, y: closestY } = closestPointOnSegment(ball.x, ball.y, p1.x, p1.y, p2.x, p2.y);
                 const distanceSquared = distSq(ball.x, ball.y, closestX, closestY);

                 if (distanceSquared < ballRadiusSq) {
                     // Collision with this edge
                     // Move ball out slightly
                     const overlap = ball.radius - Math.sqrt(distanceSquared);
                     const dx = ball.x - closestX;
                     const dy = ball.y - closestY;
                     const collisionDist = Math.sqrt(dx*dx + dy*dy);
                     const moveX = collisionDist < 0.01 ? 0 : (dx / collisionDist) * overlap;
                     const moveY = collisionDist < 0.01 ? 0 : (dy / collisionDist) * overlap;
                     ball.x += moveX * 1.1; // Move slightly more to ensure separation
                     ball.y += moveY * 1.1;

                     // Calculate edge normal
                     let edgeDx = p2.x - p1.x;
                     let edgeDy = p2.y - p1.y;
                     let normalX = -edgeDy;
                     let normalY = edgeDx;
                     // Ensure normal points outward (away from flipper center, approximate)
                     // A better way involves checking against flipper's pre-rotation axes
                     if ((closestX - flipper.pivotX) * normalX + (closestY - flipper.pivotY) * normalY < 0) {
                         normalX *= -1;
                         normalY *= -1;
                     }
                     const normalLen = Math.sqrt(normalX*normalX + normalY*normalY);
                      if (normalLen > 0.01) {
                         normalX /= normalLen;
                         normalY /= normalLen;
                      }


                     // Reflect velocity
                     const reflected = reflectVelocity(ball.speedX, ball.speedY, normalX, normalY);
                      // Add flipper impulse/angular velocity effect
                      let impulseX = 0;
                      let impulseY = -FLIPPER_STRENGTH; // Base upward impulse
                      // Add sideways push based on flipper
                      impulseX += flipper.isLeft ? FLIPPER_SIDE_STRENGTH : -FLIPPER_SIDE_STRENGTH;
                      // Add angular velocity contribution (simplified)
                      // If flipper is moving up (positive angular velocity for left, negative for right)
                      if (flipper.angularVelocity !== 0) {
                           // This needs more sophisticated physics involving point of contact
                           // Simple boost: increase vertical impulse based on flipper speed
                           impulseY -= Math.abs(flipper.angularVelocity) * 40; // Factor based on rotation speed
                       }

                     // Apply combined reflection and impulse
                      // Weighting reflection vs impulse can be tricky. Let's add impulse to reflected velocity.
                     ball.speedX = reflected.x * 0.5 + impulseX; // Blend reflected velocity with impulse
                     ball.speedY = reflected.y * 0.5 + impulseY;

                     // Add score, visual effect
                     score += 1 * currentMultiplier;
                     updateScoreDisplay();
                     createParticles(closestX, closestY, 8, '#FFFFFF'); // Flipper hit sparks
                      // Optional: Play flipper sound

                     return; // Only handle one edge collision per frame
                 }
             }
         }


        // --- Update Game Logic ---
        function updateFlippers(deltaTime) {
             // Update Left Flipper Angle
             const leftTargetAngle = leftFlipper.isActivating ? leftFlipper.activeAngle : leftFlipper.restAngle;
             const leftAngleDiff = leftTargetAngle - leftFlipper.currentAngle;
             // Apply angular velocity based on difference, clamped by max speed
              leftFlipper.angularVelocity = Math.sign(leftAngleDiff) * Math.min(Math.abs(leftAngleDiff), FLIPPER_ROTATE_SPEED);
              if (Math.abs(leftAngleDiff) > 0.01) { // Check difference before updating
                   leftFlipper.currentAngle += leftFlipper.angularVelocity;
               } else {
                   leftFlipper.currentAngle = leftTargetAngle; // Snap to target angle
                   leftFlipper.angularVelocity = 0;
               }
              leftFlipper.isUp = leftFlipper.currentAngle === leftFlipper.activeAngle;


             // Update Right Flipper Angle
             const rightTargetAngle = rightFlipper.isActivating ? rightFlipper.activeAngle : rightFlipper.restAngle;
             const rightAngleDiff = rightTargetAngle - rightFlipper.currentAngle;
             rightFlipper.angularVelocity = Math.sign(rightAngleDiff) * Math.min(Math.abs(rightAngleDiff), FLIPPER_ROTATE_SPEED);
              if (Math.abs(rightAngleDiff) > 0.01) {
                 rightFlipper.currentAngle += rightFlipper.angularVelocity;
             } else {
                 rightFlipper.currentAngle = rightTargetAngle;
                 rightFlipper.angularVelocity = 0;
             }
              rightFlipper.isUp = rightFlipper.currentAngle === rightFlipper.activeAngle;
        }

        function update(timestamp) {
            if (!gameActive) return; // Don't update if game over

            // Calcular deltaTime
            if (!lastTimestamp) lastTimestamp = timestamp;
            const deltaTime = Math.min(0.1, (timestamp - lastTimestamp) / 1000); // Delta em segundos, com limite
            lastTimestamp = timestamp;

            // Update launcher pull distance
            if (launcher.charging && !ball.isLaunched) {
                launcher.pullDistance += 90 * deltaTime; // Carregamento baseado em tempo (ex: 90 pixels/seg)
                if (launcher.pullDistance > launcher.maxPull) {
                    launcher.pullDistance = launcher.maxPull;
                }
            }

            // Update flippers
            updateFlippers(); // Update flipper angles smoothly

            // Update ball position
            if (ball.isLaunched) {
                ball.speedY += GRAVITY; // Apply Gravity
                ball.x += ball.speedX;
                ball.y += ball.speedY;

                // Apply friction/air resistance
                ball.speedX *= FRICTION;
                ball.speedY *= FRICTION;

                // Check all collisions
                checkBallStuckOrOutOfBounds(deltaTime);
                checkWallCollisions();
                checkBumperCollisions();
                checkMultiplierZoneCollisions();
                checkFlipperCollisions(); // Check new flipper collision logic

                // Verifica colisões apenas se a bola ainda estiver ativa (não foi resetada acima)
                if (ball.isLaunched) {
                    checkWallCollisions();      // Inclui o check de dreno que PERDE vida
                    checkBumperCollisions();
                    checkMultiplierZoneCollisions();
                    checkFlipperCollisions();
                }
            }

            // Update bumper hit state timers
            bumpers.forEach(bumper => {
               if (bumper.hitTimer > 0) bumper.hitTimer -= 1; // Simples contador de frames
                // Alternativa baseada em tempo:
                // if (bumper.hitTimer > 0) bumper.hitTimer -= deltaTime;
                else bumper.isHit = false;
            });
        }

        // --- Main Draw Function ---
        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)'; // More opaque
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            ctx.fillStyle = '#FF4500'; // Orange-Red
            ctx.font = 'bold 48px Segoe UI, Tahoma, Geneva, Verdana, sans-serif';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#000';
            ctx.shadowBlur = 5;
            ctx.fillText('GAME OVER', canvasWidth / 2, canvasHeight / 2 - 60);

            ctx.fillStyle = '#FFFFFF';
            ctx.font = '28px Segoe UI, Tahoma, Geneva, Verdana, sans-serif';
            ctx.fillText(`Final Score: ${score}`, canvasWidth / 2, canvasHeight / 2 + 0);

            ctx.font = '20px Segoe UI, Tahoma, Geneva, Verdana, sans-serif';
            ctx.fillStyle = '#DDDDDD';
            ctx.fillText('Press ENTER to play again', canvasWidth / 2, canvasHeight / 2 + 50);

             ctx.shadowColor = 'transparent'; // Reset shadow
        }

        function drawInstructions() {
            if (!gameStarted && gameActive) { // Show only if game not started AND not game over
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 36px Segoe UI, Tahoma, Geneva, Verdana, sans-serif';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#FF8C00';
                ctx.shadowBlur = 10;
                ctx.fillText('PIMBAL', canvasWidth / 2, canvasHeight / 2 - 140);
                ctx.shadowColor = 'transparent';


                ctx.fillStyle = '#FFFFFF';
                ctx.font = '20px Segoe UI, Tahoma, Geneva, Verdana, sans-serif';
                ctx.fillText('Controls:', canvasWidth / 2, canvasHeight / 2 - 70);

                ctx.font = '18px Segoe UI, Tahoma, Geneva, Verdana, sans-serif';
                ctx.fillText('SPACE - Charge & Launch Ball', canvasWidth / 2, canvasHeight / 2 - 30);
                ctx.fillText('LEFT ARROW / Z - Left Flipper', canvasWidth / 2, canvasHeight / 2 + 0);
                ctx.fillText('RIGHT ARROW / Slash (/) - Right Flipper', canvasWidth / 2, canvasHeight / 2 + 30);

                ctx.fillStyle = '#66FF66'; // Bright Green
                ctx.fillText('Hit Bumpers and Zones for Points!', canvasWidth / 2, canvasHeight / 2 + 80);

                ctx.fillStyle = '#FFAA66'; // Light Orange
                ctx.font = 'bold 20px Segoe UI, Tahoma, Geneva, Verdana, sans-serif';
                ctx.fillText('Hold SPACE to charge, Release to launch!', canvasWidth / 2, canvasHeight / 2 + 140);
            }
        }

        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            // Draw game elements (order matters for layering)
            drawMultiplierZones();
            drawWalls(); // Walls behind other elements
            drawBumpers();
            drawLauncher();
            drawParticles(); // Draw particles behind flippers/ball? Or adjust Z
            drawFlipper(leftFlipper); // Draw flippers using pivot logic
            drawFlipper(rightFlipper);
            drawBall(); // Draw ball on top

            // If game over, show message overlay
            if (!gameActive) {
                drawGameOver();
            }

            // Show instructions if game hasn't started (and not game over)
            drawInstructions();
        }


        // --- Utility Functions ---
         function createParticles(x, y, count, color) {
             for (let i = 0; i < count; i++) {
                 const angle = Math.random() * Math.PI * 2;
                 const speed = 1 + Math.random() * 3;
                 const life = 0.4 + Math.random() * 0.4;
                 const rgb = hexToRgb(color); // Use helper to convert hex
                 particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - Math.random() * 1, // Slight upward bias
                    r: rgb ? rgb.r : 255,
                    g: rgb ? rgb.g : 255,
                    b: rgb ? rgb.b : 255,
                    alpha: 0.9,
                    decay: 1.5 / life, // Faster decay looks more 'sparky'
                    size: 1 + Math.random() * 2.5
                });
            }
        }

         function hexToRgb(hex) {
             if (!hex) return null;
             const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
             return result ? {
                 r: parseInt(result[1], 16),
                 g: parseInt(result[2], 16),
                 b: parseInt(result[3], 16)
             } : null;
         }

         function shadeColor(hexColor, percent) {
            if (!hexColor) return '#000000';
             let rgb = hexToRgb(hexColor);
             if (!rgb) return '#000000';
             let { r, g, b } = rgb;

            const amount = Math.round(2.55 * percent); // Convert percent (-100 to 100) to 0-255 range delta

             r = Math.min(255, Math.max(0, r + amount));
             g = Math.min(255, Math.max(0, g + amount));
             b = Math.min(255, Math.max(0, b + amount));

            const rr = r.toString(16).padStart(2, '0');
            const gg = g.toString(16).padStart(2, '0');
            const bb = b.toString(16).padStart(2, '0');
            return `#${rr}${gg}${bb}`;
        }

        // --- Game Loop ---
        function gameLoop(timestamp) { // Adicionar timestamp
            update(timestamp); // Passa o timestamp para update
            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- Start the game ---
        var lastTimestamp = 0; // Inicializar lastTimestamp globalmente também
        updateScoreDisplay();
        // Iniciar o loop com requestAnimationFrame para obter o primeiro timestamp
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>