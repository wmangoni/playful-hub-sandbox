<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo de Xadrez com IA</title>
    <!-- Incluir CSS do chessboardjs -->
    <link rel="stylesheet"
          href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">

    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 20px;
            background-color: #b3aa88;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        /* Container para o tabuleiro e o overlay */
        .board-container {
            position: relative; /* Necessário para posicionar o overlay absoluto */
            width: 400px; /* Mesma largura do tabuleiro */
            margin-bottom: 15px;
        }
        #myBoard {
            width: 400px; /* Ou ajuste conforme necessário */
            margin-bottom: 15px;
        }
        .controls {
            margin-top: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        #status, #turn {
            margin: 5px 0;
            font-weight: bold;
            min-height: 1.2em; /* Evita saltos de layout */
        }
        select, button {
            padding: 8px 12px;
            font-size: 1em;
            cursor: pointer;
        }
        .highlight-check {
            box-shadow: inset 0 0 15px 5px rgba(255, 0, 0, 0.5); /* Destaque visual para rei em xeque */
        }
        /* --- Estilo do Overlay de Loading --- */
        #loadingOverlay {
            position: absolute; /* Posiciona sobre o tabuleiro */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.7); /* Fundo branco semi-transparente */
            color: #333;
            font-size: 1.8em;
            font-weight: bold;
            display: flex; /* Para centralizar o texto */
            justify-content: center;
            align-items: center;
            z-index: 100; /* Garante que fique por cima das peças */
            cursor: wait; /* Muda o cursor */
            border-radius: 3px; /* Opcional: arredondar bordas */
            /* Escondido por padrão */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out; /* Transição suave */
        }
        /* Classe para mostrar o overlay */
        #loadingOverlay.active {
            opacity: 1;
            visibility: visible;
        }
        .captured-pieces {
            display: flex;
            flex-wrap: wrap;
            min-height: 50px;
            padding: 10px;
            margin: 10px 0;
            background: #e8e0d3;
            border-radius: 4px;
            width: 400px; /* Mesma largura do tabuleiro */
        }
        .captured-piece {
            width: 30px;
            height: 30px;
            margin: 2px;
        }
        /* Estilos para destacar a última jogada */
        .highlight-white {
            box-shadow: inset 0 0 3px 3px yellow;
        }
        .highlight-black {
            box-shadow: inset 0 0 3px 3px yellow;
        }
        /* Estilo para os movimentos possíveis */
        .highlight-legal-move {
            background-color: rgba(0, 255, 0, 0.3) !important;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <h2>Xadrez com IA (Minimax Alpha-Beta)</h2>
        <div class="captured-pieces" id="blackCaptured">
            <!-- Peças pretas capturadas -->
        </div>
        <div class="board-container">
            <div id="myBoard"></div>
            <!-- Elemento do Overlay -->
            <div id="loadingOverlay">Pensando...</div>
        </div>
        <div class="captured-pieces" id="whiteCaptured">
            <!-- Peças brancas capturadas -->
        </div>
        <div id="status">Status: Novo Jogo</div>
        <div id="turn">Turno: Brancas</div>

        <div class="controls">
            <label for="difficulty">Dificuldade:</label>
            <select id="difficulty">
                <option value="2">Muito Fácil</option>
                <option value="3" selected>Fácil</option>
                <option value="4">Médio</option>
                <option value="5">Difícil</option>
            </select>
            <button id="newGameButton">Novo Jogo</button>
        </div>
    </div>

    <!-- Incluir Bibliotecas JavaScript -->
    <!-- jQuery (dependência do chessboardjs) -->
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <!-- chessboardjs -->
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <!-- chess.js (lógica do xadrez) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

    <script>
        // --- Variáveis Globais ---
        class OpeningBook {
            constructor() {
                this.entries = new Map(); // hashKey -> [{ move, weight }]
                this.loaded = false;
            }
            
            // métodos da classe...
        }

        class ZobristHashing {
            constructor() {
                this.initialized = false;
                this.pieceValues = {};
                this.randomTable = [];
            }
            
            // métodos da classe...
        }

        var openingBook = new OpeningBook();
        const zobristHashing = new ZobristHashing();

        async function init() {
            openingBook = await loadOpeningBook('human.bin');
        }

        setTimeout(() => {
            init();
        }, 0);

        var board = null; // Objeto chessboardjs
        var game = new Chess(); // Objeto chess.js

        var playerColor = 'w'; // Jogador humano é sempre as brancas por simplicidade
        var aiColor = 'b';
        var currentDifficultyDepth = 3; // Profundidade inicial (Fácil)
        var loadingOverlay = document.getElementById('loadingOverlay'); // Referência ao overlay
        const capturedPieces = {
            w: [], // Peças brancas capturadas
            b: []  // Peças pretas capturadas
        };
        const DEBUG_MODE = false; // Controle global para debug
        const moveSound = new Audio('../assets/sounds/sfx-pop.mp3');
        const victorySound = new Audio('../assets/sounds/powerup3.mp3');
        const defeatSound = new Audio('../assets/sounds/game_over_bgm.mp3');

        // --- CONSTANTES DE AVALIAÇÃO (Ajustáveis) ---
        const PAWN_VALUE = 100;
        const KNIGHT_VALUE = 320;
        const BISHOP_VALUE = 330;
        const ROOK_VALUE = 500;
        const QUEEN_VALUE = 900;
        const KING_VALUE = 20000; // Valor altíssimo para evitar mate

        const DOUBLED_PAWN_PENALTY = -10;
        const ISOLATED_PAWN_PENALTY = -15;
        const PASSED_PAWN_BONUS_BASE = 20; // Bônus aumenta com o avanço
        const CASTLING_BONUS = 50;
        const PAWN_SHIELD_BONUS = 10; // Por peão na frente do rei roqueado
        const KING_EXPOSED_PENALTY = -30;
        const DEVELOPMENT_BONUS = 10; // Por peça menor desenvolvida
        const CENTER_PAWN_BONUS = 15; // Peões em d4/e4/d5/e5
        const ATTACK_CENTER_BONUS = 5; // Peças atacando o centro

        // --- Tabelas Posição-Peça (Piece-Square Tables) ---
        // Valores adaptados/simplificados. Positivo é bom para a peça naquela casa.
        // Definidos da perspectiva das Brancas (linha 0 é a 8ª fileira, linha 7 é a 1ª)

        var pawnTable = [
            [ 0,   0,   0,   0,   0,   0,   0,   0],
            [50,  50,  50,  50,  50,  50,  50,  50], // Peões avançados valem mais
            [10,  10,  20,  30,  30,  20,  10,  10],
            [ 0,   0,   0,  20,  20,   0,   0,   0],
            [ 0,   0,   0,  20,  20,   0,   0,   0], // Centro inicial
            [ 0, -10, -10,   0,   0, -10, -10,   0], // Penalidade pequena para peões bloqueados iniciais
            [ 0,   0,   0, -20, -20,   0,   0,   0], // Penalidade maior para peões muito recuados
            [ 0,   0,   0,   0,   0,   0,   0,   0]
        ];

        var knightTable = [
            [-50, -40, -30, -30, -30, -30, -40, -50],
            [-40, -20,   0,   0,   0,   0, -20, -40],
            [-30,   0,  10,  10,  10,  10,   0, -30],
            [-30,   0,  10,  20,  20,  10,   0, -30], // Cavalos centralizados são bons
            [-30,   0,  10,  20,  20,  10,   0, -30],
            [-30,   0,  10,  10,  10,  10,   0, -30],
            [-40, -20,   0,   0,   0,   0, -20, -40],
            [-50, -40, -30, -30, -30, -30, -40, -50] // Cavalos nos cantos são ruins
        ];

        var bishopTable = [
            [-20, -10, -10, -10, -10, -10, -10, -20],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-10,   0,   0,  10,  10,   0,   0, -10],
            [-10,   0,  10,  10,  10,  10,   0, -10], // Bispos em diagonais longas e centro
            [-10,   0,  10,  10,  10,  10,   0, -10],
            [-10,   0,   0,  10,  10,   0,   0, -10],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-20, -10, -10, -10, -10, -10, -10, -20]
        ];

        var rookTable = [
            [  0,   0,   0,   0,   0,   0,   0,   0],
            [  0,  10,  10,  10,  10,  10,  10,   0], // Torres na 7ª (ou 2ª para pretas)
            [-10,   0,   0,   0,   0,   0,   0, -10], // Ligeiramente pior nas casas iniciais
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [  0,   0,   0,  10,  10,   0,   0,   0] // Bom em colunas abertas/semi-abertas (simplificado)
        ];

        // Rainha: Combinação de Torre e Bispo (simplificado aqui como bônus central)
         var queenTable = [
            [-20, -10, -10,   0,   0, -10, -10, -20],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-10,   0,  10,  10,  10,  10,   0, -10],
            [  0,   0,  10,  10,  10,  10,   0,   0],
            [  0,   0,  10,  10,  10,  10,   0,   0],
            [-10,   0,  10,  10,  10,  10,   0, -10],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-20, -10, -10,   0,   0, -10, -10, -20]
        ];

        // Rei: Segurança é chave (simplificado para evitar bordas/centro no início)
        var kingTable = [
            [ 20,  30,  10,   0,   0,  10,  30,  20], // Bom estar perto do canto após roque
            [ 20,  20,   0,   0,   0,   0,  20,  20],
            [-10, -20, -20, -20, -20, -20, -20, -10],
            [-20, -30, -30, -40, -40, -30, -30, -20], // Ruim no centro exposto
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-30, -40, -40, -50, -50, -40, -40, -30]
        ];

        //Tabela de rei para final de jogo
        var kingTableEndGame = [
            [-50,-40,-30,-20,-20,-30,-40,-50],
            [-30,-20,-10,  0,  0,-10,-20,-30],
            [-30,-10, 20, 30, 30, 20,-10,-30],
            [-30,-10, 30, 40, 40, 30,-10,-30], // Rei ativo no centro no final
            [-30,-10, 30, 40, 40, 30,-10,-30],
            [-30,-10, 20, 30, 30, 20,-10,-30],
            [-30,-20,-10,  0,  0,-10,-20,-30],
            [-50,-40,-30,-20,-20,-30,-40,-50]
        ];

        const ZOBRIST_TABLE = [
            0x9D39247E33776D41n, 0x2AF7398005AAA5C7n, 0x44DB015024623547n, 0x9C15F73E62A76AE2n,
            0x75834465489C0C89n, 0x3290AC3A203001BFn, 0x0FBBAD1F61042279n, 0xE83A908FF2FB60CAn,
            0x0D7E765D58755C10n, 0x1A083822CEAFE02Dn, 0x9605D5F0E25EC3B0n, 0xD021FF5CD13A2ED5n,
            0x40BDF15D4A672E32n, 0x011355146FD56395n, 0x5DB4832046F3D9E5n, 0x239F8B2D7FF719CCn,
            0x05D1A1AE85B49AA1n, 0x679F848F6E8FC971n, 0x7449BBFF801FED0Bn, 0x7D11CDB1C3B7ADF0n,
            0x82C7709E781EB7CCn, 0xF3218F1C9510786Cn, 0x331478F3AF51BBE6n, 0x4BB38DE5E7219443n,
            0xAA649C6EBCFD50FCn, 0x8DBD98A352AFD40Bn, 0x87D2074B81D79217n, 0x19F3C751D3E92AE1n,
            0xB4AB30F062B19ABFn, 0x7B0500AC42047AC4n, 0xC9452CA81A09D85Dn, 0x24AA6C514DA27500n,
            0x4C9F34427501B447n, 0x14A68FD73C910841n, 0xA71B9B83461CBD93n, 0x03488B95B0F1850Fn,
            0x637B2B34FF93C040n, 0x09D1BC9A3DD90A94n, 0x3575668334A1DD3Bn, 0x735E2B97A4C45A23n,
            0x18727070F1BD400Bn, 0x1FCBACD259BF02E7n, 0xD310A7C2CE9B6555n, 0xBF983FE0FE5D8244n,
            0x9F74D14F7454A824n, 0x51EBDC4AB9BA3035n, 0x5C82C505DB9AB0FAn, 0xFCF7FE8A3430B241n,
            0x3253A729B9BA3DDEn, 0x8C74C368081B3075n, 0xB9BC6C87167C33E7n, 0x7EF48F2B83024E20n,
            0x11D505D4C351BD7Fn, 0x6568FCA92C76A243n, 0x4DE0B0F40F32A7B8n, 0x96D693460CC37E5Dn,
            0x42E240CB63689F2Fn, 0x6D2BDCDAE2919661n, 0x42880B0236E4D951n, 0x5F0F4A5898171BB6n,
            0x39F890F579F92F88n, 0x93C5B5F47356388Bn, 0x63DC359D8D231B78n, 0xEC16CA8AEA98AD76n,
            0x5355F900C2A82DC7n, 0x07FB9F855A997142n, 0x5093417AA8A7ED5En, 0x7BCBC38DA25A7F3Cn,
            0x19FC8A768CF4B6D4n, 0x637A7780DECFC0D9n, 0x8249A47AEE0E41F7n, 0x79AD695501E7D1E8n,
            0x14ACBAF4777D5776n, 0xF145B6BECCDEA195n, 0xDABF2AC8201752FCn, 0x24C3C94DF9C8D3F6n,
            0xBB6E2924F03912EAn, 0x0CE26C0B95C980D9n, 0xA49CD132BFBF7CC4n, 0xE99D662AF4243939n,
            0x27E6AD7891165C3Fn, 0x8535F040B9744FF1n, 0x54B3F4FA5F40D873n, 0x72B12C32127FED2Bn,
            0xEE954D3C7B411F47n, 0x9A85AC909A24EAA1n, 0x70AC4CD9F04F21F5n, 0xF9B89D3E99A075C2n,
            0x87B3E2B2B5C907B1n, 0xA366E5B8C54F48B8n, 0xAE4A9346CC3F7CF2n, 0x1920C04D47267BBDn,
            0x87BF02C6B49E2AE9n, 0x092237AC237F3859n, 0xFF07F64EF8ED14D0n, 0x8DE8DCA9F03CC54En,
            0x9C1633264DB49C89n, 0xB3F22C3D0B0B38EDn, 0x390E5FB44D01144Bn, 0x5BFEA5B4712768E9n,
            0x1E1032911FA78984n, 0x9A74ACB964E78CB3n, 0x4F80F7A035DAFB04n, 0x6304D09A0B3738C4n,
            0x2171E64683023A08n, 0x5B9B63EB9CEFF80Cn, 0x506AACF489889342n, 0x1881AFC9A3A701D6n,
            0x6503080440750644n, 0xDFD395339CDBF4A7n, 0xEF927DBCF00C20F2n, 0x7B32F7D1E03680ECn,
            0xB9FD7620E7316243n, 0x05A7E8A57DB91B77n, 0xB5889C6E15630A75n, 0x4A750A09CE9573F7n,
            0xCF464CEC899A2F8An, 0xF538639CE705B824n, 0x3C79A0FF5580EF7Fn, 0xEDE6C87F8477609Dn,
            0x799E81F05BC93F31n, 0x86536B8CF3428A8Cn, 0x97D7374C60087B73n, 0xA246637CFF328532n,
            0x043FCAE60CC0EBA0n, 0x920E449535DD359En, 0x70EB093B15B290CCn, 0x73A1921916591CBDn,
            0x56436C9FE1A1AA8Dn, 0xEFAC4B70633B8F81n, 0xBB215798D45DF7AFn, 0x45F20042F24F1768n,
            0x930F80F4E8EB7462n, 0xFF6712FFCFD75EA1n, 0xAE623FD67468AA70n, 0xDD2C5BC84BC8D8FCn,
            0x7EED120D54CF2DD9n, 0x22FE545401165F1Cn, 0xC91800E98FB99929n, 0x808BD68E6AC10365n,
            0xDEC468145B7605F6n, 0x1BEDE3A3AEF53302n, 0x43539603D6C55602n, 0xAA969B5C691CCB7An,
            0xA87832D392EFEE56n, 0x65942C7B3C7E11AEn, 0xDED2D633CAD004F6n, 0x21F08570F420E565n,
            0xB415938D7DA94E3Cn, 0x91B859E59ECB6350n, 0x10CFF333E0ED804An, 0x28AED140BE0BB7DDn,
            0xC5CC1D89724FA456n, 0x5648F680F11A2741n, 0x2D255069F0B7DAB3n, 0x9BC5A38EF729ABD4n,
            0xEF2F054308F6A2BCn, 0xAF2042F5CC5C2858n, 0x480412BAB7F5BE2An, 0xAEF3AF4A563DFE43n,
            0x19AFE59AE451497Fn, 0x52593803DFF1E840n, 0xF4F076E65F2CE6F0n, 0x11379625747D5AF3n,
            0xBCE5D2248682C115n, 0x9DA4243DE836994Fn, 0x066F70B33FE09017n, 0x4DC4DE189B671A1Cn,
            0x51039AB7712457C3n, 0xC07A3F80C31FB4B4n, 0xB46EE9C5E64A6E7Cn, 0xB3819A42ABE61C87n,
            0x21A007933A522A20n, 0x2DF16F761598AA4Fn, 0x763C4A1371B368FDn, 0xF793C46702E086A0n,
            0xD7288E012AEB8D31n, 0xDE336A2A4BC1C44Bn, 0x0BF692B38D079F23n, 0x2C604A7A177326B3n,
            0x4850E73E03EB6064n, 0xCFC447F1E53C8E1Bn, 0xB05CA3F564268D99n, 0x9AE182C8BC9474E8n,
            0xA4FC4BD4FC5558CAn, 0xE755178D58FC4E76n, 0x69B97DB1A4C03DFEn, 0xF9B5B7C4ACC67C96n,
            0xFC6A82D64B8655FBn, 0x9C684CB6C4D24417n, 0x8EC97D2917456ED0n, 0x6703DF9D2924E97En,
            0xC547F57E42A7444En, 0x78E37644E7CAD29En, 0xFE9A44E9362F05FAn, 0x08BD35CC38336615n,
            0x9315E5EB3A129ACEn, 0x94061B871E04DF75n, 0xDF1D9F9D784BA010n, 0x3BBA57B68871B59Dn,
            0xD2B7ADEEDED1F73Fn, 0xF7A255D83BC373F8n, 0xD7F4F2448C0CEB81n, 0xD95BE88CD210FFA7n,
            0x336F52F8FF4728E7n, 0xA74049DAC312AC71n, 0xA2F61BB6E437FDB5n, 0x4F2A5CB07F6A35B3n,
            0x87D380BDA5BF7859n, 0x16B9F7E06C453A21n, 0x7BA2484C8A0FD54En, 0xF3A678CAD9A2E38Cn,
            0x39B0BF7DDE437BA2n, 0xFCAF55C1BF8A4424n, 0x18FCF680573FA594n, 0x4C0563B89F495AC3n,
            0x40E087931A00930Dn, 0x8CFFA9412EB642C1n, 0x68CA39053261169Fn, 0x7A1EE967D27579E2n,
            0x9D1D60E5076F5B6Fn, 0x3810E399B6F65BA2n, 0x32095B6D4AB5F9B1n, 0x35CAB62109DD038An,
            0xA90B24499FCFAFB1n, 0x77A225A07CC2C6BDn, 0x513E5E634C70E331n, 0x4361C0CA3F692F12n,
            0xD941ACA44B20A45Bn, 0x528F7C8602C5807Bn, 0x52AB92BEB9613989n, 0x9D1DFA2EFC557F73n,
            0x722FF175F572C348n, 0x1D1260A51107FE97n, 0x7A249A57EC0C9BA2n, 0x04208FE9E8F7F2D6n,
            0x5A110C6058B920A0n, 0x0CD9A497658A5698n, 0x56FD23C8F9715A4Cn, 0x284C847B9D887AAEn,
            0x04FEABFBBDB619CBn, 0x742E1E651C60BA83n, 0x9A9632E65904AD3Cn, 0x881B82A13B51B9E2n,
            0x506E6744CD974924n, 0xB0183DB56FFC6A79n, 0x0ED9B915C66ED37En, 0x5E11E86D5873D484n,
            0xF678647E3519AC6En, 0x1B85D488D0F20CC5n, 0xDAB9FE6525D89021n, 0x0D151D86ADB73615n,
            0xA865A54EDCC0F019n, 0x93C42566AEF98FFBn, 0x99E7AFEABE000731n, 0x48CBFF086DDF285An,
            0x7F9B6AF1EBF78BAFn, 0x58627E1A149BBA21n, 0x2CD16E2ABD791E33n, 0xD363EFF5F0977996n,
            0x0CE2A38C344A6EEDn, 0x1A804AADB9CFA741n, 0x907F30421D78C5DEn, 0x501F65EDB3034D07n,
            0x37624AE5A48FA6E9n, 0x957BAF61700CFF4En, 0x3A6C27934E31188An, 0xD49503536ABCA345n,
            0x088E049589C432E0n, 0xF943AEE7FEBF21B8n, 0x6C3B8E3E336139D3n, 0x364F6FFA464EE52En,
            0xD60F6DCEDC314222n, 0x56963B0DCA418FC0n, 0x16F50EDF91E513AFn, 0xEF1955914B609F93n,
            0x565601C0364E3228n, 0xECB53939887E8175n, 0xBAC7A9A18531294Bn, 0xB344C470397BBA52n,
            0x65D34954DAF3CEBDn, 0xB4B81B3FA97511E2n, 0xB422061193D6F6A7n, 0x071582401C38434Dn,
            0x7A13F18BBEDC4FF5n, 0xBC4097B116C524D2n, 0x59B97885E2F2EA28n, 0x99170A5DC3115544n,
            0x6F423357E7C6A9F9n, 0x325928EE6E6F8794n, 0xD0E4366228B03343n, 0x565C31F7DE89EA27n,
            0x30F5611484119414n, 0xD873DB391292ED4Fn, 0x7BD94E1D8E17DEBCn, 0xC7D9F16864A76E94n,
            0x947AE053EE56E63Cn, 0xC8C93882F9475F5Fn, 0x3A9BF55BA91F81CAn, 0xD9A11FBB3D9808E4n,
            0x0FD22063EDC29FCAn, 0xB3F256D8ACA0B0B9n, 0xB03031A8B4516E84n, 0x35DD37D5871448AFn,
            0xE9F6082B05542E4En, 0xEBFAFA33D7254B59n, 0x9255ABB50D532280n, 0xB9AB4CE57F2D34F3n,
            0x693501D628297551n, 0xC62C58F97DD949BFn, 0xCD454F8F19C5126An, 0xBBE83F4ECC2BDECBn,
            0xDC842B7E2819E230n, 0xBA89142E007503B8n, 0xA3BC941D0A5061CBn, 0xE9F6760E32CD8021n,
            0x09C7E552BC76492Fn, 0x852F54934DA55CC9n, 0x8107FCCF064FCF56n, 0x098954D51FFF6580n,
            0x23B70EDB1955C4BFn, 0xC330DE426430F69Dn, 0x4715ED43E8A45C0An, 0xA8D7E4DAB780A08Dn,
            0x0572B974F03CE0BBn, 0xB57D2E985E1419C7n, 0xE8D9ECBE2CF3D73Fn, 0x2FE4B17170E59750n,
            0x11317BA87905E790n, 0x7FBF21EC8A1F45ECn, 0x1725CABFCB045B00n, 0x964E915CD5E2B207n,
            0x3E2B8BCBF016D66Dn, 0xBE7444E39328A0ACn, 0xF85B2B4FBCDE44B7n, 0x49353FEA39BA63B1n,
            0x1DD01AAFCD53486An, 0x1FCA8A92FD719F85n, 0xFC7C95D827357AFAn, 0x18A6A990C8B35EBDn,
            0xCCCB7005C6B9C28Dn, 0x3BDBB92C43B17F26n, 0xAA70B5B4F89695A2n, 0xE94C39A54A98307Fn,
            0xB7A0B174CFF6F36En, 0xD4DBA84729AF48ADn, 0x2E18BC1AD9704A68n, 0x2DE0966DAF2F8B1Cn,
            0xB9C11D5B1E43A07En, 0x64972D68DEE33360n, 0x94628D38D0C20584n, 0xDBC0D2B6AB90A559n,
            0xD2733C4335C6A72Fn, 0x7E75D99D94A70F4Dn, 0x6CED1983376FA72Bn, 0x97FCAACBF030BC24n,
            0x7B77497B32503B12n, 0x8547EDDFB81CCB94n, 0x79999CDFF70902CBn, 0xCFFE1939438E9B24n,
            0x829626E3892D95D7n, 0x92FAE24291F2B3F1n, 0x63E22C147B9C3403n, 0xC678B6D860284A1Cn,
            0x5873888850659AE7n, 0x0981DCD296A8736Dn, 0x9F65789A6509A440n, 0x9FF38FED72E9052Fn,
            0xE479EE5B9930578Cn, 0xE7F28ECD2D49EECDn, 0x56C074A581EA17FEn, 0x5544F7D774B14AEFn,
            0x7B3F0195FC6F290Fn, 0x12153635B2C0CF57n, 0x7F5126DBBA5E0CA7n, 0x7A76956C3EAFB413n,
            0x3D5774A11D31AB39n, 0x8A1B083821F40CB4n, 0x7B4A38E32537DF62n, 0x950113646D1D6E03n,
            0x4DA8979A0041E8A9n, 0x3BC36E078F7515D7n, 0x5D0A12F27AD310D1n, 0x7F9D1A2E1EBE1327n,
            0xDA3A361B1C5157B1n, 0xDCDD7D20903D0C25n, 0x36833336D068F707n, 0xCE68341F79893389n,
            0xAB9090168DD05F34n, 0x43954B3252DC25E5n, 0xB438C2B67F98E5E9n, 0x10DCD78E3851A492n,
            0xDBC27AB5447822BFn, 0x9B3CDB65F82CA382n, 0xB67B7896167B4C84n, 0xBFCED1B0048EAC50n,
            0xA9119B60369FFEBDn, 0x1FFF7AC80904BF45n, 0xAC12FB171817EEE7n, 0xAF08DA9177DDA93Dn,
            0x1B0CAB936E65C744n, 0xB559EB1D04E5E932n, 0xC37B45B3F8D6F2BAn, 0xC3A9DC228CAAC9E9n,
            0xF3B8B6675A6507FFn, 0x9FC477DE4ED681DAn, 0x67378D8ECCEF96CBn, 0x6DD856D94D259236n,
            0xA319CE15B0B4DB31n, 0x073973751F12DD5En, 0x8A8E849EB32781A5n, 0xE1925C71285279F5n,
            0x74C04BF1790C0EFEn, 0x4DDA48153C94938An, 0x9D266D6A1CC0542Cn, 0x7440FB816508C4FEn,
            0x13328503DF48229Fn, 0xD6BF7BAEE43CAC40n, 0x4838D65F6EF6748Fn, 0x1E152328F3318DEAn,
            0x8F8419A348F296BFn, 0x72C8834A5957B511n, 0xD7A023A73260B45Cn, 0x94EBC8ABCFB56DAEn,
            0x9FC10D0F989993E0n, 0xDE68A2355B93CAE6n, 0xA44CFE79AE538BBEn, 0x9D1D84FCCE371425n,
            0x51D2B1AB2DDFB636n, 0x2FD7E4B9E72CD38Cn, 0x65CA5B96B7552210n, 0xDD69A0D8AB3B546Dn,
            0x604D51B25FBF70E2n, 0x73AA8A564FB7AC9En, 0x1A8C1E992B941148n, 0xAAC40A2703D9BEA0n,
            0x764DBEAE7FA4F3A6n, 0x1E99B96E70A9BE8Bn, 0x2C5E9DEB57EF4743n, 0x3A938FEE32D29981n,
            0x26E6DB8FFDF5ADFEn, 0x469356C504EC9F9Dn, 0xC8763C5B08D1908Cn, 0x3F6C6AF859D80055n,
            0x7F7CC39420A3A545n, 0x9BFB227EBDF4C5CEn, 0x89039D79D6FC5C5Cn, 0x8FE88B57305E2AB6n,
            0xA09E8C8C35AB96DEn, 0xFA7E393983325753n, 0xD6B6D0ECC617C699n, 0xDFEA21EA9E7557E3n,
            0xB67C1FA481680AF8n, 0xCA1E3785A9E724E5n, 0x1CFC8BED0D681639n, 0xD18D8549D140CAEAn,
            0x4ED0FE7E9DC91335n, 0xE4DBF0634473F5D2n, 0x1761F93A44D5AEFEn, 0x53898E4C3910DA55n,
            0x734DE8181F6EC39An, 0x2680B122BAA28D97n, 0x298AF231C85BAFABn, 0x7983EED3740847D5n,
            0x66C1A2A1A60CD889n, 0x9E17E49642A3E4C1n, 0xEDB454E7BADC0805n, 0x50B704CAB602C329n,
            0x4CC317FB9CDDD023n, 0x66B4835D9EAFEA22n, 0x219B97E26FFC81BDn, 0x261E4E4C0A333A9Dn,
            0x1FE2CCA76517DB90n, 0xD7504DFA8816EDBBn, 0xB9571FA04DC089C8n, 0x1DDC0325259B27DEn,
            0xCF3F4688801EB9AAn, 0xF4F5D05C10CAB243n, 0x38B6525C21A42B0En, 0x36F60E2BA4FA6800n,
            0xEB3593803173E0CEn, 0x9C4CD6257C5A3603n, 0xAF0C317D32ADAA8An, 0x258E5A80C7204C4Bn,
            0x8B889D624D44885Dn, 0xF4D14597E660F855n, 0xD4347F66EC8941C3n, 0xE699ED85B0DFB40Dn,
            0x2472F6207C2D0484n, 0xC2A1E7B5B459AEB5n, 0xAB4F6451CC1D45ECn, 0x63767572AE3D6174n,
            0xA59E0BD101731A28n, 0x116D0016CB948F09n, 0x2CF9C8CA052F6E9Fn, 0x0B090A7560A968E3n,
            0xABEEDDB2DDE06FF1n, 0x58EFC10B06A2068Dn, 0xC6E57A78FBD986E0n, 0x2EAB8CA63CE802D7n,
            0x14A195640116F336n, 0x7C0828DD624EC390n, 0xD74BBE77E6116AC7n, 0x804456AF10F5FB53n,
            0xEBE9EA2ADF4321C7n, 0x03219A39EE587A30n, 0x49787FEF17AF9924n, 0xA1E9300CD8520548n,
            0x5B45E522E4B1B4EFn, 0xB49C3B3995091A36n, 0xD4490AD526F14431n, 0x12A8F216AF9418C2n,
            0x001F837CC7350524n, 0x1877B51E57A764D5n, 0xA2853B80F17F58EEn, 0x993E1DE72D36D310n,
            0xB3598080CE64A656n, 0x252F59CF0D9F04BBn, 0xD23C8E176D113600n, 0x1BDA0492E7E4586En,
            0x21E0BD5026C619BFn, 0x3B097ADAF088F94En, 0x8D14DEDB30BE846En, 0xF95CFFA23AF5F6F4n,
            0x3871700761B3F743n, 0xCA672B91E9E4FA16n, 0x64C8E531BFF53B55n, 0x241260ED4AD1E87Dn,
            0x106C09B972D2E822n, 0x7FBA195410E5CA30n, 0x7884D9BC6CB569D8n, 0x0647DFEDCD894A29n,
            0x63573FF03E224774n, 0x4FC8E9560F91B123n, 0x1DB956E450275779n, 0xB8D91274B9E9D4FBn,
            0xA2EBEE47E2FBFCE1n, 0xD9F1F30CCD97FB09n, 0xEFED53D75FD64E6Bn, 0x2E6D02C36017F67Fn,
            0xA9AA4D20DB084E9Bn, 0xB64BE8D8B25396C1n, 0x70CB6AF7C2D5BCF0n, 0x98F076A4F7A2322En,
            0xBF84470805E69B5Fn, 0x94C3251F06F90CF3n, 0x3E003E616A6591E9n, 0xB925A6CD0421AFF3n,
            0x61BDD1307C66E300n, 0xBF8D5108E27E0D48n, 0x240AB57A8B888B20n, 0xFC87614BAF287E07n,
            0xEF02CDD06FFDB432n, 0xA1082C0466DF6C0An, 0x8215E577001332C8n, 0xD39BB9C3A48DB6CFn,
            0x2738259634305C14n, 0x61CF4F94C97DF93Dn, 0x1B6BACA2AE4E125Bn, 0x758F450C88572E0Bn,
            0x959F587D507A8359n, 0xB063E962E045F54Dn, 0x60E8ED72C0DFF5D1n, 0x7B64978555326F9Fn,
            0xFD080D236DA814BAn, 0x8C90FD9B083F4558n, 0x106F72FE81E2C590n, 0x7976033A39F7D952n,
            0xA4EC0132764CA04Bn, 0x733EA705FAE4FA77n, 0xB4D8F77BC3E56167n, 0x9E21F4F903B33FD9n,
            0x9D765E419FB69F6Dn, 0xD30C088BA61EA5EFn, 0x5D94337FBFAF7F5Bn, 0x1A4E4822EB4D7A59n,
            0x6FFE73E81B637FB3n, 0xDDF957BC36D8B9CAn, 0x64D0E29EEA8838B3n, 0x08DD9BDFD96B9F63n,
            0x087E79E5A57D1D13n, 0xE328E230E3E2B3FBn, 0x1C2559E30F0946BEn, 0x720BF5F26F4D2EAAn,
            0xB0774D261CC609DBn, 0x443F64EC5A371195n, 0x4112CF68649A260En, 0xD813F2FAB7F5C5CAn,
            0x660D3257380841EEn, 0x59AC2C7873F910A3n, 0xE846963877671A17n, 0x93B633ABFA3469F8n,
            0xC0C0F5A60EF4CDCFn, 0xCAF21ECD4377B28Cn, 0x57277707199B8175n, 0x506C11B9D90E8B1Dn,
            0xD83CC2687A19255Fn, 0x4A29C6465A314CD1n, 0xED2DF21216235097n, 0xB5635C95FF7296E2n,
            0x22AF003AB672E811n, 0x52E762596BF68235n, 0x9AEBA33AC6ECC6B0n, 0x944F6DE09134DFB6n,
            0x6C47BEC883A7DE39n, 0x6AD047C430A12104n, 0xA5B1CFDBA0AB4067n, 0x7C45D833AFF07862n,
            0x5092EF950A16DA0Bn, 0x9338E69C052B8E7Bn, 0x455A4B4CFE30E3F5n, 0x6B02E63195AD0CF8n,
            0x6B17B224BAD6BF27n, 0xD1E0CCD25BB9C169n, 0xDE0C89A556B9AE70n, 0x50065E535A213CF6n,
            0x9C1169FA2777B874n, 0x78EDEFD694AF1EEDn, 0x6DC93D9526A50E68n, 0xEE97F453F06791EDn,
            0x32AB0EDB696703D3n, 0x3A6853C7E70757A7n, 0x31865CED6120F37Dn, 0x67FEF95D92607890n,
            0x1F2B1D1F15F6DC9Cn, 0xB69E38A8965C6B65n, 0xAA9119FF184CCCF4n, 0xF43C732873F24C13n,
            0xFB4A3D794A9A80D2n, 0x3550C2321FD6109Cn, 0x371F77E76BB8417En, 0x6BFA9AAE5EC05779n,
            0xCD04F3FF001A4778n, 0xE3273522064480CAn, 0x9F91508BFFCFC14An, 0x049A7F41061A9E60n,
            0xFCB6BE43A9F2FE9Bn, 0x08DE8A1C7797DA9Bn, 0x8F9887E6078735A1n, 0xB5B4071DBFC73A66n,
            0x230E343DFBA08D33n, 0x43ED7F5A0FAE657Dn, 0x3A88A0FBBCB05C63n, 0x21874B8B4D2DBC4Fn,
            0x1BDEA12E35F6A8C9n, 0x53C065C6C8E63528n, 0xE34A1D250E7A8D6Bn, 0xD6B04D3B7651DD7En,
            0x5E90277E7CB39E2Dn, 0x2C046F22062DC67Dn, 0xB10BB459132D0A26n, 0x3FA9DDFB67E2F199n,
            0x0E09B88E1914F7AFn, 0x10E8B35AF3EEAB37n, 0x9EEDECA8E272B933n, 0xD4C718BC4AE8AE5Fn,
            0x81536D601170FC20n, 0x91B534F885818A06n, 0xEC8177F83F900978n, 0x190E714FADA5156En,
            0xB592BF39B0364963n, 0x89C350C893AE7DC1n, 0xAC042E70F8B383F2n, 0xB49B52E587A1EE60n,
            0xFB152FE3FF26DA89n, 0x3E666E6F69AE2C15n, 0x3B544EBE544C19F9n, 0xE805A1E290CF2456n,
            0x24B33C9D7ED25117n, 0xE74733427B72F0C1n, 0x0A804D18B7097475n, 0x57E3306D881EDB4Fn,
            0x4AE7D6A36EB5DBCBn, 0x2D8D5432157064C8n, 0xD1E649DE1E7F268Bn, 0x8A328A1CEDFE552Cn,
            0x07A3AEC79624C7DAn, 0x84547DDC3E203C94n, 0x990A98FD5071D263n, 0x1A4FF12616EEFC89n,
            0xF6F7FD1431714200n, 0x30C05B1BA332F41Cn, 0x8D2636B81555A786n, 0x46C9FEB55D120902n,
            0xCCEC0A73B49C9921n, 0x4E9D2827355FC492n, 0x19EBB029435DCB0Fn, 0x4659D2B743848A2Cn,
            0x963EF2C96B33BE31n, 0x74F85198B05A2E7Dn, 0x5A0F544DD2B1FB18n, 0x03727073C2E134B1n,
            0xC7F6AA2DE59AEA61n, 0x352787BAA0D7C22Fn, 0x9853EAB63B5E0B35n, 0xABBDCDD7ED5C0860n,
            0xCF05DAF5AC8D77B0n, 0x49CAD48CEBF4A71En, 0x7A4C10EC2158C4A6n, 0xD9E92AA246BF719En,
            0x13AE978D09FE5557n, 0x730499AF921549FFn, 0x4E4B705B92903BA4n, 0xFF577222C14F0A3An,
            0x55B6344CF97AAFAEn, 0xB862225B055B6960n, 0xCAC09AFBDDD2CDB4n, 0xDAF8E9829FE96B5Fn,
            0xB5FDFC5D3132C498n, 0x310CB380DB6F7503n, 0xE87FBB46217A360En, 0x2102AE466EBB1148n,
            0xF8549E1A3AA5E00Dn, 0x07A69AFDCC42261An, 0xC4C118BFE78FEAAEn, 0xF9F4892ED96BD438n,
            0x1AF3DBE25D8F45DAn, 0xF5B4B0B0D2DEEEB4n, 0x962ACEEFA82E1C84n, 0x046E3ECAAF453CE9n,
            0xF05D129681949A4Cn, 0x964781CE734B3C84n, 0x9C2ED44081CE5FBDn, 0x522E23F3925E319En,
            0x177E00F9FC32F791n, 0x2BC60A63A6F3B3F2n, 0x222BBFAE61725606n, 0x486289DDCC3D6780n,
            0x7DC7785B8EFDFC80n, 0x8AF38731C02BA980n, 0x1FAB64EA29A2DDF7n, 0xE4D9429322CD065An,
            0x9DA058C67844F20Cn, 0x24C0E332B70019B0n, 0x233003B5A6CFE6ADn, 0xD586BD01C5C217F6n,
            0x5E5637885F29BC2Bn, 0x7EBA726D8C94094Bn, 0x0A56A5F0BFE39272n, 0xD79476A84EE20D06n,
            0x9E4C1269BAA4BF37n, 0x17EFEE45B0DEE640n, 0x1D95B0A5FCF90BC6n, 0x93CBE0B699C2585Dn,
            0x65FA4F227A2B6D79n, 0xD5F9E858292504D5n, 0xC2B5A03F71471A6Fn, 0x59300222B4561E00n,
            0xCE2F8642CA0712DCn, 0x7CA9723FBB2E8988n, 0x2785338347F2BA08n, 0xC61BB3A141E50E8Cn,
            0x150F361DAB9DEC26n, 0x9F6A419D382595F4n, 0x64A53DC924FE7AC9n, 0x142DE49FFF7A7C3Dn,
            0x0C335248857FA9E7n, 0x0A9C32D5EAE45305n, 0xE6C42178C4BBB92En, 0x71F1CE2490D20B07n,
            0xF1BCC3D275AFE51An, 0xE728E8C83C334074n, 0x96FBF83A12884624n, 0x81A1549FD6573DA5n,
            0x5FA7867CAF35E149n, 0x56986E2EF3ED091Bn, 0x917F1DD5F8886C61n, 0xD20D8C88C8FFE65Fn,
            0x31D71DCE64B2C310n, 0xF165B587DF898190n, 0xA57E6339DD2CF3A0n, 0x1EF6E6DBB1961EC9n,
            0x70CC73D90BC26E24n, 0xE21A6B35DF0C3AD7n, 0x003A93D8B2806962n, 0x1C99DED33CB890A1n,
            0xCF3145DE0ADD4289n, 0xD0E4427A5514FB72n, 0x77C621CC9FB3A483n, 0x67A34DAC4356550Bn,
            0xF8D626AAAF278509n
        ];

        console.log(computePolyglotHash(game).toString(16));

        async function loadOpeningBook(url) {
            console.log("Attempting to load opening book:", url);
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} for ${url}`);
                }
                const buffer = await response.arrayBuffer();
                const dataView = new DataView(buffer);
                if (buffer.byteLength % 16 !== 0) {
                    console.warn("Opening book file size is not a multiple of 16 bytes.");
                }
                const entryCount = Math.floor(dataView.byteLength / 16);
                const book = new Map(); // Use a standard Map

                console.log(`Loading ${entryCount} entries from book...`);

                for (let i = 0; i < entryCount; i++) {
                    const entryOffset = i * 16;
                    // Read the key (64 bits, big-endian) as BigInt
                    const key = dataView.getBigUint64(entryOffset, false); // false for big-endian
                    // Read the move (16 bits, big-endian)
                    const move = dataView.getUint16(entryOffset + 8, false);
                    // Read the weight (16 bits, big-endian)
                    const weight = dataView.getUint16(entryOffset + 10, false);
                    // Read learn (32 bits, big-endian) - unused here
                    // const learn = dataView.getUint32(entryOffset + 12, false);

                    if (!book.has(key)) {
                        book.set(key, []);
                    }
                    book.get(key).push({ move, weight });

                    // Optional: Log the first few entries for verification
                    // if (i < 5) {
                    //    console.log(`Entry ${i}: Key=${key.toString(16)}, Move=${move.toString(16)}, Weight=${weight}`);
                    //}
                }
                console.log("Opening book loaded successfully.");
                openingBook.entries = book; // Store in the class instance
                openingBook.loaded = true;  // Mark as loaded
                return book; // Return the map (although it's stored in the global now)

            } catch (error) {
                console.error("Failed to load opening book:", error);
                openingBook.loaded = false;
                return new Map(); // Return empty map on error
            }
        }

        // Calcular hash Zobrist para uma posição do tabuleiro
        function computeHash(board) {
            console.log("computeHash");
            if (!this.initialized) this.initialize();
            
            let hash = 0n; // BigInt para hash de 64 bits
            
            // Peças no tabuleiro
            const boardState = board.board(); // Usa o método .board() corretamente
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = boardState[row][col];
                    if (piece) {
                        const pieceIdx = this.pieceValues[piece.color + piece.type];
                        const squareIdx = row * 8 + col;
                        hash ^= this.randomTable[pieceIdx * 64 + squareIdx];
                    }
                }
            }

            console.log(hash);
            
            // Lado da jogada (brancas ou pretas)
            if (board.turn() === 'b') {
                hash ^= this.randomTable[12 * 64]; // Use índice após todos os valores das peças
            }
            
            // Direitos de roque (ajustado para funcionar com chess.js)
            const castling = { k: false, q: false, K: false, Q: false };
            
            // Verificamos a string de estado FEN para extrair direitos de roque
            const fen = board.fen();
            const fenParts = fen.split(' ');
            if (fenParts.length >= 3) {
                const castlingRights = fenParts[2];
                
                if (castlingRights !== '-') {
                    if (castlingRights.includes('K')) castling.K = true;
                    if (castlingRights.includes('Q')) castling.Q = true;
                    if (castlingRights.includes('k')) castling.k = true;
                    if (castlingRights.includes('q')) castling.q = true;
                }
            }
            
            // Aplica XOR para cada direito de roque
            if (castling.K) hash ^= this.randomTable[12 * 64 + 1]; // Roque curto brancas
            if (castling.Q) hash ^= this.randomTable[12 * 64 + 2]; // Roque longo brancas
            if (castling.k) hash ^= this.randomTable[12 * 64 + 3]; // Roque curto pretas
            if (castling.q) hash ^= this.randomTable[12 * 64 + 4]; // Roque longo pretas
            
            console.log(hash.toString());
            return hash.toString(); // Converte para string para uso como chave no Map
        }

        function computePolyglotHash(game) {
            console.log("computePolyglotHash");
            let hash = 0n;
            // 1. Piece Placement (Indices 0-767)
            // Iterate ranks 1-8, files a-h to match Polyglot square indexing (a1=0, h8=63)
            for (let rank = 1; rank <= 8; rank++) {
                for (let fileIndex = 0; fileIndex < 8; fileIndex++) {
                    const file = 'abcdefgh'[fileIndex];
                    const algebraicSquare = file + rank; // e.g., "a1", "h8"
                    const piece = game.get(algebraicSquare); // Get piece from chess.js

                    if (piece) {
                        const polyglotPiece = getPolyglotPieceIndex(piece);
                        // Calculate Polyglot square index: (rank - 1) * 8 + fileIndex
                        const polyglotSquareIndex = (rank - 1) * 8 + fileIndex; // This is the crucial part

                        // Calculate Zobrist table index for this piece/square combo
                        // Index = piece_index * 64 + square_index
                        const zobristIndex = polyglotPiece * 64 + polyglotSquareIndex;

                        if (zobristIndex < 0 || zobristIndex >= 768) {
                             console.error(`Invalid piece/square zobristIndex: ${zobristIndex} for ${algebraicSquare} (${polyglotSquareIndex}), piece ${polyglotPiece}`);
                             continue; // Should not happen with valid input
                        }
                         // XOR with the corresponding random number
                        hash ^= ZOBRIST_TABLE[zobristIndex];
                        //console.log(`Square: ${algebraicSquare}, Piece: ${piece.color}${piece.type}, PolyPiece: ${polyglotPiece}, PolySqIdx: ${polyglotSquareIndex}, ZobristIdx: ${zobristIndex}, Hash: ${hash.toString(16)}`);
                    }
                }
            }


            // 2. Castling Rights (Indices 768-771)
            const fenParts = game.fen().split(' ');
            const castlingRights = fenParts[2];
            if (castlingRights !== '-') {
                if (castlingRights.includes('K')) hash ^= ZOBRIST_TABLE[768]; // White King side
                if (castlingRights.includes('Q')) hash ^= ZOBRIST_TABLE[769]; // White Queen side
                if (castlingRights.includes('k')) hash ^= ZOBRIST_TABLE[770]; // Black King side
                if (castlingRights.includes('q')) hash ^= ZOBRIST_TABLE[771]; // Black Queen side
            }
            //console.log(`After castling (${castlingRights}): ${hash.toString(16)}`);

            // 3. En Passant Target Square (Indices 772-779)
            const enPassantTarget = fenParts[3];
            if (enPassantTarget !== '-') {
                // Polyglot only cares about the *file* of the target square
                const file = enPassantTarget.charCodeAt(0) - 'a'.charCodeAt(0); // 0 for 'a', 7 for 'h'
                if (file >= 0 && file < 8) {
                    hash ^= ZOBRIST_TABLE[772 + file];
                    //console.log(`After En Passant (${enPassantTarget}, file ${file}): ${hash.toString(16)}`);
                } else {
                    console.error(`Invalid en passant file index: ${file} from ${enPassantTarget}`);
                }
            } else {
                //console.log(`After En Passant (none): ${hash.toString(16)}`);
            }

            // 4. Side to Move (Index 780)
            // XOR only if it's Black's turn
            if (game.turn() === 'b') {
                hash ^= ZOBRIST_TABLE[780];
                //console.log(`After Side to Move (Black): ${hash.toString(16)}`);
            } else {
                //console.log(`After Side to Move (White): ${hash.toString(16)}`);
            }

            console.log("Final Polyglot Hash:", hash.toString(16).toUpperCase());
            // IMPORTANT: Return the BigInt directly, not the string,
            // to match the keys stored from the binary file.

            return hash;
        }

        function getPolyglotPieceIndex(piece) {
            const offset = piece.color === 'w' ? 0 : 6;
            switch (piece.type) {
                case 'p': return offset + 0;
                case 'n': return offset + 1;
                case 'b': return offset + 2;
                case 'r': return offset + 3;
                case 'q': return offset + 4;
                case 'k': return offset + 5;
                default:  throw new Error(`Invalid piece type: ${piece.type}`);
            }
        }

        function squareIndexToUCI(squareIndex) {
             // Converts Polyglot index (0-63, a1=0) to UCI string (e.g., "a1")
             if (squareIndex < 0 || squareIndex > 63) return "??";
             const file = 'abcdefgh'[squareIndex % 8];
             const rank = Math.floor(squareIndex / 8) + 1;
             return file + rank;
         }

        function decodePolyglotMove(move16) {
            //console.log("decodePolyglotMove", move16);
            // Polyglot move format:
            // 0-5: from square (0-63, a1=0)
            // 6-11: to square (0-63, a1=0)
            // 12-14: promotion piece type (0=N, 1=B, 2=R, 3=Q) -> Actually N=1, B=2, R=3, Q=4 ! Error in some docs. Standard is N=1...
            // Let's use the standard convention: 1=N, 2=B, 3=R, 4=Q (0 means no promotion)

            const fromSquareIndex = move16 & 0x3F;       // 0b0000000000111111
            const toSquareIndex = (move16 >> 6) & 0x3F; // 0b0000111111000000 >> 6
            const promotionType = (move16 >> 12) & 0x7; // 0b0111000000000000 >> 12 (Reads 3 bits) - Standard is 4 types (N,B,R,Q)

            const fromUCI = squareIndexToUCI(fromSquareIndex);
            const toUCI = squareIndexToUCI(toSquareIndex);
            //console.log(`fromIdx=${fromSquareIndex}=${fromUCI}, toIdx=${toSquareIndex}=${toUCI}, promoType=${promotionType}`);

            let promotion = '';
            if (promotionType !== 0) {
                 // Standard Polyglot: 1=N, 2=B, 3=R, 4=Q
                 // Need to map to 'n', 'b', 'r', 'q' for chess.js
                 switch (promotionType) {
                    case 1: promotion = 'n'; break;
                    case 2: promotion = 'b'; break;
                    case 3: promotion = 'r'; break;
                    case 4: promotion = 'q'; break;
                    default: console.warn("Unexpected promotion type in Polyglot move:", promotionType); break;
                 }
             }
            return fromUCI + toUCI + promotion;
        }

        function weightedChoice(entries) {
            //console.log("weightedChoice", entries);
             if (!entries || entries.length === 0) return null; // Handle empty case

            const totalWeight = entries.reduce((acc, entry) => acc + (entry.weight || 0), 0);
            if (totalWeight <= 0) {
                // If weights are zero or invalid, pick randomly without weights
                 return entries[Math.floor(Math.random() * entries.length)].move;
             }

             let random = Math.random() * totalWeight;
             for (const entry of entries) {
                const weight = entry.weight || 0;
                 if (random < weight) {
                     return entry.move; // Return the move data (16-bit number)
                 }
                 random -= weight;
            }
             // Fallback (shouldn't usually happen with correct random/totalWeight)
            return entries[entries.length - 1].move;
        }

        function squareToUCI(square) {
            const file = 'abcdefgh'[square % 8];
            const rank = 8 - Math.floor(square / 8);
            console.log(square, file, rank);
            return file + rank;
        }

        // Função de debug centralizada
        function debug(...args) {
            if (DEBUG_MODE) {
                console.log(...args);
            }
        }

        // Função para tocar o som do movimento
        function playMoveSound() {
            moveSound.currentTime = 0; // Reseta o áudio para o início
            moveSound.play().catch(error => {
                debug("Erro ao tocar som:", error);
            });
        }

        // Função auxiliar para determinar a fase do jogo (simplificado)
        function determineIsEndGame(currentBoard) {
            let whiteMaterial = 0;
            let blackMaterial = 0;
            let queens = 0;

            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const piece = currentBoard[i][j];
                    if (piece && piece.type !== 'k' && piece.type !== 'p') {
                        const value = getPieceValue(piece); // Usa a função existente
                        if (piece.color === 'w') {
                            whiteMaterial += value;
                        } else {
                            blackMaterial += value;
                        }
                        if (piece.type === 'q') {
                            queens++;
                        }
                    }
                }
            }
            // Critério: Sem damas OU material total (sem peões/reis) abaixo de um limiar
            const lowMaterialThreshold = KNIGHT_VALUE + BISHOP_VALUE + ROOK_VALUE; // Exemplo de limiar
            return queens === 0 || (whiteMaterial < lowMaterialThreshold && blackMaterial < lowMaterialThreshold);
        }
            
        // --- NOVA FUNÇÃO evaluateBoard ---
        function evaluateBoard(currentBoard, turn) {
            let totalEvaluation = 0;
            
            // Verificação de empate por repetição (adicionar no início da função)
            if (game.in_threefold_repetition()) {
                // Se for a vez das pretas (IA), penalizar fortemente o empate
                // pois queremos que a IA evite repetições
                return turn === 'b' ? -5000 : 5000;
            }
            
            // Verificação de outros tipos de empate
            if (game.in_draw() || game.in_stalemate() || game.insufficient_material()) {
                // Penalizar empates em geral, mas menos que o mate
                return turn === 'b' ? -3000 : 3000;
            }

            let materialScore = 0;
            let positionalScore = 0;
            let structureAndSafetyScore = 0;
            let tacticalBonus = 0; // Bônus para xeque, mate, ataques
            let whiteKingSquare = null;
            let blackKingSquare = null;
            let whiteMinorPiecesDeveloped = 0;
            let blackMinorPiecesDeveloped = 0;
            let whitePawns = []; // Armazena { square: 'e2', col: 4, row: 6 }
            let blackPawns = [];

            const isEndGame = determineIsEndGame(currentBoard);

            // --- FASE 1: Calcular Material e Posição Base (Tabelas) ---
            for (let i = 0; i < 8; i++) { // Linhas (0-7) -> Fileiras (8-1)
                for (let j = 0; j < 8; j++) { // Colunas (0-7) -> Colunas (a-h)
                    const piece = currentBoard[i][j];
                    const square = String.fromCharCode('a'.charCodeAt(0) + j) + (8 - i);

                    if (piece) {
                        // 1.1 Calcular Score Material
                        const pieceValue = getPieceValue(piece);
                        materialScore += (piece.color === 'w' ? pieceValue : -pieceValue);

                        // 1.2 Calcular Score Posicional (usando tabelas)
                        let table = null;
                        switch (piece.type) {
                            case 'p':
                                table = pawnTable;
                                if (piece.color === 'w') whitePawns.push({ square: square, col: j, row: i });
                                else blackPawns.push({ square: square, col: j, row: i });
                                break;
                            case 'n':
                                table = knightTable;
                                // Conta desenvolvimento se não estiver na casa inicial
                                if (piece.color === 'w' && !(i === 7 && (j === 1 || j === 6))) whiteMinorPiecesDeveloped += 10;
                                if (piece.color === 'b' && !(i === 0 && (j === 1 || j === 6))) blackMinorPiecesDeveloped += 10;
                                break;
                            case 'b':
                                table = bishopTable;
                                // Conta desenvolvimento se não estiver na casa inicial
                                if (piece.color === 'w' && !(i === 7 && (j === 2 || j === 5))) whiteMinorPiecesDeveloped += 10;
                                if (piece.color === 'b' && !(i === 0 && (j === 2 || j === 5))) blackMinorPiecesDeveloped += 10;
                                break;
                            case 'r': table = rookTable; break;
                            case 'q': table = queenTable; break;
                            case 'k':
                                table = isEndGame ? kingTableEndGame : kingTable;
                                if (piece.color === 'w') whiteKingSquare = { square: square, row: i, col: j };
                                else blackKingSquare = { square: square, row: i, col: j };
                                break;
                        }

                        if (table) {
                            const tableRow = piece.color === 'w' ? i : 7 - i; // Ajusta linha para tabela (espelha para pretas)
                            const tableCol = j;
                            const tableValue = table[tableRow][tableCol];
                            positionalScore += (piece.color === 'w' ? tableValue : -tableValue);
                        }
                    }
                }
            }

            // --- FASE 2: Calcular Bônus/Penalidades Estruturais e de Segurança ---

            // 2.1 Estrutura de Peões
            let whitePawnStructureScore = 0;
            let blackPawnStructureScore = 0;
            const whitePawnCols = whitePawns.map(p => p.col);
            const blackPawnCols = blackPawns.map(p => p.col);

            // Penalidades/Bônus para Brancas
            whitePawns.forEach(pawn => {
                const col = pawn.col;
                const rank = 8 - pawn.row; // Rank (1-8)
                if (whitePawnCols.filter(c => c === col).length > 1) whitePawnStructureScore += DOUBLED_PAWN_PENALTY;
                if (!whitePawnCols.includes(col - 1) && !whitePawnCols.includes(col + 1)) whitePawnStructureScore += ISOLATED_PAWN_PENALTY;
                // Passados: Checar se não há peões pretos na frente ou adjacentes
                let isPassed = true;
                for (let bpCol = col - 1; bpCol <= col + 1; bpCol++) {
                    if (bpCol >= 0 && bpCol <= 7) {
                        blackPawns.forEach(blackPawn => {
                            if (blackPawn.col === bpCol && blackPawn.row < pawn.row) { // Peão preto está à frente
                                isPassed = false;
                            }
                        });
                    }
                    if (!isPassed) break;
                }
                if (isPassed) whitePawnStructureScore += PASSED_PAWN_BONUS_BASE + (rank - 2) * 5;
                // Bônus centro peão (pode ser redundante se já estiver na tabela, mas explícito aqui)
                if (pawn.square === 'd4' || pawn.square === 'e4') whitePawnStructureScore += CENTER_PAWN_BONUS;
            });

            // Penalidades/Bônus para Pretas
            blackPawns.forEach(pawn => {
                const col = pawn.col;
                const rank = 8 - pawn.row; // Rank (1-8)
                if (blackPawnCols.filter(c => c === col).length > 1) blackPawnStructureScore += DOUBLED_PAWN_PENALTY;
                if (!blackPawnCols.includes(col - 1) && !blackPawnCols.includes(col + 1)) blackPawnStructureScore += ISOLATED_PAWN_PENALTY;
                // Passados: Checar se não há peões brancos na frente ou adjacentes
                let isPassed = true;
                for (let wpCol = col - 1; wpCol <= col + 1; wpCol++) {
                    if (wpCol >= 0 && wpCol <= 7) {
                        whitePawns.forEach(whitePawn => {
                            if (whitePawn.col === wpCol && whitePawn.row > pawn.row) { // Peão branco está à frente
                                isPassed = false;
                            }
                        });
                    }
                     if (!isPassed) break;
                }
                if (isPassed) blackPawnStructureScore += PASSED_PAWN_BONUS_BASE + (7 - rank) * 5; // Bonus aumenta com avanço (para pretas)
                // Bônus centro peão
                if (pawn.square === 'd5' || pawn.square === 'e5') blackPawnStructureScore += CENTER_PAWN_BONUS;
            });

            structureAndSafetyScore += whitePawnStructureScore; // Adiciona score branco
            structureAndSafetyScore -= blackPawnStructureScore; // Subtrai score preto

            // 2.2 Segurança do Rei e Roque
            let whiteKingSafetyScore = 0;
            let blackKingSafetyScore = 0;
            // Verifica roque branco (simplificado)
            let whiteCastled = false;
            if (whiteKingSquare) {
                if (whiteKingSquare.square === 'g1' && currentBoard[7][5]?.type === 'r' && currentBoard[7][5]?.color === 'w') { // Roque curto O-O
                    whiteCastled = true;
                    if (currentBoard[6][5]?.type === 'p' && currentBoard[6][5]?.color === 'w') whiteKingSafetyScore += PAWN_SHIELD_BONUS; // f2
                    if (currentBoard[6][6]?.type === 'p' && currentBoard[6][6]?.color === 'w') whiteKingSafetyScore += PAWN_SHIELD_BONUS; // g2
                    if (currentBoard[6][7]?.type === 'p' && currentBoard[6][7]?.color === 'w') whiteKingSafetyScore += PAWN_SHIELD_BONUS; // h2
                } else if (whiteKingSquare.square === 'c1' && currentBoard[7][3]?.type === 'r' && currentBoard[7][3]?.color === 'w') { // Roque longo O-O-O
                    whiteCastled = true;
                    if (currentBoard[6][0]?.type === 'p' && currentBoard[6][0]?.color === 'w') whiteKingSafetyScore += PAWN_SHIELD_BONUS; // a2
                    if (currentBoard[6][1]?.type === 'p' && currentBoard[6][1]?.color === 'w') whiteKingSafetyScore += PAWN_SHIELD_BONUS; // b2
                    if (currentBoard[6][2]?.type === 'p' && currentBoard[6][2]?.color === 'w') whiteKingSafetyScore += PAWN_SHIELD_BONUS; // c2
                }
                if (whiteCastled) whiteKingSafetyScore += CASTLING_BONUS;
                // else if (!isEndGame && (whiteKingSquare.col > 2 && whiteKingSquare.col < 5)) { // Penalidade se rei estiver no centro no meio-jogo sem rocar?
                //     whiteKingSafetyScore += KING_EXPOSED_PENALTY;
                // }
            }
             // Verifica roque preto (simplificado)
            let blackCastled = false;
             if (blackKingSquare) {
                if (blackKingSquare.square === 'g8' && currentBoard[0][5]?.type === 'r' && currentBoard[0][5]?.color === 'b') { // Roque curto O-O
                    blackCastled = true;
                    if (currentBoard[1][5]?.type === 'p' && currentBoard[1][5]?.color === 'b') blackKingSafetyScore += PAWN_SHIELD_BONUS; // f7
                    if (currentBoard[1][6]?.type === 'p' && currentBoard[1][6]?.color === 'b') blackKingSafetyScore += PAWN_SHIELD_BONUS; // g7
                    if (currentBoard[1][7]?.type === 'p' && currentBoard[1][7]?.color === 'b') blackKingSafetyScore += PAWN_SHIELD_BONUS; // h7
                } else if (blackKingSquare.square === 'c8' && currentBoard[0][3]?.type === 'r' && currentBoard[0][3]?.color === 'b') { // Roque longo O-O-O
                    blackCastled = true;
                    if (currentBoard[1][0]?.type === 'p' && currentBoard[1][0]?.color === 'b') blackKingSafetyScore += PAWN_SHIELD_BONUS; // a7
                    if (currentBoard[1][1]?.type === 'p' && currentBoard[1][1]?.color === 'b') blackKingSafetyScore += PAWN_SHIELD_BONUS; // b7
                    if (currentBoard[1][2]?.type === 'p' && currentBoard[1][2]?.color === 'b') blackKingSafetyScore += PAWN_SHIELD_BONUS; // c7
                }
                if (blackCastled) blackKingSafetyScore += CASTLING_BONUS;
                // else if (!isEndGame && (blackKingSquare.col > 2 && blackKingSquare.col < 5)) {
                //     blackKingSafetyScore += KING_EXPOSED_PENALTY;
                // }
            }
            structureAndSafetyScore += whiteKingSafetyScore;
            structureAndSafetyScore -= blackKingSafetyScore;

            // 2.3 Desenvolvimento de Peças Menores
            structureAndSafetyScore += whiteMinorPiecesDeveloped * DEVELOPMENT_BONUS;
            structureAndSafetyScore -= blackMinorPiecesDeveloped * DEVELOPMENT_BONUS;

            // --- FASE 3: Bônus Táticos (Xeque, Mate, Ataque) ---
            // Usamos a instância global 'game' para verificar estados como xeque/mate
            // A avaliação é da *posição atual*. game.turn() indica quem jogaria *depois*.
            const turnAfterPosition = game.turn();

            if (game.in_checkmate()) {
                // Se é a vez das Brancas jogarem e estão em mate, Pretas venceram (ruim para Brancas -> grande negativo)
                // Se é a vez das Pretas jogarem e estão em mate, Brancas venceram (bom para Brancas -> grande positivo)
                tacticalBonus += (turnAfterPosition === 'w' ? -KING_VALUE * 2 : KING_VALUE * 2);
            } else if (game.in_stalemate() || game.in_draw() || game.insufficient_material() || game.in_threefold_repetition()) {
                // Empates devem ter score próximo de 0, ajustando a partir do material/posição
                // Se um lado tem vantagem material mas força empate, isso é ruim para ele.
                // Vamos retornar 0 diretamente para simplificar, assumindo que empate é neutro.
                // return 0; // Ou ajustar baseado na avaliação atual? Por ora, deixamos somar.
            } else if (game.in_check()) {
                // Se é a vez das Brancas jogarem e estão em xeque, é ruim para Brancas (negativo).
                // Se é a vez das Pretas jogarem e estão em xeque, é bom para Brancas (positivo).
                tacticalBonus += (turnAfterPosition === 'w' ? -50 : 50);
            }

            // 3.2 Bônus de Ataque ao Rei (Proximidade - lógica anterior mantida)
            const enemyColor = turn === 'w' ? 'b' : 'w';
            const enemyKingSquare = enemyColor === 'w' ? whiteKingSquare : blackKingSquare;
            let attackBonus = 0;
            if (enemyKingSquare && !isEndGame) { // Bônus de ataque mais relevante no meio-jogo
                const kingRow = enemyKingSquare.row;
                const kingCol = enemyKingSquare.col;
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const piece = currentBoard[i][j];
                        // Se a peça é da cor que está avaliando (cor de 'turn')
                        if (piece && piece.color === turn) {
                            const distance = Math.abs(i - kingRow) + Math.abs(j - kingCol);
                            // Bônus maior para peças mais próximas (inversamente proporcional à distância)
                            // Ajuste o multiplicador conforme necessário
                            attackBonus += Math.max(0, (14 - distance)) * 2; // Ex: 14 - dist, max 0, mult 2
                        }
                    }
                }
            }
            // O bônus de ataque é bom para quem está atacando (turn)
            tacticalBonus += (turn === 'w' ? attackBonus : -attackBonus);


            // --- FASE 4: Retornar Avaliação Final ---
            // Soma todas as componentes. A avaliação é sempre do ponto de vista das Brancas.
            totalEvaluation = materialScore + positionalScore + structureAndSafetyScore + tacticalBonus;

            debug(`Eval (White's Pov): Material=${materialScore}, Positional=${positionalScore}, Struct/Safe=${structureAndSafetyScore}, Tactical=${tacticalBonus} => Total=${totalEvaluation}`);

            // A função minimax lida com maximizar/minimizar, então retornamos sempre a perspectiva das Brancas.
            return totalEvaluation;
        }

        function getPieceValue(piece) {
            if (piece === null) return 0;
            switch (piece.type) {
                case 'p': return PAWN_VALUE;
                case 'n': return KNIGHT_VALUE;
                case 'b': return BISHOP_VALUE;
                case 'r': return ROOK_VALUE;
                case 'q': return QUEEN_VALUE;
                case 'k': return KING_VALUE;
                default: return 0;
            }
        }

        // Função auxiliar para encontrar a posição do rei
        function findKing(color) {
            var boardState = game.board();
            for (var i = 0; i < 8; i++) {
                for (var j = 0; j < 8; j++) {
                    var piece = boardState[i][j];
                    if (piece && piece.type === 'k' && piece.color === color) {
                        // Converte coordenadas (linha, coluna) para notação de casa (ex: e4)
                        return String.fromCharCode('a'.charCodeAt(0) + j) + (8 - i);
                    }
                }
            }
            return null; // Não deveria acontecer em um jogo normal
        }

        // Implementar uma função de busca seletiva que avalia apenas os movimentos mais promissores
        function minimaxRoot(depth, isMaximizingPlayer) {
            const moves = game.moves({ verbose: true });
            
            // Número de melhores movimentos para explorar em cada nível
            const BEAM_WIDTH = 10;
            
            // Fase 1: Avaliar todos os movimentos possíveis na primeira camada
            const evaluatedMoves = [];
            
            for (const move of moves) {
                game.move(move.san);
                // Avaliação superficial (profundidade 1)
                const score = evaluateBoard(game.board(), game.turn());
                game.undo();
                
                evaluatedMoves.push({
                    move: move,
                    score: score
                });
            }
            
            // Ordenar os movimentos
            // Para o jogador maximizador (brancas), ordenamos do maior para o menor
            // Para o jogador minimizador (pretas), ordenamos do menor para o maior
            evaluatedMoves.sort((a, b) => {
                return isMaximizingPlayer ? b.score - a.score : a.score - b.score;
            });
            
            // Selecionar apenas os N melhores movimentos
            const bestMoves = evaluatedMoves.slice(0, Math.min(BEAM_WIDTH, evaluatedMoves.length));
            
            // Fase 2: Explorar com profundidade total apenas os melhores movimentos
            let bestMoveFound = null;
            let bestScore = isMaximizingPlayer ? -Infinity : Infinity;
            
            for (const moveObj of bestMoves) {
                game.move(moveObj.move.san);
                // Agora explorar com profundidade total usando seletividade em cada nível
                const value = selectiveSearch(depth - 1, -Infinity, Infinity, !isMaximizingPlayer, BEAM_WIDTH);
                game.undo();
                
                // Atualizar o melhor movimento
                if (isMaximizingPlayer) {
                    if (value > bestScore) {
                        bestScore = value;
                        bestMoveFound = moveObj.move;
                    }
                } else {
                    if (value < bestScore) {
                        bestScore = value;
                        bestMoveFound = moveObj.move;
                    }
                }
            }
            
            // Se por algum motivo não encontrarmos o melhor movimento
            if (bestMoveFound === null && moves.length > 0) {
                return moves[0];
            }
            
            return bestMoveFound;
        }

        // Modificar a função selectiveSearch para considerar capturas como movimentos prioritários
        function selectiveSearch(depth, alpha, beta, isMaximizingPlayer, beamWidth) {
            // Caso base: fim da recursão
            if (depth === 0 || game.game_over()) {
                return evaluateBoard(game.board(), game.turn());
            }
            
            const moves = game.moves({ verbose: true });
            
            // Se estivermos no último nível ou houver poucos movimentos, avaliar todos
            if (depth === 1 || moves.length <= beamWidth) {
                return minimax(depth, alpha, beta, isMaximizingPlayer);
            }
            
            // Separar movimentos de captura e não-captura
            const captureMoves = [];
            const nonCaptureMoves = [];
            
            for (const move of moves) {
                if (move.flags.includes('c')) {
                    captureMoves.push(move);
                } else {
                    nonCaptureMoves.push(move);
                }
            }
            
            // Avaliar superficialmente todos os movimentos neste nível
            const evaluatedCaptures = [];
            const evaluatedNonCaptures = [];
            
            // Avaliar capturas
            for (const move of captureMoves) {
                game.move(move);
                // Avaliação superficial
                const score = evaluateBoard(game.board(), game.turn());
                game.undo();
                
                evaluatedCaptures.push({
                    move: move,
                    score: score
                });
            }
            
            // Avaliar não-capturas
            for (const move of nonCaptureMoves) {
                game.move(move);
                // Avaliação superficial
                const score = evaluateBoard(game.board(), game.turn());
                game.undo();
                
                evaluatedNonCaptures.push({
                    move: move,
                    score: score
                });
            }
            
            // Ordenar os movimentos
            evaluatedCaptures.sort((a, b) => {
                return isMaximizingPlayer ? b.score - a.score : a.score - b.score;
            });
            
            evaluatedNonCaptures.sort((a, b) => {
                return isMaximizingPlayer ? b.score - a.score : a.score - b.score;
            });
            
            // Selecionar os melhores movimentos, priorizando capturas
            let bestMoves = [];
            
            // Adicionar todas as capturas (ou até o limite de beam width)
            bestMoves = bestMoves.concat(evaluatedCaptures.slice(0, beamWidth));
            
            // Adicionar os melhores movimentos não-captura até completar o beam width
            if (bestMoves.length < beamWidth) {
                bestMoves = bestMoves.concat(
                    evaluatedNonCaptures.slice(0, beamWidth - bestMoves.length)
                );
            }
            
            // Agora que temos os melhores movimentos, aplicamos o minimax tradicional
            if (isMaximizingPlayer) {
                let bestScore = -Infinity;
                
                for (const moveObj of bestMoves) {
                    game.move(moveObj.move);
                    const score = selectiveSearch(depth - 1, alpha, beta, false, beamWidth);
                    game.undo();
                    
                    bestScore = Math.max(bestScore, score);
                    alpha = Math.max(alpha, bestScore);
                    
                    if (beta <= alpha) {
                        break; // Poda alpha-beta
                    }
                }
                
                return bestScore;
            } else {
                let bestScore = Infinity;
                
                for (const moveObj of bestMoves) {
                    game.move(moveObj.move);
                    const score = selectiveSearch(depth - 1, alpha, beta, true, beamWidth);
                    game.undo();
                    
                    bestScore = Math.min(bestScore, score);
                    beta = Math.min(beta, bestScore);
                    
                    if (beta <= alpha) {
                        break; // Poda alpha-beta
                    }
                }
                
                return bestScore;
            }
        }

        // Manter a função minimax original para os níveis mais profundos
        function minimax(depth, alpha, beta, isMaximizingPlayer) {
            if (depth === 0 || game.game_over()) {
                return evaluateBoard(game.board(), game.turn());
            }
            
            const moves = game.moves();
            
            if (isMaximizingPlayer) {
                let bestScore = -Infinity;
                
                for (const move of moves) {
                    game.move(move);
                    const score = minimax(depth - 1, alpha, beta, false);
                    game.undo();
                    
                    bestScore = Math.max(bestScore, score);
                    alpha = Math.max(alpha, bestScore);
                    
                    if (beta <= alpha) {
                        break; // Poda alpha-beta
                    }
                }
                
                return bestScore;
            } else {
                let bestScore = Infinity;
                
                for (const move of moves) {
                    game.move(move);
                    const score = minimax(depth - 1, alpha, beta, true);
                    game.undo();
                    
                    bestScore = Math.min(bestScore, score);
                    beta = Math.min(beta, bestScore);
                    
                    if (beta <= alpha) {
                        break; // Poda alpha-beta
                    }
                }
                
                return bestScore;
            }
        }

        // --- Funções de Controle do Jogo ---

        function makeAIMove() {
            console.log("makeAIMove");
            if (game.game_over()) return;

            // Carregar o livro de aberturas
            const currentHash = computePolyglotHash(game).toString(16);

            // Encontrar movimentos no livro
            const entries = openingBook.get(currentHash);
            console.log("entries", entries);
            if (entries) {
                const selectedMove = weightedChoice(entries);
                const uciMove = decodePolyglotMove(selectedMove);
                console.log("uciMove", uciMove);
                board.move(uciMove); // Executar o movimento
                return;
            }

            const ply = game.history().length; // Número de meios-movimentos jogados
            const isOpeningPhase = ply < 6; // Aplicar livro nos 3 primeiros lances das pretas (ply 1 e 3 e 5)
            let openingMoveSAN = null;
            let captureAvailable = false;
            let bookMoveMade = false;

            // 1. Verificar se estamos na fase de abertura e é a vez da IA
            if (game.turn() === aiColor && isOpeningPhase) {
                // 2. Verificar se há alguma captura disponível
                const possibleMoves = game.moves({ verbose: true });
                for (const move of possibleMoves) {
                    if (move.flags.includes('c')) {
                        captureAvailable = true;
                        console.log("AI: Captura disponível, ignorando livro de abertura.");
                        break;
                    }
                }

                // 3. Se não houver captura, determinar o movimento do livro
                if (!captureAvailable) {
                    if (ply === 1) { // Primeiro movimento das Pretas
                        openingMoveSAN = 'e6';
                        console.log("AI: Primeiro movimento das Pretas, jogando e6.");
                    } else if (ply === 3) { // Segundo movimento das Pretas
                        // Verificar se e6 foi jogado (histórico deve ter 3 lances, o segundo sendo e6)
                         if (game.history().length === 3 && game.history({verbose:true})[1].san === 'e6') {
                              openingMoveSAN = 'd5';
                              console.log("AI: Segundo movimento das Pretas, jogando d5.");
                         } else {
                              console.log("AI: Condição para d5 (após e6) não atendida, usando Minimax.");
                         }
                    }
                }
            }

            // 4. Tentar executar o movimento do livro, se aplicável
            if (openingMoveSAN) {
                 const moveResult = game.move(openingMoveSAN);
                 if (moveResult) {
                     console.log("AI: Jogando movimento da abertura (Defesa Francesa):", openingMoveSAN);
                     board.position(game.fen());
                     updateStatus();
                     bookMoveMade = true;
                     // Não precisa de setTimeout aqui, é instantâneo
                 } else {
                     // Isso não deveria acontecer para e6/d5 no início, mas por segurança:
                     console.warn("AI: Movimento da abertura", openingMoveSAN, "foi ilegal? Usando Minimax.");
                 }
            }

            // 5. Se nenhum movimento do livro foi feito, usar Minimax
            if (!bookMoveMade) {
                console.log("AI: Usando Minimax para encontrar o movimento.");
                var depth = parseInt(document.getElementById('difficulty').value);
                // ---> MOSTRAR LOADING <---
                //loadingOverlay.classList.add('active');
                // Opcional: remover a atualização do #status para "Pensando..." se o overlay for suficiente
                setThinkingStatus(true);
                // Usar setTimeout para não bloquear a UI e dar sensação de "pensamento"
                window.setTimeout(function() {
                    var move = minimaxRoot(depth, false); // Preto é minimizador

                    // ---> ESCONDER LOADING (SEMPRE, mesmo se move for null) <---
                    //loadingOverlay.classList.remove('active');
                    setThinkingStatus(false);

                    if (move) {
                        const capturedPiece = game.get(move.to);
                        
                        game.move(move.san);
                        
                        // Tocar som do movimento
                        playMoveSound();
                        
                        // Destacar o movimento da IA
                        highlightMove(move.from, move.to);
                        
                        if (capturedPiece) {
                            const color = capturedPiece.color;
                            const type = capturedPiece.type;
                            debug("IA capturou:", color, type);
                            capturedPieces[color].push(type);
                            updateCapturedPieces();
                        }

                        board.position(game.fen());
                        updateStatus();
                    } else {
                        console.error("AI Minimax falhou em encontrar um movimento! Estado:", game.fen(), game.game_over());
                    }
                    setThinkingStatus(false);
                }, 400); // Delay pequeno
            }
        }

        // Função setThinkingStatus (sem alterações)
        function setThinkingStatus(isThinking) {
            const statusElement = document.getElementById('status');
            if (isThinking) {
                statusElement.textContent = "IA está pensando...";
            } else {
                 updateStatus(); // Restaura o status normal
            }
        }

        // Função auxiliar para obter o nome correto da peça para a URL da imagem
        function getPieceName(pieceName) {
            return pieceName.toUpperCase().slice(-1);
        }

        // Função atualizada para exibir as peças capturadas
        function updateCapturedPieces() {
            const blackCaptured = document.getElementById('blackCaptured');
            const whiteCaptured = document.getElementById('whiteCaptured');

            debug("Estado atual das peças capturadas:", JSON.stringify(capturedPieces, undefined, 4));
            
            blackCaptured.innerHTML = '';
            whiteCaptured.innerHTML = '';
            
            capturedPieces.b.forEach(piece => {
                const img = document.createElement('img');
                img.src = `../assets/images/b${getPieceName(piece)}.png`;
                img.classList.add('captured-piece');
                blackCaptured.appendChild(img);
            });
            
            capturedPieces.w.forEach(piece => {
                const img = document.createElement('img');
                img.src = `../assets/images/w${getPieceName(piece)}.png`;
                img.classList.add('captured-piece');
                whiteCaptured.appendChild(img);
            });
        }

        // Função para remover highlights anteriores
        function removeHighlights() {
            $('#myBoard .square-55d63').removeClass('highlight-white');
            $('#myBoard .square-55d63').removeClass('highlight-black');
        }

        // Função para destacar um movimento
        function highlightMove(source, target) {
            removeHighlights();
            $('#myBoard .square-' + source).addClass('highlight-white');
            $('#myBoard .square-' + target).addClass('highlight-black');
        }

        // Função para remover highlights de movimentos possíveis
        function removeLegalMoveHighlights() {
            $('#myBoard .square-55d63').removeClass('highlight-legal-move');
        }

        // Função para mostrar movimentos possíveis
        function showLegalMoves(square) {
            // Obter movimentos possíveis para a peça
            const moves = game.moves({
                square: square,
                verbose: true
            });

            // Destacar cada movimento possível
            moves.forEach(move => {
                $(`#myBoard .square-${move.to}`).addClass('highlight-legal-move');
            });
        }

        // Modificar a função onDragStart para mostrar movimentos possíveis
        function onDragStart(source, piece, position, orientation) {
            // Remover highlights anteriores
            removeLegalMoveHighlights();
            
            // Não permitir mover se o jogo acabou ou não é a vez do jogador
            if (game.game_over() || game.turn() !== playerColor || piece.search(/^b/) !== -1) {
                return false;
            }

            // Mostrar movimentos possíveis
            showLegalMoves(source);
        }

        // Modificar a função onDrop para limpar os highlights
        function onDrop(source, target) {
            // Remover highlights de movimentos possíveis
            removeLegalMoveHighlights();

            const capturedPiece = game.get(target);
            
            var move = game.move({ 
                from: source, 
                to: target, 
                promotion: 'q'
            });

            if (move === null) return 'snapback';

            // Tocar som do movimento
            playMoveSound();

            // Destacar o movimento do jogador
            highlightMove(source, target);

            if (capturedPiece) {
                const color = capturedPiece.color;
                const type = capturedPiece.type;
                debug("Peça capturada:", color, type);
                capturedPieces[color].push(type);
                updateCapturedPieces();
            }

            updateStatus();
            console.log("updateStatus");

            if (!game.game_over() && game.turn() === aiColor) {
                // Adiciona delay consistente para os primeiros movimentos
                // if (game.history().length <= 4) { // Primeiros 2 lances de cada lado
                //     setTimeout(() => {
                //         const possibleMoves = game.moves();
                //         const randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                        
                //         game.move(randomMove);
                //         playMoveSound();
                        
                //         // Destacar o movimento aleatório da IA
                //         const lastMove = game.history({verbose: true})[game.history().length - 1];
                //         highlightMove(lastMove.from, lastMove.to);
                        
                //         board.position(game.fen());
                //         updateStatus();
                //     }, 400);
                // } else {
                    makeAIMove();
                //}
            }

            return true; // Evita comportamento inesperado
        }

        // Atualiza o status do jogo (turno, xeque, etc.)
        function updateStatus() {
            let status = '';
            let gameEnded = false;

            if (game.in_checkmate()) {
                // Verifica quem ganhou
                const winner = game.turn() === 'w' ? 'Pretas' : 'Brancas';
                status = `Fim de jogo, ${winner} venceram por xeque-mate`;
                gameEnded = true;
                
                // Toca o som apropriado
                if (winner === 'Brancas') {
                    victorySound.play().catch(error => debug("Erro ao tocar som de vitória:", error));
                } else {
                    defeatSound.play().catch(error => debug("Erro ao tocar som de derrota:", error));
                }
            }
            else if (game.in_draw()) {
                status = 'Fim de jogo, empate';
                gameEnded = true;
                defeatSound.play().catch(error => debug("Erro ao tocar som de empate:", error));
            }
            else if (game.in_stalemate()) {
                status = 'Fim de jogo, empate por afogamento';
                gameEnded = true;
                defeatSound.play().catch(error => debug("Erro ao tocar som de empate:", error));
            }
            else if (game.in_threefold_repetition()) {
                status = 'Fim de jogo, empate por tripla repetição';
                gameEnded = true;
                defeatSound.play().catch(error => debug("Erro ao tocar som de empate:", error));
            }
            else if (game.insufficient_material()) {
                status = 'Fim de jogo, empate por material insuficiente';
                gameEnded = true;
                defeatSound.play().catch(error => debug("Erro ao tocar som de empate:", error));
            }
            else {
                status = game.turn() === 'b' ? 'Turno: Pretas' : 'Turno: Brancas';
            }

            if (game.in_check()) {
                status += ' (XEQUE)';
            }

            document.getElementById('turn').textContent = status;
            
            // Se o jogo acabou, desabilita o tabuleiro
            if (gameEnded) {
                board.draggable = false;
            }
        }

        // Configuração inicial do chessboardjs
        var config = {
            draggable: true,
            position: 'start',
            onDragStart: onDragStart,
            onDrop: onDrop,
            onSnapEnd: function() {
                board.position(game.fen());
            },
            onMouseoutSquare: removeLegalMoveHighlights,
            onMouseoverSquare: function(square, piece) {
                // Mostrar movimentos possíveis apenas se for uma peça do jogador
                if (piece && piece.charAt(0) === playerColor) {
                    showLegalMoves(square);
                }
            },
            pieceTheme: '../assets/images/{piece}.png'
            //pieceTheme: 'https://chessboardjs.com/img/chesspieces/alpha/{piece}.png'
            //pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
        };

        board = Chessboard('myBoard', config); // Inicializa o tabuleiro

        // --- Event Listeners ---
        document.getElementById('newGameButton').addEventListener('click', function() {
            game = new Chess();
            board.position('start');
            board.draggable = true;
            loadingOverlay.classList.remove('active');
            capturedPieces.w = [];
            capturedPieces.b = [];
            updateCapturedPieces();
            updateStatus();
            removeHighlights();
            removeLegalMoveHighlights();
            document.getElementById('turn').textContent = 'Turno: Brancas';
            $('#myBoard .square-55d63').removeClass('highlight-check');
        });

        document.getElementById('difficulty').addEventListener('change', function(e) {
            currentDifficultyDepth = parseInt(e.target.value);
            //console.log("Dificuldade alterada para Profundidade: " + currentDifficultyDepth);
            // Opcional: Reiniciar o jogo ao mudar a dificuldade?
            // game = new Chess();
            // board.position('start');
            // updateStatus();
        });

        // --- Inicialização ---
        $(window).resize(board.resize); // Torna o tabuleiro responsivo se a janela mudar de tamanho
        updateStatus(); // Define o status inicial

    </script>

</body>
</html>