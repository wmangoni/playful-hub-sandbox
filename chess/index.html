<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo de Xadrez com IA</title>
    <!-- Incluir CSS do chessboardjs -->
    <link rel="stylesheet"
          href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">

    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 20px;
            background-color: #b3aa88;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        /* Container para o tabuleiro e o overlay */
        .board-container {
            position: relative; /* Necessário para posicionar o overlay absoluto */
            width: 400px; /* Mesma largura do tabuleiro */
            margin-bottom: 15px;
        }
        #myBoard {
            width: 400px; /* Ou ajuste conforme necessário */
            margin-bottom: 15px;
        }
        .controls {
            margin-top: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        #status, #turn {
            margin: 5px 0;
            font-weight: bold;
            min-height: 1.2em; /* Evita saltos de layout */
        }
        select, button {
            padding: 8px 12px;
            font-size: 1em;
            cursor: pointer;
        }
        .highlight-check {
            box-shadow: inset 0 0 15px 5px rgba(255, 0, 0, 0.5); /* Destaque visual para rei em xeque */
        }
        /* --- Estilo do Overlay de Loading --- */
        #loadingOverlay {
            position: absolute; /* Posiciona sobre o tabuleiro */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.7); /* Fundo branco semi-transparente */
            color: #333;
            font-size: 1.8em;
            font-weight: bold;
            display: flex; /* Para centralizar o texto */
            justify-content: center;
            align-items: center;
            z-index: 100; /* Garante que fique por cima das peças */
            cursor: wait; /* Muda o cursor */
            border-radius: 3px; /* Opcional: arredondar bordas */
            /* Escondido por padrão */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out; /* Transição suave */
        }
        /* Classe para mostrar o overlay */
        #loadingOverlay.active {
            opacity: 1;
            visibility: visible;
        }
        .captured-pieces {
            display: flex;
            flex-wrap: wrap;
            min-height: 50px;
            padding: 10px;
            margin: 10px 0;
            background: #e8e0d3;
            border-radius: 4px;
            width: 400px; /* Mesma largura do tabuleiro */
        }
        .captured-piece {
            width: 30px;
            height: 30px;
            margin: 2px;
        }
        /* Estilos para destacar a última jogada */
        .highlight-white {
            box-shadow: inset 0 0 3px 3px yellow;
        }
        .highlight-black {
            box-shadow: inset 0 0 3px 3px yellow;
        }
        /* Estilo para os movimentos possíveis */
        .highlight-legal-move {
            background-color: rgba(0, 255, 0, 0.3) !important;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <h2>Xadrez com IA (Minimax Alpha-Beta)</h2>
        <div class="captured-pieces" id="blackCaptured">
            <!-- Peças pretas capturadas -->
        </div>
        <div class="board-container">
            <div id="myBoard"></div>
            <!-- Elemento do Overlay -->
            <div id="loadingOverlay">Pensando...</div>
        </div>
        <div class="captured-pieces" id="whiteCaptured">
            <!-- Peças brancas capturadas -->
        </div>
        <div id="status">Status: Novo Jogo</div>
        <div id="turn">Turno: Brancas</div>

        <div class="controls">
            <label for="difficulty">Dificuldade:</label>
            <select id="difficulty">
                <option value="2">Muito Fácil</option>
                <option value="3" selected>Fácil</option>
                <option value="4">Médio</option>
                <option value="5">Difícil</option>
            </select>
            <button id="newGameButton">Novo Jogo</button>
        </div>
    </div>

    <!-- Incluir Bibliotecas JavaScript -->
    <!-- jQuery (dependência do chessboardjs) -->
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <!-- chessboardjs -->
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <!-- chess.js (lógica do xadrez) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

    <script>
        // --- Variáveis Globais ---
        var board = null; // Objeto chessboardjs
        var game = new Chess(); // Objeto chess.js
        var playerColor = 'w'; // Jogador humano é sempre as brancas por simplicidade
        var aiColor = 'b';
        var currentDifficultyDepth = 2; // Profundidade inicial (Fácil)
        var loadingOverlay = document.getElementById('loadingOverlay'); // Referência ao overlay
        const capturedPieces = {
            w: [], // Peças brancas capturadas
            b: []  // Peças pretas capturadas
        };
        const DEBUG_MODE = false; // Controle global para debug
        const moveSound = new Audio('../assets/sounds/sfx-pop.mp3');
        const victorySound = new Audio('../assets/sounds/powerup3.mp3');
        const defeatSound = new Audio('../assets/sounds/game_over_bgm.mp3');

        // --- Tabelas Posição-Peça (Piece-Square Tables) ---
        // Valores adaptados/simplificados. Positivo é bom para a peça naquela casa.
        // Definidos da perspectiva das Brancas (linha 0 é a 8ª fileira, linha 7 é a 1ª)

        var pawnTable = [
            [ 0,   0,   0,   0,   0,   0,   0,   0],
            [50,  50,  50,  50,  50,  50,  50,  50], // Peões avançados valem mais
            [10,  10,  20,  30,  30,  20,  10,  10],
            [ 0,   0,   0,  20,  20,   0,   0,   0],
            [ 0,   0,   0,  20,  20,   0,   0,   0], // Centro inicial
            [ 0, -10, -10,   0,   0, -10, -10,   0], // Penalidade pequena para peões bloqueados iniciais
            [ 0,   0,   0, -20, -20,   0,   0,   0], // Penalidade maior para peões muito recuados
            [ 0,   0,   0,   0,   0,   0,   0,   0]
        ];

        var knightTable = [
            [-50, -40, -30, -30, -30, -30, -40, -50],
            [-40, -20,   0,   0,   0,   0, -20, -40],
            [-30,   0,  10,  10,  10,  10,   0, -30],
            [-30,   0,  10,  20,  20,  10,   0, -30], // Cavalos centralizados são bons
            [-30,   0,  10,  20,  20,  10,   0, -30],
            [-30,   0,  10,  10,  10,  10,   0, -30],
            [-40, -20,   0,   0,   0,   0, -20, -40],
            [-50, -40, -30, -30, -30, -30, -40, -50] // Cavalos nos cantos são ruins
        ];

        var bishopTable = [
            [-20, -10, -10, -10, -10, -10, -10, -20],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-10,   0,   0,  10,  10,   0,   0, -10],
            [-10,   0,  10,  10,  10,  10,   0, -10], // Bispos em diagonais longas e centro
            [-10,   0,  10,  10,  10,  10,   0, -10],
            [-10,   0,   0,  10,  10,   0,   0, -10],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-20, -10, -10, -10, -10, -10, -10, -20]
        ];

        var rookTable = [
            [  0,   0,   0,   0,   0,   0,   0,   0],
            [  0,  10,  10,  10,  10,  10,  10,   0], // Torres na 7ª (ou 2ª para pretas)
            [-10,   0,   0,   0,   0,   0,   0, -10], // Ligeiramente pior nas casas iniciais
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [  0,   0,   0,  10,  10,   0,   0,   0] // Bom em colunas abertas/semi-abertas (simplificado)
        ];

        // Rainha: Combinação de Torre e Bispo (simplificado aqui como bônus central)
         var queenTable = [
            [-20, -10, -10,   0,   0, -10, -10, -20],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [  0,   0,   0,   0,   0,   0,   0,   0],
            [  0,   0,   0,   0,   0,   0,   0,   0],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-20, -10, -10,   0,   0, -10, -10, -20]
        ];

        // Rei: Segurança é chave (simplificado para evitar bordas/centro no início)
        var kingTable = [
            [ 20,  30,  10,   0,   0,  10,  30,  20], // Bom estar perto do canto após roque
            [ 20,  20,   0,   0,   0,   0,  20,  20],
            [-10, -20, -20, -20, -20, -20, -20, -10],
            [-20, -30, -30, -40, -40, -30, -30, -20], // Ruim no centro exposto
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-30, -40, -40, -50, -50, -40, -40, -30]
        ];
        // TODO: Adicionar tabelas de final de jogo para o Rei (onde ele deve ir para o centro)

        // --- Funções da IA (Minimax com Poda Alpha-Beta) ---

        // Função de debug centralizada
        function debug(...args) {
            if (DEBUG_MODE) {
                console.log(...args);
            }
        }

        // Função para tocar o som do movimento
        function playMoveSound() {
            moveSound.currentTime = 0; // Reseta o áudio para o início
            moveSound.play().catch(error => {
                debug("Erro ao tocar som:", error);
            });
        }

        // Modificar a função evaluateBoard para incluir avaliação de ataques
        function evaluateBoard(board, turn) {
            let totalEvaluation = 0;
            
            // Primeiro, avaliamos o valor material e posicional das peças
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const piece = board[i][j];
                    if (piece) {
                        // Valor material da peça
                        const pieceValue = getPieceValue(piece);
                        
                        // Valor posicional da peça
                        let positionalValue = 0;
                        let table = null;
                        
                        // Selecionar a tabela apropriada para a peça
                        switch (piece.type) {
                            case 'p': table = pawnTable; break;
                            case 'n': table = knightTable; break;
                            case 'b': table = bishopTable; break;
                            case 'r': table = rookTable; break;
                            case 'q': table = queenTable; break;
                            case 'k': table = kingTable; break;
                        }
                        
                        if (table) {
                            // A tabela é definida da perspectiva das Brancas.
                            // Se a peça for Preta, precisamos inverter a linha (i).
                            const row = piece.color === 'w' ? i : 7 - i;
                            const col = j;
                            positionalValue = table[row][col];
                        }
                        
                        // Adiciona valor material e posicional.
                        totalEvaluation += (piece.color === 'w' ? (pieceValue + positionalValue) : -(pieceValue + positionalValue));
                    }
                }
            }
            
            // Adicionar avaliação de segurança das peças
            // Verificar se alguma peça está sob ataque e não defendida
            const currentPosition = game.fen();
            
            // Verificar ameaças às peças brancas
            if (turn === 'b') {
                // Simular cada movimento possível das pretas
                const possibleMoves = game.moves({ verbose: true });
                for (const move of possibleMoves) {
                    if (move.flags.includes('c')) { // Se é uma captura
                        const capturedPieceValue = getPieceValueByType(move.captured);
                        // Adicionar um bônus para capturas vantajosas
                        // Quanto maior o valor da peça capturada, maior o bônus
                        totalEvaluation -= capturedPieceValue * 1.5; // Bônus para pretas (negativo para brancas)
                    }
                }
            }
            
            // Verificar ameaças às peças pretas
            if (turn === 'w') {
                // Simular cada movimento possível das brancas
                const possibleMoves = game.moves({ verbose: true });
                for (const move of possibleMoves) {
                    if (move.flags.includes('c')) { // Se é uma captura
                        const capturedPieceValue = getPieceValueByType(move.captured);
                        // Adicionar um bônus para capturas vantajosas
                        totalEvaluation += capturedPieceValue * 1.5; // Bônus para brancas
                    }
                }
            }
            
            // Bônus para xeque
            if (game.in_check()) {
                const checkBonus = 50; // Valor significativo para incentivar xeques
                totalEvaluation += (turn === 'w' ? -checkBonus : checkBonus);
            }

            // Bônus para xeque-mate
            if (game.in_checkmate()) {
                const mateBonus = 10000; // Valor muito alto para priorizar mate
                totalEvaluation += (turn === 'w' ? -mateBonus : mateBonus);
            }

            // Bônus para ataques ao rei
            const enemyKingSquare = findKing(turn === 'w' ? 'b' : 'w');
            if (enemyKingSquare) {
                const [kingFile, kingRank] = [enemyKingSquare.charCodeAt(0) - 'a'.charCodeAt(0), 8 - parseInt(enemyKingSquare[1])];
                
                // Avaliar proximidade das peças ao rei inimigo
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const piece = board[i][j];
                        if (piece && piece.color === turn) {
                            // Calcular distância Manhattan ao rei
                            const distance = Math.abs(i - kingRank) + Math.abs(j - kingFile);
                            // Quanto menor a distância, maior o bônus
                            const proximityBonus = (7 - distance) * 3;
                            totalEvaluation += (turn === 'w' ? proximityBonus : -proximityBonus);
                        }
                    }
                }
            }
            
            return totalEvaluation;
        }

        function getPieceValue(piece) {
            if (piece === null) {
                return 0;
            }
            var getAbsoluteValue = function (piece) {
                switch (piece.type) {
                    case 'p': return 10;
                    case 'n': return 30;
                    case 'b': return 30;
                    case 'r': return 50;
                    case 'q': return 90;
                    case 'k': return 900; // Valor alto para o rei
                    default: return 0;
                }
            };

            var absoluteValue = getAbsoluteValue(piece);
            return piece.color === 'w' ? absoluteValue : -absoluteValue;
        }

        // Função auxiliar para obter o valor de uma peça pelo seu tipo
        function getPieceValueByType(pieceType) {
            switch (pieceType) {
                case 'p': return 10;  // Peão
                case 'n': return 30;  // Cavalo
                case 'b': return 30;  // Bispo
                case 'r': return 50;  // Torre
                case 'q': return 90;  // Dama
                default: return 0;
            }
        }

        // Função auxiliar para encontrar a posição do rei
        function findKing(color) {
            var boardState = game.board();
            for (var i = 0; i < 8; i++) {
                for (var j = 0; j < 8; j++) {
                    var piece = boardState[i][j];
                    if (piece && piece.type === 'k' && piece.color === color) {
                        // Converte coordenadas (linha, coluna) para notação de casa (ex: e4)
                        return String.fromCharCode('a'.charCodeAt(0) + j) + (8 - i);
                    }
                }
            }
            return null; // Não deveria acontecer em um jogo normal
        }

        // Implementar uma função de busca seletiva que avalia apenas os movimentos mais promissores
        function minimaxRoot(depth, isMaximizingPlayer) {
            const moves = game.moves({ verbose: true });
            
            // Número de melhores movimentos para explorar em cada nível
            const BEAM_WIDTH = 4;
            
            // Fase 1: Avaliar todos os movimentos possíveis na primeira camada
            const evaluatedMoves = [];
            
            for (const move of moves) {
                game.move(move.san);
                // Avaliação superficial (profundidade 1)
                const score = evaluateBoard(game.board(), game.turn());
                game.undo();
                
                evaluatedMoves.push({
                    move: move,
                    score: score
                });
            }
            
            // Ordenar os movimentos
            // Para o jogador maximizador (brancas), ordenamos do maior para o menor
            // Para o jogador minimizador (pretas), ordenamos do menor para o maior
            evaluatedMoves.sort((a, b) => {
                return isMaximizingPlayer ? b.score - a.score : a.score - b.score;
            });
            
            // Selecionar apenas os N melhores movimentos
            const bestMoves = evaluatedMoves.slice(0, Math.min(BEAM_WIDTH, evaluatedMoves.length));
            
            // Fase 2: Explorar com profundidade total apenas os melhores movimentos
            let bestMoveFound = null;
            let bestScore = isMaximizingPlayer ? -Infinity : Infinity;
            
            for (const moveObj of bestMoves) {
                game.move(moveObj.move.san);
                // Agora explorar com profundidade total usando seletividade em cada nível
                const value = selectiveSearch(depth - 1, -Infinity, Infinity, !isMaximizingPlayer, BEAM_WIDTH);
                game.undo();
                
                // Atualizar o melhor movimento
                if (isMaximizingPlayer) {
                    if (value > bestScore) {
                        bestScore = value;
                        bestMoveFound = moveObj.move;
                    }
                } else {
                    if (value < bestScore) {
                        bestScore = value;
                        bestMoveFound = moveObj.move;
                    }
                }
            }
            
            // Se por algum motivo não encontrarmos o melhor movimento
            if (bestMoveFound === null && moves.length > 0) {
                return moves[0];
            }
            
            return bestMoveFound;
        }

        // Modificar a função selectiveSearch para considerar capturas como movimentos prioritários
        function selectiveSearch(depth, alpha, beta, isMaximizingPlayer, beamWidth) {
            // Caso base: fim da recursão
            if (depth === 0 || game.game_over()) {
                return evaluateBoard(game.board(), game.turn());
            }
            
            const moves = game.moves({ verbose: true });
            
            // Se estivermos no último nível ou houver poucos movimentos, avaliar todos
            if (depth === 1 || moves.length <= beamWidth) {
                return minimax(depth, alpha, beta, isMaximizingPlayer);
            }
            
            // Separar movimentos de captura e não-captura
            const captureMoves = [];
            const nonCaptureMoves = [];
            
            for (const move of moves) {
                if (move.flags.includes('c')) {
                    captureMoves.push(move);
                } else {
                    nonCaptureMoves.push(move);
                }
            }
            
            // Avaliar superficialmente todos os movimentos neste nível
            const evaluatedCaptures = [];
            const evaluatedNonCaptures = [];
            
            // Avaliar capturas
            for (const move of captureMoves) {
                game.move(move);
                // Avaliação superficial
                const score = evaluateBoard(game.board(), game.turn());
                game.undo();
                
                evaluatedCaptures.push({
                    move: move,
                    score: score
                });
            }
            
            // Avaliar não-capturas
            for (const move of nonCaptureMoves) {
                game.move(move);
                // Avaliação superficial
                const score = evaluateBoard(game.board(), game.turn());
                game.undo();
                
                evaluatedNonCaptures.push({
                    move: move,
                    score: score
                });
            }
            
            // Ordenar os movimentos
            evaluatedCaptures.sort((a, b) => {
                return isMaximizingPlayer ? b.score - a.score : a.score - b.score;
            });
            
            evaluatedNonCaptures.sort((a, b) => {
                return isMaximizingPlayer ? b.score - a.score : a.score - b.score;
            });
            
            // Selecionar os melhores movimentos, priorizando capturas
            let bestMoves = [];
            
            // Adicionar todas as capturas (ou até o limite de beam width)
            bestMoves = bestMoves.concat(evaluatedCaptures.slice(0, beamWidth));
            
            // Adicionar os melhores movimentos não-captura até completar o beam width
            if (bestMoves.length < beamWidth) {
                bestMoves = bestMoves.concat(
                    evaluatedNonCaptures.slice(0, beamWidth - bestMoves.length)
                );
            }
            
            // Agora que temos os melhores movimentos, aplicamos o minimax tradicional
            if (isMaximizingPlayer) {
                let bestScore = -Infinity;
                
                for (const moveObj of bestMoves) {
                    game.move(moveObj.move);
                    const score = selectiveSearch(depth - 1, alpha, beta, false, beamWidth);
                    game.undo();
                    
                    bestScore = Math.max(bestScore, score);
                    alpha = Math.max(alpha, bestScore);
                    
                    if (beta <= alpha) {
                        break; // Poda alpha-beta
                    }
                }
                
                return bestScore;
            } else {
                let bestScore = Infinity;
                
                for (const moveObj of bestMoves) {
                    game.move(moveObj.move);
                    const score = selectiveSearch(depth - 1, alpha, beta, true, beamWidth);
                    game.undo();
                    
                    bestScore = Math.min(bestScore, score);
                    beta = Math.min(beta, bestScore);
                    
                    if (beta <= alpha) {
                        break; // Poda alpha-beta
                    }
                }
                
                return bestScore;
            }
        }

        // Manter a função minimax original para os níveis mais profundos
        function minimax(depth, alpha, beta, isMaximizingPlayer) {
            if (depth === 0 || game.game_over()) {
                return evaluateBoard(game.board(), game.turn());
            }
            
            const moves = game.moves();
            
            if (isMaximizingPlayer) {
                let bestScore = -Infinity;
                
                for (const move of moves) {
                    game.move(move);
                    const score = minimax(depth - 1, alpha, beta, false);
                    game.undo();
                    
                    bestScore = Math.max(bestScore, score);
                    alpha = Math.max(alpha, bestScore);
                    
                    if (beta <= alpha) {
                        break; // Poda alpha-beta
                    }
                }
                
                return bestScore;
            } else {
                let bestScore = Infinity;
                
                for (const move of moves) {
                    game.move(move);
                    const score = minimax(depth - 1, alpha, beta, true);
                    game.undo();
                    
                    bestScore = Math.min(bestScore, score);
                    beta = Math.min(beta, bestScore);
                    
                    if (beta <= alpha) {
                        break; // Poda alpha-beta
                    }
                }
                
                return bestScore;
            }
        }

        // --- Funções de Controle do Jogo ---

        function makeAIMove() {
            if (game.game_over()) return;

            const ply = game.history().length; // Número de meios-movimentos jogados
            const isOpeningPhase = ply < 6; // Aplicar livro nos 3 primeiros lances das pretas (ply 1 e 3 e 5)
            let openingMoveSAN = null;
            let captureAvailable = false;
            let bookMoveMade = false;

            // 1. Verificar se estamos na fase de abertura e é a vez da IA
            if (game.turn() === aiColor && isOpeningPhase) {
                // 2. Verificar se há alguma captura disponível
                const possibleMoves = game.moves({ verbose: true });
                for (const move of possibleMoves) {
                    if (move.flags.includes('c')) {
                        captureAvailable = true;
                        //console.log("AI: Captura disponível, ignorando livro de abertura.");
                        break;
                    }
                }

                // 3. Se não houver captura, determinar o movimento do livro
                if (!captureAvailable) {
                    if (ply === 1) { // Primeiro movimento das Pretas
                        openingMoveSAN = 'e6';
                    } else if (ply === 3) { // Segundo movimento das Pretas
                        // Verificar se e6 foi jogado (histórico deve ter 3 lances, o segundo sendo e6)
                         if (game.history().length === 3 && game.history({verbose:true})[1].san === 'e6') {
                              openingMoveSAN = 'd5';
                         } else {
                              //console.log("AI: Condição para d5 (após e6) não atendida, usando Minimax.");
                         }
                    }
                }
            }

            // 4. Tentar executar o movimento do livro, se aplicável
            if (openingMoveSAN) {
                 const moveResult = game.move(openingMoveSAN);
                 if (moveResult) {
                     //console.log("AI: Jogando movimento da abertura (Defesa Francesa):", openingMoveSAN);
                     board.position(game.fen());
                     updateStatus();
                     bookMoveMade = true;
                     // Não precisa de setTimeout aqui, é instantâneo
                 } else {
                     // Isso não deveria acontecer para e6/d5 no início, mas por segurança:
                     console.warn("AI: Movimento da abertura", openingMoveSAN, "foi ilegal? Usando Minimax.");
                 }
            }

            // 5. Se nenhum movimento do livro foi feito, usar Minimax
            if (!bookMoveMade) {
                // //console.log("AI: Usando Minimax para encontrar o movimento.");
                var depth = parseInt(document.getElementById('difficulty').value);
                // ---> MOSTRAR LOADING <---
                //loadingOverlay.classList.add('active');
                // Opcional: remover a atualização do #status para "Pensando..." se o overlay for suficiente
                setThinkingStatus(true);
                // Usar setTimeout para não bloquear a UI e dar sensação de "pensamento"
                window.setTimeout(function() {
                    var move = minimaxRoot(depth, false); // Preto é minimizador

                    // ---> ESCONDER LOADING (SEMPRE, mesmo se move for null) <---
                    //loadingOverlay.classList.remove('active');
                    setThinkingStatus(false);

                    if (move) {
                        const capturedPiece = game.get(move.to);
                        
                        game.move(move.san);
                        
                        // Tocar som do movimento
                        playMoveSound();
                        
                        // Destacar o movimento da IA
                        highlightMove(move.from, move.to);
                        
                        if (capturedPiece) {
                            const color = capturedPiece.color;
                            const type = capturedPiece.type;
                            debug("IA capturou:", color, type);
                            capturedPieces[color].push(type);
                            updateCapturedPieces();
                        }

                        board.position(game.fen());
                        updateStatus();
                    } else {
                        console.error("AI Minimax falhou em encontrar um movimento! Estado:", game.fen(), game.game_over());
                    }
                    setThinkingStatus(false);
                }, 400); // Delay pequeno
            }
        }

        // Função setThinkingStatus (sem alterações)
        function setThinkingStatus(isThinking) {
            const statusElement = document.getElementById('status');
            if (isThinking) {
                statusElement.textContent = "IA está pensando...";
            } else {
                 updateStatus(); // Restaura o status normal
            }
        }

        // Função auxiliar para obter o nome correto da peça para a URL da imagem
        function getPieceName(pieceName) {
            return pieceName.toUpperCase().slice(-1);
        }

        // Função atualizada para exibir as peças capturadas
        function updateCapturedPieces() {
            const blackCaptured = document.getElementById('blackCaptured');
            const whiteCaptured = document.getElementById('whiteCaptured');

            debug("Estado atual das peças capturadas:", JSON.stringify(capturedPieces, undefined, 4));
            
            blackCaptured.innerHTML = '';
            whiteCaptured.innerHTML = '';
            
            capturedPieces.b.forEach(piece => {
                const img = document.createElement('img');
                img.src = `../assets/images/b${getPieceName(piece)}.png`;
                img.classList.add('captured-piece');
                blackCaptured.appendChild(img);
            });
            
            capturedPieces.w.forEach(piece => {
                const img = document.createElement('img');
                img.src = `../assets/images/w${getPieceName(piece)}.png`;
                img.classList.add('captured-piece');
                whiteCaptured.appendChild(img);
            });
        }

        // Função para remover highlights anteriores
        function removeHighlights() {
            $('#myBoard .square-55d63').removeClass('highlight-white');
            $('#myBoard .square-55d63').removeClass('highlight-black');
        }

        // Função para destacar um movimento
        function highlightMove(source, target) {
            removeHighlights();
            $('#myBoard .square-' + source).addClass('highlight-white');
            $('#myBoard .square-' + target).addClass('highlight-black');
        }

        // Função para remover highlights de movimentos possíveis
        function removeLegalMoveHighlights() {
            $('#myBoard .square-55d63').removeClass('highlight-legal-move');
        }

        // Função para mostrar movimentos possíveis
        function showLegalMoves(square) {
            // Obter movimentos possíveis para a peça
            const moves = game.moves({
                square: square,
                verbose: true
            });

            // Destacar cada movimento possível
            moves.forEach(move => {
                $(`#myBoard .square-${move.to}`).addClass('highlight-legal-move');
            });
        }

        // Modificar a função onDragStart para mostrar movimentos possíveis
        function onDragStart(source, piece, position, orientation) {
            // Remover highlights anteriores
            removeLegalMoveHighlights();
            
            // Não permitir mover se o jogo acabou ou não é a vez do jogador
            if (game.game_over() || game.turn() !== playerColor || piece.search(/^b/) !== -1) {
                return false;
            }

            // Mostrar movimentos possíveis
            showLegalMoves(source);
        }

        // Modificar a função onDrop para limpar os highlights
        function onDrop(source, target) {
            // Remover highlights de movimentos possíveis
            removeLegalMoveHighlights();

            const capturedPiece = game.get(target);
            
            var move = game.move({ 
                from: source, 
                to: target, 
                promotion: 'q'
            });

            if (move === null) return 'snapback';

            // Tocar som do movimento
            playMoveSound();

            // Destacar o movimento do jogador
            highlightMove(source, target);

            if (capturedPiece) {
                const color = capturedPiece.color;
                const type = capturedPiece.type;
                debug("Peça capturada:", color, type);
                capturedPieces[color].push(type);
                updateCapturedPieces();
            }

            updateStatus();
            
            if (!game.game_over() && game.turn() === aiColor) {
                // Adiciona delay consistente para os primeiros movimentos
                if (game.history().length <= 4) { // Primeiros 2 lances de cada lado
                    setTimeout(() => {
                        const possibleMoves = game.moves();
                        const randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                        
                        game.move(randomMove);
                        playMoveSound();
                        
                        // Destacar o movimento aleatório da IA
                        const lastMove = game.history({verbose: true})[game.history().length - 1];
                        highlightMove(lastMove.from, lastMove.to);
                        
                        board.position(game.fen());
                        updateStatus();
                    }, 400);
                } else {
                    makeAIMove();
                }
            }
        }

        // Atualiza o status do jogo (turno, xeque, etc.)
        function updateStatus() {
            let status = '';
            let gameEnded = false;

            if (game.in_checkmate()) {
                // Verifica quem ganhou
                const winner = game.turn() === 'w' ? 'Pretas' : 'Brancas';
                status = `Fim de jogo, ${winner} venceram por xeque-mate`;
                gameEnded = true;
                
                // Toca o som apropriado
                if (winner === 'Brancas') {
                    victorySound.play().catch(error => debug("Erro ao tocar som de vitória:", error));
                } else {
                    defeatSound.play().catch(error => debug("Erro ao tocar som de derrota:", error));
                }
            }
            else if (game.in_draw()) {
                status = 'Fim de jogo, empate';
                gameEnded = true;
                defeatSound.play().catch(error => debug("Erro ao tocar som de empate:", error));
            }
            else if (game.in_stalemate()) {
                status = 'Fim de jogo, empate por afogamento';
                gameEnded = true;
                defeatSound.play().catch(error => debug("Erro ao tocar som de empate:", error));
            }
            else if (game.in_threefold_repetition()) {
                status = 'Fim de jogo, empate por tripla repetição';
                gameEnded = true;
                defeatSound.play().catch(error => debug("Erro ao tocar som de empate:", error));
            }
            else if (game.insufficient_material()) {
                status = 'Fim de jogo, empate por material insuficiente';
                gameEnded = true;
                defeatSound.play().catch(error => debug("Erro ao tocar som de empate:", error));
            }
            else {
                status = game.turn() === 'b' ? 'Turno: Pretas' : 'Turno: Brancas';
            }

            if (game.in_check()) {
                status += ' (XEQUE)';
            }

            document.getElementById('turn').textContent = status;
            
            // Se o jogo acabou, desabilita o tabuleiro
            if (gameEnded) {
                board.draggable = false;
            }
        }

        // Configuração inicial do chessboardjs
        var config = {
            draggable: true,
            position: 'start',
            onDragStart: onDragStart,
            onDrop: onDrop,
            onSnapEnd: function() {
                board.position(game.fen());
            },
            onMouseoutSquare: removeLegalMoveHighlights,
            onMouseoverSquare: function(square, piece) {
                // Mostrar movimentos possíveis apenas se for uma peça do jogador
                if (piece && piece.charAt(0) === playerColor) {
                    showLegalMoves(square);
                }
            },
            pieceTheme: '../assets/images/{piece}.png'
        };
        board = Chessboard('myBoard', config); // Inicializa o tabuleiro

        // --- Event Listeners ---
        document.getElementById('newGameButton').addEventListener('click', function() {
            game = new Chess();
            board.position('start');
            board.draggable = true;
            loadingOverlay.classList.remove('active');
            capturedPieces.w = [];
            capturedPieces.b = [];
            updateCapturedPieces();
            updateStatus();
            removeHighlights();
            removeLegalMoveHighlights();
            document.getElementById('turn').textContent = 'Turno: Brancas';
            $('#myBoard .square-55d63').removeClass('highlight-check');
        });

        document.getElementById('difficulty').addEventListener('change', function(e) {
            currentDifficultyDepth = parseInt(e.target.value);
            //console.log("Dificuldade alterada para Profundidade: " + currentDifficultyDepth);
            // Opcional: Reiniciar o jogo ao mudar a dificuldade?
            // game = new Chess();
            // board.position('start');
            // updateStatus();
        });

        // --- Inicialização ---
        $(window).resize(board.resize); // Torna o tabuleiro responsivo se a janela mudar de tamanho
        updateStatus(); // Define o status inicial

    </script>

</body>
</html>