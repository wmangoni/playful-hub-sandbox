<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo de Xadrez com IA</title>
    <!-- Incluir CSS do chessboardjs -->
    <link rel="stylesheet"
          href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">

    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 20px;
            background-color: #b3aa88;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        /* Container para o tabuleiro e o overlay */
        .board-container {
            position: relative; /* Necessário para posicionar o overlay absoluto */
            width: 400px; /* Mesma largura do tabuleiro */
            margin-bottom: 15px;
        }
        #myBoard {
            width: 400px; /* Ou ajuste conforme necessário */
            margin-bottom: 15px;
        }
        .controls {
            margin-top: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        #status, #turn {
            margin: 5px 0;
            font-weight: bold;
            min-height: 1.2em; /* Evita saltos de layout */
        }
        select, button {
            padding: 8px 12px;
            font-size: 1em;
            cursor: pointer;
        }
        .highlight-check {
            box-shadow: inset 0 0 15px 5px rgba(255, 0, 0, 0.5); /* Destaque visual para rei em xeque */
        }
        /* --- Estilo do Overlay de Loading --- */
        #loadingOverlay {
            position: absolute; /* Posiciona sobre o tabuleiro */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.7); /* Fundo branco semi-transparente */
            color: #333;
            font-size: 1.8em;
            font-weight: bold;
            display: flex; /* Para centralizar o texto */
            justify-content: center;
            align-items: center;
            z-index: 100; /* Garante que fique por cima das peças */
            cursor: wait; /* Muda o cursor */
            border-radius: 3px; /* Opcional: arredondar bordas */
            /* Escondido por padrão */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out; /* Transição suave */
        }
        /* Classe para mostrar o overlay */
        #loadingOverlay.active {
            opacity: 1;
            visibility: visible;
        }
        .captured-pieces {
            display: flex;
            flex-wrap: wrap;
            min-height: 50px;
            padding: 10px;
            margin: 10px 0;
            background: #e8e0d3;
            border-radius: 4px;
            width: 400px; /* Mesma largura do tabuleiro */
        }
        .captured-piece {
            width: 30px;
            height: 30px;
            margin: 2px;
        }
        /* Estilos para destacar a última jogada */
        .highlight-white {
            box-shadow: inset 0 0 3px 3px yellow;
        }
        .highlight-black {
            box-shadow: inset 0 0 3px 3px yellow;
        }
        /* Estilo para os movimentos possíveis */
        .highlight-legal-move {
            background-color: rgba(0, 255, 0, 0.3) !important;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <h2>Xadrez com IA (Minimax Alpha-Beta)</h2>
        <div class="captured-pieces" id="blackCaptured">
            <!-- Peças pretas capturadas -->
        </div>
        <div class="board-container">
            <div id="myBoard"></div>
            <!-- Elemento do Overlay -->
            <div id="loadingOverlay">Pensando...</div>
        </div>
        <div class="captured-pieces" id="whiteCaptured">
            <!-- Peças brancas capturadas -->
        </div>
        <div id="status">Status: Novo Jogo</div>
        <div id="turn">Turno: Brancas</div>

        <div class="controls">
            <label for="difficulty">Dificuldade:</label>
            <select id="difficulty">
                <option value="2">Muito Fácil</option>
                <option value="3" selected>Fácil</option>
                <option value="4">Médio</option>
                <option value="5">Difícil</option>
            </select>
            <button id="newGameButton">Novo Jogo</button>
        </div>
    </div>

    <!-- Incluir Bibliotecas JavaScript -->
    <!-- jQuery (dependência do chessboardjs) -->
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <!-- chessboardjs -->
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <!-- chess.js (lógica do xadrez) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

    <script>
        // --- Variáveis Globais ---
        var board = null; // Objeto chessboardjs
        var game = new Chess(); // Objeto chess.js
        var playerColor = 'w'; // Jogador humano é sempre as brancas por simplicidade
        var aiColor = 'b';
        var currentDifficultyDepth = 3; // Profundidade inicial (Fácil)
        var loadingOverlay = document.getElementById('loadingOverlay'); // Referência ao overlay
        const capturedPieces = {
            w: [], // Peças brancas capturadas
            b: []  // Peças pretas capturadas
        };
        const DEBUG_MODE = false; // Controle global para debug
        const moveSound = new Audio('../assets/sounds/sfx-pop.mp3');
        const victorySound = new Audio('../assets/sounds/powerup3.mp3');
        const defeatSound = new Audio('../assets/sounds/game_over_bgm.mp3');

        // --- CONSTANTES DE AVALIAÇÃO (Ajustáveis) ---
        const PAWN_VALUE = 100;
        const KNIGHT_VALUE = 320;
        const BISHOP_VALUE = 330;
        const ROOK_VALUE = 500;
        const QUEEN_VALUE = 900;
        const KING_VALUE = 20000; // Valor altíssimo para evitar mate

        const DOUBLED_PAWN_PENALTY = -10;
        const ISOLATED_PAWN_PENALTY = -15;
        const PASSED_PAWN_BONUS_BASE = 20; // Bônus aumenta com o avanço
        const CASTLING_BONUS = 50;
        const PAWN_SHIELD_BONUS = 10; // Por peão na frente do rei roqueado
        const KING_EXPOSED_PENALTY = -30;
        const DEVELOPMENT_BONUS = 10; // Por peça menor desenvolvida
        const CENTER_PAWN_BONUS = 15; // Peões em d4/e4/d5/e5
        const ATTACK_CENTER_BONUS = 5; // Peças atacando o centro

        // --- Tabelas Posição-Peça (Piece-Square Tables) ---
        // Valores adaptados/simplificados. Positivo é bom para a peça naquela casa.
        // Definidos da perspectiva das Brancas (linha 0 é a 8ª fileira, linha 7 é a 1ª)

        /*
        var pawnTable = [
            [ 0,   0,   0,   0,   0,   0,   0,   0],
            [50,  50,  50,  50,  50,  50,  50,  50], // Peões avançados valem mais
            [10,  10,  20,  30,  30,  20,  10,  10],
            [ 0,   0,   0,  20,  20,   0,   0,   0],
            [ 0,   0,   0,  20,  20,   0,   0,   0], // Centro inicial
            [ 0, -10, -10,   0,   0, -10, -10,   0], // Penalidade pequena para peões bloqueados iniciais
            [ 0,   0,   0, -20, -20,   0,   0,   0], // Penalidade maior para peões muito recuados
            [ 0,   0,   0,   0,   0,   0,   0,   0]
        ];
        */

        var pawnTable = [
            [ 0,   0,   0,   0,   0,   0,   0,   0],
            [ 5,  10,  10, -20, -20,  10,  10,   5],
            [ 5,  -5, -10,   0,   0, -10,  -5,   5],
            [ 0,   0,   0,  20,  20,   0,   0,   0],
            [ 5,   5,  10,  25,  25,  10,   5,   5],
            [ 10,  10, 20,  30,  30,  20,  10,  10],
            [ 50,  50, 50,  50,  50,  50,  50,  50],
            [ 0,   0,   0,   0,   0,   0,   0,   0]
        ];

        var knightTable = [
            [-50, -40, -30, -30, -30, -30, -40, -50],
            [-40, -20,   0,   0,   0,   0, -20, -40],
            [-30,   0,  10,  10,  10,  10,   0, -30],
            [-30,   0,  10,  20,  20,  10,   0, -30], // Cavalos centralizados são bons
            [-30,   0,  10,  20,  20,  10,   0, -30],
            [-30,   0,  10,  10,  10,  10,   0, -30],
            [-40, -20,   0,   0,   0,   0, -20, -40],
            [-50, -40, -30, -30, -30, -30, -40, -50] // Cavalos nos cantos são ruins
        ];

        var bishopTable = [
            [-20, -10, -10, -10, -10, -10, -10, -20],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-10,   0,   0,  10,  10,   0,   0, -10],
            [-10,   0,  10,  10,  10,  10,   0, -10], // Bispos em diagonais longas e centro
            [-10,   0,  10,  10,  10,  10,   0, -10],
            [-10,   0,   0,  10,  10,   0,   0, -10],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-20, -10, -10, -10, -10, -10, -10, -20]
        ];

        var rookTable = [
            [  0,   0,   0,   0,   0,   0,   0,   0],
            [  0,  10,  10,  10,  10,  10,  10,   0], // Torres na 7ª (ou 2ª para pretas)
            [-10,   0,   0,   0,   0,   0,   0, -10], // Ligeiramente pior nas casas iniciais
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [  0,   0,   0,  10,  10,   0,   0,   0] // Bom em colunas abertas/semi-abertas (simplificado)
        ];

        // Rainha: Combinação de Torre e Bispo (simplificado aqui como bônus central)
         var queenTable = [
            [-20, -10, -10,   0,   0, -10, -10, -20],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-10,   0,  10,  10,  10,  10,   0, -10],
            [  0,   0,  10,  10,  10,  10,   0,   0],
            [  0,   0,  10,  10,  10,  10,   0,   0],
            [-10,   0,  10,  10,  10,  10,   0, -10],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-20, -10, -10,   0,   0, -10, -10, -20]
        ];

        // Rei: Segurança é chave (simplificado para evitar bordas/centro no início)
        var kingTable = [
            [ 20,  30,  10,   0,   0,  10,  30,  20], // Bom estar perto do canto após roque
            [ 20,  20,   0,   0,   0,   0,  20,  20],
            [-10, -20, -20, -20, -20, -20, -20, -10],
            [-20, -30, -30, -40, -40, -30, -30, -20], // Ruim no centro exposto
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-30, -40, -40, -50, -50, -40, -40, -30]
        ];

        //Tabela de rei para final de jogo
        var kingTableEndGame = [
            [-50,-40,-30,-20,-20,-30,-40,-50],
            [-30,-20,-10,  0,  0,-10,-20,-30],
            [-30,-10, 20, 30, 30, 20,-10,-30],
            [-30,-10, 30, 40, 40, 30,-10,-30], // Rei ativo no centro no final
            [-30,-10, 30, 40, 40, 30,-10,-30],
            [-30,-10, 20, 30, 30, 20,-10,-30],
            [-30,-20,-10,  0,  0,-10,-20,-30],
            [-50,-40,-30,-20,-20,-30,-40,-50]
        ];

        // Função de debug centralizada
        function debug(...args) {
            if (DEBUG_MODE) {
                console.log(...args);
            }
        }

        // Função para tocar o som do movimento
        function playMoveSound() {
            moveSound.currentTime = 0; // Reseta o áudio para o início
            moveSound.play().catch(error => {
                debug("Erro ao tocar som:", error);
            });
        }

        // Função auxiliar para determinar a fase do jogo (simplificado)
        function determineIsEndGame(currentBoard) {
            let whiteMaterial = 0;
            let blackMaterial = 0;
            let queens = 0;

            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const piece = currentBoard[i][j];
                    if (piece && piece.type !== 'k' && piece.type !== 'p') {
                        const value = getPieceValue(piece); // Usa a função existente
                        if (piece.color === 'w') {
                            whiteMaterial += value;
                        } else {
                            blackMaterial += value;
                        }
                        if (piece.type === 'q') {
                            queens++;
                        }
                    }
                }
            }
            // Critério: Sem damas OU material total (sem peões/reis) abaixo de um limiar
            const lowMaterialThreshold = KNIGHT_VALUE + BISHOP_VALUE + ROOK_VALUE; // Exemplo de limiar
            return queens === 0 || (whiteMaterial < lowMaterialThreshold && blackMaterial < lowMaterialThreshold);
        }
            
        // --- NOVA FUNÇÃO evaluateBoard ---
        function evaluateBoard(currentBoard, turn) {
            let totalEvaluation = 0;
            
            // Verificação de empate por repetição (adicionar no início da função)
            if (game.in_threefold_repetition()) {
                // Se for a vez das pretas (IA), penalizar fortemente o empate
                // pois queremos que a IA evite repetições
                return turn === 'b' ? -5000 : 5000;
            }
            
            // Verificação de outros tipos de empate
            if (game.in_draw() || game.in_stalemate() || game.insufficient_material()) {
                // Penalizar empates em geral, mas menos que o mate
                return turn === 'b' ? -3000 : 3000;
            }

            let materialScore = 0;
            let positionalScore = 0;
            let structureAndSafetyScore = 0;
            let tacticalBonus = 0; // Bônus para xeque, mate, ataques
            let whiteKingSquare = null;
            let blackKingSquare = null;
            let whiteMinorPiecesDeveloped = 0;
            let blackMinorPiecesDeveloped = 0;
            let whitePawns = []; // Armazena { square: 'e2', col: 4, row: 6 }
            let blackPawns = [];

            const isEndGame = determineIsEndGame(currentBoard);

            // --- FASE 1: Calcular Material e Posição Base (Tabelas) ---
            for (let i = 0; i < 8; i++) { // Linhas (0-7) -> Fileiras (8-1)
                for (let j = 0; j < 8; j++) { // Colunas (0-7) -> Colunas (a-h)
                    const piece = currentBoard[i][j];
                    const square = String.fromCharCode('a'.charCodeAt(0) + j) + (8 - i);

                    if (piece) {
                        // 1.1 Calcular Score Material
                        const pieceValue = getPieceValue(piece);
                        materialScore += (piece.color === 'w' ? pieceValue : -pieceValue);

                        // 1.2 Calcular Score Posicional (usando tabelas)
                        let table = null;
                        switch (piece.type) {
                            case 'p':
                                table = pawnTable;
                                if (piece.color === 'w') whitePawns.push({ square: square, col: j, row: i });
                                else blackPawns.push({ square: square, col: j, row: i });
                                break;
                            case 'n':
                                table = knightTable;
                                // Conta desenvolvimento se não estiver na casa inicial
                                if (piece.color === 'w' && !(i === 7 && (j === 1 || j === 6))) whiteMinorPiecesDeveloped += 10;
                                if (piece.color === 'b' && !(i === 0 && (j === 1 || j === 6))) blackMinorPiecesDeveloped += 10;
                                break;
                            case 'b':
                                table = bishopTable;
                                // Conta desenvolvimento se não estiver na casa inicial
                                if (piece.color === 'w' && !(i === 7 && (j === 2 || j === 5))) whiteMinorPiecesDeveloped += 10;
                                if (piece.color === 'b' && !(i === 0 && (j === 2 || j === 5))) blackMinorPiecesDeveloped += 10;
                                break;
                            case 'r': table = rookTable; break;
                            case 'q': table = queenTable; break;
                            case 'k':
                                table = isEndGame ? kingTableEndGame : kingTable;
                                if (piece.color === 'w') whiteKingSquare = { square: square, row: i, col: j };
                                else blackKingSquare = { square: square, row: i, col: j };
                                break;
                        }

                        if (table) {
                            const tableRow = piece.color === 'w' ? i : 7 - i; // Ajusta linha para tabela (espelha para pretas)
                            const tableCol = j;
                            const tableValue = table[tableRow][tableCol];
                            positionalScore += (piece.color === 'w' ? tableValue : -tableValue);
                        }
                    }
                }
            }

            // --- FASE 2: Calcular Bônus/Penalidades Estruturais e de Segurança ---

            // 2.1 Estrutura de Peões
            let whitePawnStructureScore = 0;
            let blackPawnStructureScore = 0;
            const whitePawnCols = whitePawns.map(p => p.col);
            const blackPawnCols = blackPawns.map(p => p.col);

            // Penalidades/Bônus para Brancas
            whitePawns.forEach(pawn => {
                const col = pawn.col;
                const rank = 8 - pawn.row; // Rank (1-8)
                if (whitePawnCols.filter(c => c === col).length > 1) whitePawnStructureScore += DOUBLED_PAWN_PENALTY;
                if (!whitePawnCols.includes(col - 1) && !whitePawnCols.includes(col + 1)) whitePawnStructureScore += ISOLATED_PAWN_PENALTY;
                // Passados: Checar se não há peões pretos na frente ou adjacentes
                let isPassed = true;
                for (let bpCol = col - 1; bpCol <= col + 1; bpCol++) {
                    if (bpCol >= 0 && bpCol <= 7) {
                        blackPawns.forEach(blackPawn => {
                            if (blackPawn.col === bpCol && blackPawn.row < pawn.row) { // Peão preto está à frente
                                isPassed = false;
                            }
                        });
                    }
                    if (!isPassed) break;
                }
                if (isPassed) whitePawnStructureScore += PASSED_PAWN_BONUS_BASE + (rank - 2) * 5;
                // Bônus centro peão (pode ser redundante se já estiver na tabela, mas explícito aqui)
                if (pawn.square === 'd4' || pawn.square === 'e4') whitePawnStructureScore += CENTER_PAWN_BONUS;
            });

            // Penalidades/Bônus para Pretas
            blackPawns.forEach(pawn => {
                const col = pawn.col;
                const rank = 8 - pawn.row; // Rank (1-8)
                if (blackPawnCols.filter(c => c === col).length > 1) blackPawnStructureScore += DOUBLED_PAWN_PENALTY;
                if (!blackPawnCols.includes(col - 1) && !blackPawnCols.includes(col + 1)) blackPawnStructureScore += ISOLATED_PAWN_PENALTY;
                // Passados: Checar se não há peões brancos na frente ou adjacentes
                let isPassed = true;
                for (let wpCol = col - 1; wpCol <= col + 1; wpCol++) {
                    if (wpCol >= 0 && wpCol <= 7) {
                        whitePawns.forEach(whitePawn => {
                            if (whitePawn.col === wpCol && whitePawn.row > pawn.row) { // Peão branco está à frente
                                isPassed = false;
                            }
                        });
                    }
                     if (!isPassed) break;
                }
                if (isPassed) blackPawnStructureScore += PASSED_PAWN_BONUS_BASE + (7 - rank) * 5; // Bonus aumenta com avanço (para pretas)
                // Bônus centro peão
                if (pawn.square === 'd5' || pawn.square === 'e5') blackPawnStructureScore += CENTER_PAWN_BONUS;
            });

            structureAndSafetyScore += whitePawnStructureScore; // Adiciona score branco
            structureAndSafetyScore -= blackPawnStructureScore; // Subtrai score preto

            // 2.2 Segurança do Rei e Roque
            let whiteKingSafetyScore = 0;
            let blackKingSafetyScore = 0;
            // Verifica roque branco (simplificado)
            let whiteCastled = false;
            if (whiteKingSquare) {
                if (whiteKingSquare.square === 'g1' && currentBoard[7][5]?.type === 'r' && currentBoard[7][5]?.color === 'w') { // Roque curto O-O
                    whiteCastled = true;
                    if (currentBoard[6][5]?.type === 'p' && currentBoard[6][5]?.color === 'w') whiteKingSafetyScore += PAWN_SHIELD_BONUS; // f2
                    if (currentBoard[6][6]?.type === 'p' && currentBoard[6][6]?.color === 'w') whiteKingSafetyScore += PAWN_SHIELD_BONUS; // g2
                    if (currentBoard[6][7]?.type === 'p' && currentBoard[6][7]?.color === 'w') whiteKingSafetyScore += PAWN_SHIELD_BONUS; // h2
                } else if (whiteKingSquare.square === 'c1' && currentBoard[7][3]?.type === 'r' && currentBoard[7][3]?.color === 'w') { // Roque longo O-O-O
                    whiteCastled = true;
                    if (currentBoard[6][0]?.type === 'p' && currentBoard[6][0]?.color === 'w') whiteKingSafetyScore += PAWN_SHIELD_BONUS; // a2
                    if (currentBoard[6][1]?.type === 'p' && currentBoard[6][1]?.color === 'w') whiteKingSafetyScore += PAWN_SHIELD_BONUS; // b2
                    if (currentBoard[6][2]?.type === 'p' && currentBoard[6][2]?.color === 'w') whiteKingSafetyScore += PAWN_SHIELD_BONUS; // c2
                }
                if (whiteCastled) whiteKingSafetyScore += CASTLING_BONUS;
                // else if (!isEndGame && (whiteKingSquare.col > 2 && whiteKingSquare.col < 5)) { // Penalidade se rei estiver no centro no meio-jogo sem rocar?
                //     whiteKingSafetyScore += KING_EXPOSED_PENALTY;
                // }
            }
             // Verifica roque preto (simplificado)
            let blackCastled = false;
             if (blackKingSquare) {
                if (blackKingSquare.square === 'g8' && currentBoard[0][5]?.type === 'r' && currentBoard[0][5]?.color === 'b') { // Roque curto O-O
                    blackCastled = true;
                    if (currentBoard[1][5]?.type === 'p' && currentBoard[1][5]?.color === 'b') blackKingSafetyScore += PAWN_SHIELD_BONUS; // f7
                    if (currentBoard[1][6]?.type === 'p' && currentBoard[1][6]?.color === 'b') blackKingSafetyScore += PAWN_SHIELD_BONUS; // g7
                    if (currentBoard[1][7]?.type === 'p' && currentBoard[1][7]?.color === 'b') blackKingSafetyScore += PAWN_SHIELD_BONUS; // h7
                } else if (blackKingSquare.square === 'c8' && currentBoard[0][3]?.type === 'r' && currentBoard[0][3]?.color === 'b') { // Roque longo O-O-O
                    blackCastled = true;
                    if (currentBoard[1][0]?.type === 'p' && currentBoard[1][0]?.color === 'b') blackKingSafetyScore += PAWN_SHIELD_BONUS; // a7
                    if (currentBoard[1][1]?.type === 'p' && currentBoard[1][1]?.color === 'b') blackKingSafetyScore += PAWN_SHIELD_BONUS; // b7
                    if (currentBoard[1][2]?.type === 'p' && currentBoard[1][2]?.color === 'b') blackKingSafetyScore += PAWN_SHIELD_BONUS; // c7
                }
                if (blackCastled) blackKingSafetyScore += CASTLING_BONUS;
                // else if (!isEndGame && (blackKingSquare.col > 2 && blackKingSquare.col < 5)) {
                //     blackKingSafetyScore += KING_EXPOSED_PENALTY;
                // }
            }
            structureAndSafetyScore += whiteKingSafetyScore;
            structureAndSafetyScore -= blackKingSafetyScore;

            // 2.3 Desenvolvimento de Peças Menores
            structureAndSafetyScore += whiteMinorPiecesDeveloped * DEVELOPMENT_BONUS;
            structureAndSafetyScore -= blackMinorPiecesDeveloped * DEVELOPMENT_BONUS;

            // --- FASE 3: Bônus Táticos (Xeque, Mate, Ataque) ---
            // Usamos a instância global 'game' para verificar estados como xeque/mate
            // A avaliação é da *posição atual*. game.turn() indica quem jogaria *depois*.
            const turnAfterPosition = game.turn();

            if (game.in_checkmate()) {
                // Se é a vez das Brancas jogarem e estão em mate, Pretas venceram (ruim para Brancas -> grande negativo)
                // Se é a vez das Pretas jogarem e estão em mate, Brancas venceram (bom para Brancas -> grande positivo)
                tacticalBonus += (turnAfterPosition === 'w' ? -KING_VALUE * 2 : KING_VALUE * 2);
            } else if (game.in_stalemate() || game.in_draw() || game.insufficient_material() || game.in_threefold_repetition()) {
                // Empates devem ter score próximo de 0, ajustando a partir do material/posição
                // Se um lado tem vantagem material mas força empate, isso é ruim para ele.
                // Vamos retornar 0 diretamente para simplificar, assumindo que empate é neutro.
                // return 0; // Ou ajustar baseado na avaliação atual? Por ora, deixamos somar.
            } else if (game.in_check()) {
                // Se é a vez das Brancas jogarem e estão em xeque, é ruim para Brancas (negativo).
                // Se é a vez das Pretas jogarem e estão em xeque, é bom para Brancas (positivo).
                tacticalBonus += (turnAfterPosition === 'w' ? -50 : 50);
            }

            // 3.2 Bônus de Ataque ao Rei (Proximidade - lógica anterior mantida)
            const enemyColor = turn === 'w' ? 'b' : 'w';
            const enemyKingSquare = enemyColor === 'w' ? whiteKingSquare : blackKingSquare;
            let attackBonus = 0;
            if (enemyKingSquare && !isEndGame) { // Bônus de ataque mais relevante no meio-jogo
                const kingRow = enemyKingSquare.row;
                const kingCol = enemyKingSquare.col;
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const piece = currentBoard[i][j];
                        // Se a peça é da cor que está avaliando (cor de 'turn')
                        if (piece && piece.color === turn) {
                            const distance = Math.abs(i - kingRow) + Math.abs(j - kingCol);
                            // Bônus maior para peças mais próximas (inversamente proporcional à distância)
                            // Ajuste o multiplicador conforme necessário
                            attackBonus += Math.max(0, (14 - distance)) * 2; // Ex: 14 - dist, max 0, mult 2
                        }
                    }
                }
            }
            // O bônus de ataque é bom para quem está atacando (turn)
            tacticalBonus += (turn === 'w' ? attackBonus : -attackBonus);


            // --- FASE 4: Retornar Avaliação Final ---
            // Soma todas as componentes. A avaliação é sempre do ponto de vista das Brancas.
            totalEvaluation = materialScore + positionalScore + structureAndSafetyScore + tacticalBonus;

            debug(`Eval (White's Pov): Material=${materialScore}, Positional=${positionalScore}, Struct/Safe=${structureAndSafetyScore}, Tactical=${tacticalBonus} => Total=${totalEvaluation}`);

            // A função minimax lida com maximizar/minimizar, então retornamos sempre a perspectiva das Brancas.
            return totalEvaluation;
        }

        function getPieceValue(piece) {
            if (piece === null) return 0;
            switch (piece.type) {
                case 'p': return PAWN_VALUE;
                case 'n': return KNIGHT_VALUE;
                case 'b': return BISHOP_VALUE;
                case 'r': return ROOK_VALUE;
                case 'q': return QUEEN_VALUE;
                case 'k': return KING_VALUE;
                default: return 0;
            }
        }

        // Função auxiliar para encontrar a posição do rei
        function findKing(color) {
            var boardState = game.board();
            for (var i = 0; i < 8; i++) {
                for (var j = 0; j < 8; j++) {
                    var piece = boardState[i][j];
                    if (piece && piece.type === 'k' && piece.color === color) {
                        // Converte coordenadas (linha, coluna) para notação de casa (ex: e4)
                        return String.fromCharCode('a'.charCodeAt(0) + j) + (8 - i);
                    }
                }
            }
            return null; // Não deveria acontecer em um jogo normal
        }

        // Implementar uma função de busca seletiva que avalia apenas os movimentos mais promissores
        function minimaxRoot(depth, isMaximizingPlayer) {
            const moves = game.moves({ verbose: true });
            
            // Número de melhores movimentos para explorar em cada nível
            const BEAM_WIDTH = 10;
            
            // Fase 1: Avaliar todos os movimentos possíveis na primeira camada
            const evaluatedMoves = [];
            
            for (const move of moves) {
                game.move(move.san);
                // Avaliação superficial (profundidade 1)
                const score = evaluateBoard(game.board(), game.turn());
                game.undo();
                
                evaluatedMoves.push({
                    move: move,
                    score: score
                });
            }
            
            // Ordenar os movimentos
            // Para o jogador maximizador (brancas), ordenamos do maior para o menor
            // Para o jogador minimizador (pretas), ordenamos do menor para o maior
            evaluatedMoves.sort((a, b) => {
                return isMaximizingPlayer ? b.score - a.score : a.score - b.score;
            });
            
            // Selecionar apenas os N melhores movimentos
            const bestMoves = evaluatedMoves.slice(0, Math.min(BEAM_WIDTH, evaluatedMoves.length));
            
            // Fase 2: Explorar com profundidade total apenas os melhores movimentos
            let bestMoveFound = null;
            let bestScore = isMaximizingPlayer ? -Infinity : Infinity;
            
            for (const moveObj of bestMoves) {
                game.move(moveObj.move.san);
                // Agora explorar com profundidade total usando seletividade em cada nível
                const value = selectiveSearch(depth - 1, -Infinity, Infinity, !isMaximizingPlayer, BEAM_WIDTH);
                game.undo();
                
                // Atualizar o melhor movimento
                if (isMaximizingPlayer) {
                    if (value > bestScore) {
                        bestScore = value;
                        bestMoveFound = moveObj.move;
                    }
                } else {
                    if (value < bestScore) {
                        bestScore = value;
                        bestMoveFound = moveObj.move;
                    }
                }
            }
            
            // Se por algum motivo não encontrarmos o melhor movimento
            if (bestMoveFound === null && moves.length > 0) {
                return moves[0];
            }
            
            return bestMoveFound;
        }

        // Modificar a função selectiveSearch para considerar capturas como movimentos prioritários
        function selectiveSearch(depth, alpha, beta, isMaximizingPlayer, beamWidth) {
            // Caso base: fim da recursão
            if (depth === 0 || game.game_over()) {
                return evaluateBoard(game.board(), game.turn());
            }
            
            const moves = game.moves({ verbose: true });
            
            // Se estivermos no último nível ou houver poucos movimentos, avaliar todos
            if (depth === 1 || moves.length <= beamWidth) {
                return minimax(depth, alpha, beta, isMaximizingPlayer);
            }
            
            // Separar movimentos de captura e não-captura
            const captureMoves = [];
            const nonCaptureMoves = [];
            
            for (const move of moves) {
                if (move.flags.includes('c')) {
                    captureMoves.push(move);
                } else {
                    nonCaptureMoves.push(move);
                }
            }
            
            // Avaliar superficialmente todos os movimentos neste nível
            const evaluatedCaptures = [];
            const evaluatedNonCaptures = [];
            
            // Avaliar capturas
            for (const move of captureMoves) {
                game.move(move);
                // Avaliação superficial
                const score = evaluateBoard(game.board(), game.turn());
                game.undo();
                
                evaluatedCaptures.push({
                    move: move,
                    score: score
                });
            }
            
            // Avaliar não-capturas
            for (const move of nonCaptureMoves) {
                game.move(move);
                // Avaliação superficial
                const score = evaluateBoard(game.board(), game.turn());
                game.undo();
                
                evaluatedNonCaptures.push({
                    move: move,
                    score: score
                });
            }
            
            // Ordenar os movimentos
            evaluatedCaptures.sort((a, b) => {
                return isMaximizingPlayer ? b.score - a.score : a.score - b.score;
            });
            
            evaluatedNonCaptures.sort((a, b) => {
                return isMaximizingPlayer ? b.score - a.score : a.score - b.score;
            });
            
            // Selecionar os melhores movimentos, priorizando capturas
            let bestMoves = [];
            
            // Adicionar todas as capturas (ou até o limite de beam width)
            bestMoves = bestMoves.concat(evaluatedCaptures.slice(0, beamWidth));
            
            // Adicionar os melhores movimentos não-captura até completar o beam width
            if (bestMoves.length < beamWidth) {
                bestMoves = bestMoves.concat(
                    evaluatedNonCaptures.slice(0, beamWidth - bestMoves.length)
                );
            }
            
            // Agora que temos os melhores movimentos, aplicamos o minimax tradicional
            if (isMaximizingPlayer) {
                let bestScore = -Infinity;
                
                for (const moveObj of bestMoves) {
                    game.move(moveObj.move);
                    const score = selectiveSearch(depth - 1, alpha, beta, false, beamWidth);
                    game.undo();
                    
                    bestScore = Math.max(bestScore, score);
                    alpha = Math.max(alpha, bestScore);
                    
                    if (beta <= alpha) {
                        break; // Poda alpha-beta
                    }
                }
                
                return bestScore;
            } else {
                let bestScore = Infinity;
                
                for (const moveObj of bestMoves) {
                    game.move(moveObj.move);
                    const score = selectiveSearch(depth - 1, alpha, beta, true, beamWidth);
                    game.undo();
                    
                    bestScore = Math.min(bestScore, score);
                    beta = Math.min(beta, bestScore);
                    
                    if (beta <= alpha) {
                        break; // Poda alpha-beta
                    }
                }
                
                return bestScore;
            }
        }

        // Manter a função minimax original para os níveis mais profundos
        function minimax(depth, alpha, beta, isMaximizingPlayer) {
            if (depth === 0 || game.game_over()) {
                return evaluateBoard(game.board(), game.turn());
            }
            
            const moves = game.moves();
            
            if (isMaximizingPlayer) {
                let bestScore = -Infinity;
                
                for (const move of moves) {
                    game.move(move);
                    const score = minimax(depth - 1, alpha, beta, false);
                    game.undo();
                    
                    bestScore = Math.max(bestScore, score);
                    alpha = Math.max(alpha, bestScore);
                    
                    if (beta <= alpha) {
                        break; // Poda alpha-beta
                    }
                }
                
                return bestScore;
            } else {
                let bestScore = Infinity;
                
                for (const move of moves) {
                    game.move(move);
                    const score = minimax(depth - 1, alpha, beta, true);
                    game.undo();
                    
                    bestScore = Math.min(bestScore, score);
                    beta = Math.min(beta, bestScore);
                    
                    if (beta <= alpha) {
                        break; // Poda alpha-beta
                    }
                }
                
                return bestScore;
            }
        }

        // --- Funções de Controle do Jogo ---

        function makeAIMove() {
            if (game.game_over()) return;

            const ply = game.history().length; // Número de meios-movimentos jogados
            const isOpeningPhase = ply < 6; // Aplicar livro nos 3 primeiros lances das pretas (ply 1 e 3 e 5)
            let openingMoveSAN = null;
            let captureAvailable = false;
            let bookMoveMade = false;

            // 1. Verificar se estamos na fase de abertura e é a vez da IA
            if (game.turn() === aiColor && isOpeningPhase) {
                // 2. Verificar se há alguma captura disponível
                const possibleMoves = game.moves({ verbose: true });
                for (const move of possibleMoves) {
                    if (move.flags.includes('c')) {
                        captureAvailable = true;
                        //console.log("AI: Captura disponível, ignorando livro de abertura.");
                        break;
                    }
                }

                // 3. Se não houver captura, determinar o movimento do livro
                if (!captureAvailable) {
                    if (ply === 1) { // Primeiro movimento das Pretas
                        openingMoveSAN = 'e6';
                    } else if (ply === 3) { // Segundo movimento das Pretas
                        // Verificar se e6 foi jogado (histórico deve ter 3 lances, o segundo sendo e6)
                         if (game.history().length === 3 && game.history({verbose:true})[1].san === 'e6') {
                              openingMoveSAN = 'd5';
                         } else {
                              console.log("AI: Condição para d5 (após e6) não atendida, usando Minimax.");
                         }
                    }
                }
            }

            // 4. Tentar executar o movimento do livro, se aplicável
            if (openingMoveSAN) {
                 const moveResult = game.move(openingMoveSAN);
                 if (moveResult) {
                     //console.log("AI: Jogando movimento da abertura (Defesa Francesa):", openingMoveSAN);
                     board.position(game.fen());
                     updateStatus();
                     bookMoveMade = true;
                     // Não precisa de setTimeout aqui, é instantâneo
                 } else {
                     // Isso não deveria acontecer para e6/d5 no início, mas por segurança:
                     console.warn("AI: Movimento da abertura", openingMoveSAN, "foi ilegal? Usando Minimax.");
                 }
            }

            // 5. Se nenhum movimento do livro foi feito, usar Minimax
            if (!bookMoveMade) {
                // //console.log("AI: Usando Minimax para encontrar o movimento.");
                var depth = parseInt(document.getElementById('difficulty').value);
                // ---> MOSTRAR LOADING <---
                //loadingOverlay.classList.add('active');
                // Opcional: remover a atualização do #status para "Pensando..." se o overlay for suficiente
                setThinkingStatus(true);
                // Usar setTimeout para não bloquear a UI e dar sensação de "pensamento"
                window.setTimeout(function() {
                    var move = minimaxRoot(depth, false); // Preto é minimizador

                    // ---> ESCONDER LOADING (SEMPRE, mesmo se move for null) <---
                    //loadingOverlay.classList.remove('active');
                    setThinkingStatus(false);

                    if (move) {
                        const capturedPiece = game.get(move.to);
                        
                        game.move(move.san);
                        
                        // Tocar som do movimento
                        playMoveSound();
                        
                        // Destacar o movimento da IA
                        highlightMove(move.from, move.to);
                        
                        if (capturedPiece) {
                            const color = capturedPiece.color;
                            const type = capturedPiece.type;
                            debug("IA capturou:", color, type);
                            capturedPieces[color].push(type);
                            updateCapturedPieces();
                        }

                        board.position(game.fen());
                        updateStatus();
                    } else {
                        console.error("AI Minimax falhou em encontrar um movimento! Estado:", game.fen(), game.game_over());
                    }
                    setThinkingStatus(false);
                }, 400); // Delay pequeno
            }
        }

        // Função setThinkingStatus (sem alterações)
        function setThinkingStatus(isThinking) {
            const statusElement = document.getElementById('status');
            if (isThinking) {
                statusElement.textContent = "IA está pensando...";
            } else {
                 updateStatus(); // Restaura o status normal
            }
        }

        // Função auxiliar para obter o nome correto da peça para a URL da imagem
        function getPieceName(pieceName) {
            return pieceName.toUpperCase().slice(-1);
        }

        // Função atualizada para exibir as peças capturadas
        function updateCapturedPieces() {
            const blackCaptured = document.getElementById('blackCaptured');
            const whiteCaptured = document.getElementById('whiteCaptured');

            debug("Estado atual das peças capturadas:", JSON.stringify(capturedPieces, undefined, 4));
            
            blackCaptured.innerHTML = '';
            whiteCaptured.innerHTML = '';
            
            capturedPieces.b.forEach(piece => {
                const img = document.createElement('img');
                img.src = `../assets/images/b${getPieceName(piece)}.png`;
                img.classList.add('captured-piece');
                blackCaptured.appendChild(img);
            });
            
            capturedPieces.w.forEach(piece => {
                const img = document.createElement('img');
                img.src = `../assets/images/w${getPieceName(piece)}.png`;
                img.classList.add('captured-piece');
                whiteCaptured.appendChild(img);
            });
        }

        // Função para remover highlights anteriores
        function removeHighlights() {
            $('#myBoard .square-55d63').removeClass('highlight-white');
            $('#myBoard .square-55d63').removeClass('highlight-black');
        }

        // Função para destacar um movimento
        function highlightMove(source, target) {
            removeHighlights();
            $('#myBoard .square-' + source).addClass('highlight-white');
            $('#myBoard .square-' + target).addClass('highlight-black');
        }

        // Função para remover highlights de movimentos possíveis
        function removeLegalMoveHighlights() {
            $('#myBoard .square-55d63').removeClass('highlight-legal-move');
        }

        // Função para mostrar movimentos possíveis
        function showLegalMoves(square) {
            // Obter movimentos possíveis para a peça
            const moves = game.moves({
                square: square,
                verbose: true
            });

            // Destacar cada movimento possível
            moves.forEach(move => {
                $(`#myBoard .square-${move.to}`).addClass('highlight-legal-move');
            });
        }

        // Modificar a função onDragStart para mostrar movimentos possíveis
        function onDragStart(source, piece, position, orientation) {
            // Remover highlights anteriores
            removeLegalMoveHighlights();
            
            // Não permitir mover se o jogo acabou ou não é a vez do jogador
            if (game.game_over() || game.turn() !== playerColor || piece.search(/^b/) !== -1) {
                return false;
            }

            // Mostrar movimentos possíveis
            showLegalMoves(source);
        }

        // Modificar a função onDrop para limpar os highlights
        function onDrop(source, target) {
            // Remover highlights de movimentos possíveis
            removeLegalMoveHighlights();

            const capturedPiece = game.get(target);
            
            var move = game.move({ 
                from: source, 
                to: target, 
                promotion: 'q'
            });

            if (move === null) return 'snapback';

            // Tocar som do movimento
            playMoveSound();

            // Destacar o movimento do jogador
            highlightMove(source, target);

            if (capturedPiece) {
                const color = capturedPiece.color;
                const type = capturedPiece.type;
                debug("Peça capturada:", color, type);
                capturedPieces[color].push(type);
                updateCapturedPieces();
            }

            updateStatus();
            
            if (!game.game_over() && game.turn() === aiColor) {
                // Adiciona delay consistente para os primeiros movimentos
                if (game.history().length <= 4) { // Primeiros 2 lances de cada lado
                    setTimeout(() => {
                        const possibleMoves = game.moves();
                        const randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                        
                        game.move(randomMove);
                        playMoveSound();
                        
                        // Destacar o movimento aleatório da IA
                        const lastMove = game.history({verbose: true})[game.history().length - 1];
                        highlightMove(lastMove.from, lastMove.to);
                        
                        board.position(game.fen());
                        updateStatus();
                    }, 400);
                } else {
                    makeAIMove();
                }
            }
        }

        // Atualiza o status do jogo (turno, xeque, etc.)
        function updateStatus() {
            let status = '';
            let gameEnded = false;

            if (game.in_checkmate()) {
                // Verifica quem ganhou
                const winner = game.turn() === 'w' ? 'Pretas' : 'Brancas';
                status = `Fim de jogo, ${winner} venceram por xeque-mate`;
                gameEnded = true;
                
                // Toca o som apropriado
                if (winner === 'Brancas') {
                    victorySound.play().catch(error => debug("Erro ao tocar som de vitória:", error));
                } else {
                    defeatSound.play().catch(error => debug("Erro ao tocar som de derrota:", error));
                }
            }
            else if (game.in_draw()) {
                status = 'Fim de jogo, empate';
                gameEnded = true;
                defeatSound.play().catch(error => debug("Erro ao tocar som de empate:", error));
            }
            else if (game.in_stalemate()) {
                status = 'Fim de jogo, empate por afogamento';
                gameEnded = true;
                defeatSound.play().catch(error => debug("Erro ao tocar som de empate:", error));
            }
            else if (game.in_threefold_repetition()) {
                status = 'Fim de jogo, empate por tripla repetição';
                gameEnded = true;
                defeatSound.play().catch(error => debug("Erro ao tocar som de empate:", error));
            }
            else if (game.insufficient_material()) {
                status = 'Fim de jogo, empate por material insuficiente';
                gameEnded = true;
                defeatSound.play().catch(error => debug("Erro ao tocar som de empate:", error));
            }
            else {
                status = game.turn() === 'b' ? 'Turno: Pretas' : 'Turno: Brancas';
            }

            if (game.in_check()) {
                status += ' (XEQUE)';
            }

            document.getElementById('turn').textContent = status;
            
            // Se o jogo acabou, desabilita o tabuleiro
            if (gameEnded) {
                board.draggable = false;
            }
        }

        // Configuração inicial do chessboardjs
        var config = {
            draggable: true,
            position: 'start',
            onDragStart: onDragStart,
            onDrop: onDrop,
            onSnapEnd: function() {
                board.position(game.fen());
            },
            onMouseoutSquare: removeLegalMoveHighlights,
            onMouseoverSquare: function(square, piece) {
                // Mostrar movimentos possíveis apenas se for uma peça do jogador
                if (piece && piece.charAt(0) === playerColor) {
                    showLegalMoves(square);
                }
            },
            pieceTheme: '../assets/images/{piece}.png'
        };
        board = Chessboard('myBoard', config); // Inicializa o tabuleiro

        // --- Event Listeners ---
        document.getElementById('newGameButton').addEventListener('click', function() {
            game = new Chess();
            board.position('start');
            board.draggable = true;
            loadingOverlay.classList.remove('active');
            capturedPieces.w = [];
            capturedPieces.b = [];
            updateCapturedPieces();
            updateStatus();
            removeHighlights();
            removeLegalMoveHighlights();
            document.getElementById('turn').textContent = 'Turno: Brancas';
            $('#myBoard .square-55d63').removeClass('highlight-check');
        });

        document.getElementById('difficulty').addEventListener('change', function(e) {
            currentDifficultyDepth = parseInt(e.target.value);
            //console.log("Dificuldade alterada para Profundidade: " + currentDifficultyDepth);
            // Opcional: Reiniciar o jogo ao mudar a dificuldade?
            // game = new Chess();
            // board.position('start');
            // updateStatus();
        });

        // --- Inicialização ---
        $(window).resize(board.resize); // Torna o tabuleiro responsivo se a janela mudar de tamanho
        updateStatus(); // Define o status inicial

    </script>

</body>
</html>