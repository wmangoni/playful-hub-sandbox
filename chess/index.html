<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo de Xadrez com IA</title>
    <!-- Incluir CSS do chessboardjs -->
    <link rel="stylesheet"
          href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">

    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 20px;
            background-color: #b3aa88;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        /* Container para o tabuleiro e o overlay */
        .board-container {
            position: relative; /* Necessário para posicionar o overlay absoluto */
            width: 400px; /* Mesma largura do tabuleiro */
            margin-bottom: 15px;
        }
        #myBoard {
            width: 400px; /* Ou ajuste conforme necessário */
            margin-bottom: 15px;
        }
        .controls {
            margin-top: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        #status, #turn {
            margin: 5px 0;
            font-weight: bold;
            min-height: 1.2em; /* Evita saltos de layout */
        }
        select, button {
            padding: 8px 12px;
            font-size: 1em;
            cursor: pointer;
        }
        .highlight-check {
            box-shadow: inset 0 0 15px 5px rgba(255, 0, 0, 0.5); /* Destaque visual para rei em xeque */
        }
        /* --- Estilo do Overlay de Loading --- */
        #loadingOverlay {
            position: absolute; /* Posiciona sobre o tabuleiro */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.7); /* Fundo branco semi-transparente */
            color: #333;
            font-size: 1.8em;
            font-weight: bold;
            display: flex; /* Para centralizar o texto */
            justify-content: center;
            align-items: center;
            z-index: 100; /* Garante que fique por cima das peças */
            cursor: wait; /* Muda o cursor */
            border-radius: 3px; /* Opcional: arredondar bordas */
            /* Escondido por padrão */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out; /* Transição suave */
        }
        /* Classe para mostrar o overlay */
        #loadingOverlay.active {
            opacity: 1;
            visibility: visible;
        }
        .captured-pieces {
            display: flex;
            flex-wrap: wrap;
            min-height: 50px;
            padding: 10px;
            margin: 10px 0;
            background: #e8e0d3;
            border-radius: 4px;
            width: 400px; /* Mesma largura do tabuleiro */
        }
        .captured-piece {
            width: 30px;
            height: 30px;
            margin: 2px;
        }
        /* Estilos para destacar a última jogada */
        .highlight-white {
            box-shadow: inset 0 0 3px 3px yellow;
        }
        .highlight-black {
            box-shadow: inset 0 0 3px 3px yellow;
        }
        /* Estilo para os movimentos possíveis */
        .highlight-legal-move {
            background-color: rgba(0, 255, 0, 0.3) !important;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <h2>Xadrez com IA (Minimax Alpha-Beta)</h2>
        <div class="captured-pieces" id="blackCaptured">
            <!-- Peças pretas capturadas -->
        </div>
        <div class="board-container">
            <div id="myBoard"></div>
            <!-- Elemento do Overlay -->
            <div id="loadingOverlay">Pensando...</div>
        </div>
        <div class="captured-pieces" id="whiteCaptured">
            <!-- Peças brancas capturadas -->
        </div>
        <div id="status">Status: Novo Jogo</div>
        <div id="turn">Turno: Brancas</div>

        <div class="controls">
            <label for="difficulty">Dificuldade:</label>
            <select id="difficulty">
                <option value="2">Muito Fácil</option>
                <option value="3" selected>Fácil</option>
                <option value="4">Médio</option>
                <option value="5">Difícil</option>
            </select>
            <button id="newGameButton">Novo Jogo</button>
        </div>
    </div>

    <!-- Incluir Bibliotecas JavaScript -->
    <!-- jQuery (dependência do chessboardjs) -->
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <!-- chessboardjs -->
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <!-- chess.js (lógica do xadrez) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

    <script>
        // --- Variáveis Globais ---
        class OpeningBook {
            constructor() {
                this.entries = new Map(); // hashKey -> [{ move, weight }]
                this.loaded = false;
            }
            
            // métodos da classe...
        }

        class ZobristHashing {
            constructor() {
                this.initialized = false;
                this.pieceValues = {};
                this.randomTable = [];
            }
            
            // métodos da classe...
        }

        var openingBook = new OpeningBook();
        const zobristHashing = new ZobristHashing();

        async function init() {
            openingBook = await loadOpeningBook('human.bin');
        }

        setTimeout(() => {
            init();
        }, 0);

        var board = null; // Objeto chessboardjs
        var game = new Chess(); // Objeto chess.js

        var playerColor = 'w'; // Jogador humano é sempre as brancas por simplicidade
        var aiColor = 'b';
        var currentDifficultyDepth = 3; // Profundidade inicial (Fácil)
        var loadingOverlay = document.getElementById('loadingOverlay'); // Referência ao overlay
        const capturedPieces = {
            w: [], // Peças brancas capturadas
            b: []  // Peças pretas capturadas
        };
        const BEAM_WIDTH = 11;
        const DEBUG_MODE = false; // Controle global para debug
        const moveSound = new Audio('../assets/sounds/sfx-pop.mp3');
        const victorySound = new Audio('../assets/sounds/powerup3.mp3');
        const defeatSound = new Audio('../assets/sounds/game_over_bgm.mp3');

        // --- CONSTANTES DE AVALIAÇÃO (Ajustáveis) ---
        const PAWN_VALUE = 100;
        const KNIGHT_VALUE = 320;
        const BISHOP_VALUE = 330;
        const ROOK_VALUE = 500;
        const QUEEN_VALUE = 900;
        const KING_VALUE = 20000; // Valor altíssimo para evitar mate

        const DOUBLED_PAWN_PENALTY = -10;
        const ISOLATED_PAWN_PENALTY = -15;
        const PASSED_PAWN_BONUS_BASE = 20; // Bônus aumenta com o avanço
        const CASTLING_BONUS = 50;
        const PAWN_SHIELD_BONUS = 10; // Por peão na frente do rei roqueado
        const KING_EXPOSED_PENALTY = -30;
        const DEVELOPMENT_BONUS = 10; // Por peça menor desenvolvida
        const CENTER_PAWN_BONUS = 15; // Peões em d4/e4/d5/e5
        const ATTACK_CENTER_BONUS = 5; // Peças atacando o centro

        // --- Tabelas Posição-Peça (Piece-Square Tables) ---
        // Valores adaptados/simplificados. Positivo é bom para a peça naquela casa.
        // Definidos da perspectiva das Brancas (linha 0 é a 8ª fileira, linha 7 é a 1ª)

        var pawnTable = [
            [ 0,   0,   0,   0,   0,   0,   0,   0],
            [50,  50,  50,  50,  50,  50,  50,  50], // Peões avançados valem mais
            [10,  10,  20,  30,  30,  20,  10,  10],
            [ 0,   0,   0,  20,  20,   0,   0,   0],
            [ 0,   0,   0,  20,  20,   0,   0,   0], // Centro inicial
            [ 0, -10, -10,   0,   0, -10, -10,   0], // Penalidade pequena para peões bloqueados iniciais
            [ 0,   0,   0, -20, -20,   0,   0,   0], // Penalidade maior para peões muito recuados
            [ 0,   0,   0,   0,   0,   0,   0,   0]
        ];

        var knightTable = [
            [-50, -40, -30, -30, -30, -30, -40, -50],
            [-40, -20,   0,   0,   0,   0, -20, -40],
            [-30,   0,  10,  10,  10,  10,   0, -30],
            [-30,   0,  10,  20,  20,  10,   0, -30], // Cavalos centralizados são bons
            [-30,   0,  10,  20,  20,  10,   0, -30],
            [-30,   0,  10,  10,  10,  10,   0, -30],
            [-40, -20,   0,   0,   0,   0, -20, -40],
            [-50, -40, -30, -30, -30, -30, -40, -50] // Cavalos nos cantos são ruins
        ];

        var bishopTable = [
            [-20, -10, -10, -10, -10, -10, -10, -20],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-10,   0,   0,  10,  10,   0,   0, -10],
            [-10,   0,  10,  10,  10,  10,   0, -10], // Bispos em diagonais longas e centro
            [-10,   0,  10,  10,  10,  10,   0, -10],
            [-10,   0,   0,  10,  10,   0,   0, -10],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-20, -10, -10, -10, -10, -10, -10, -20]
        ];

        var rookTable = [
            [  0,   0,   0,   0,   0,   0,   0,   0],
            [  0,  10,  10,  10,  10,  10,  10,   0], // Torres na 7ª (ou 2ª para pretas)
            [-10,   0,   0,   0,   0,   0,   0, -10], // Ligeiramente pior nas casas iniciais
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [  0,   0,   0,  10,  10,   0,   0,   0] // Bom em colunas abertas/semi-abertas (simplificado)
        ];

        // Rainha: Combinação de Torre e Bispo (simplificado aqui como bônus central)
         var queenTable = [
            [-20, -10, -10,   0,   0, -10, -10, -20],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-10,   0,  10,  10,  10,  10,   0, -10],
            [  0,   0,  10,  10,  10,  10,   0,   0],
            [  0,   0,  10,  10,  10,  10,   0,   0],
            [-10,   0,  10,  10,  10,  10,   0, -10],
            [-10,   0,   0,   0,   0,   0,   0, -10],
            [-20, -10, -10,   0,   0, -10, -10, -20]
        ];

        // Rei: Segurança é chave (simplificado para evitar bordas/centro no início)
        var kingTable = [
            [ 20,  30,  10,   0,   0,  10,  30,  20], // Bom estar perto do canto após roque
            [ 20,  20,   0,   0,   0,   0,  20,  20],
            [-10, -20, -20, -20, -20, -20, -20, -10],
            [-20, -30, -30, -40, -40, -30, -30, -20], // Ruim no centro exposto
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-30, -40, -40, -50, -50, -40, -40, -30],
            [-30, -40, -40, -50, -50, -40, -40, -30]
        ];

        //Tabela de rei para final de jogo
        var kingTableEndGame = [
            [-50,-40,-30,-20,-20,-30,-40,-50],
            [-30,-20,-10,  0,  0,-10,-20,-30],
            [-30,-10, 20, 30, 30, 20,-10,-30],
            [-30,-10, 30, 40, 40, 30,-10,-30], // Rei ativo no centro no final
            [-30,-10, 30, 40, 40, 30,-10,-30],
            [-30,-10, 20, 30, 30, 20,-10,-30],
            [-30,-20,-10,  0,  0,-10,-20,-30],
            [-50,-40,-30,-20,-20,-30,-40,-50]
        ];

        const ZOBRIST_TABLE = [
            11329126462075137345, 3096006490854172103, 4961560858198160711, 
            11247167491742853858, 8467686926187236489, 3643601464190828991,
            1133690081497064057, 16733846313379782858, 972344712846728208,
            1875810966947487789, 10810281711139472304, 14997549008232787669,
            4665150172008230450, 77499164859392917, 6752165915987794405,
            2566923340161161676, 419294011261754017, 7466832458773678449,
            8379435287740149003, 9012210492721573360, 9423624571218474956,
            17519441378370680940, 3680699783482293222, 5454859592240567363,
            12278110483549868284, 10213487357180498955, 9786892961111839255,
            1870057424550439649, 13018552956850641599, 8864492181390654148,
            14503047275519531101, 2642043227856860416, 5521189128215049287,
            1488034881489406017, 12041389016824462739, 236592455471957263,
            7168370738516443200, 707553987122498196, 3852097769995099451,
            8313129892476901923, 1761594034649645067, 2291114854896829159,
            15208840396761949525, 13805854893277020740, 11490038688513304612,
            5903053950100844597, 6666107027411611898, 18228317886339920449,
            3626425922614869470, 10120929114188361845, 13383691520091894759,
            9148094160140652064, 1284939680052264319, 7307368198934274627,
            5611679697977124792, 10869036679776403037, 4819485793530191663,
            7866624006794876513, 4794093907474700625, 6849775302623042486,
            4177248038373896072, 10648116955499083915, 7195685255425235832,
            17012007340428799350, 6004979459829542343, 575228772519342402,
            5806056339682094430, 8920438500019044156, 1872523786854905556,
            7168173152291242201, 9388215746117386743, 8767779863385330152,
            1489771135892281206, 17385502867130851733, 15762364259840250620,
            2649182342564336630, 13505777571156529898, 928423270205194457,
            11861585534482611396, 16833723316851456313, 2875176145464482879,
            9598842341590061041, 6103491276194240627, 8264435384771931435,
            17191732074717978439, 11134495390804798113, 8118948727165493749,
            17994305203349779906, 9778408473133385649, 11774350857553791160,
            12559012443159756018, 1810658488341658557, 9781539968129051369,
            658149708018956377, 18376927623552767184, 10225665576382809422,
            11247233359009848457, 12966474917842991341, 4111328737826509899,
            6628917895947053289, 2166287019647928708, 11129710491401161907,
            5728850993485642500, 7135057069693417668, 2409960466139986440,
            6600979542443030540, 5794634036844991298, 1765885809474863574,
            7278670237115156036, 16128398739451409575, 17262998572099182834,
            8877430296282562796, 13401997949814268483, 407550088776850295,
            13080877114316753525, 5365205568318698487, 14935709793025404810,
            17669982663530100772, 4357691132969283455, 17142609481641189533,
            8763584794241613617, 9679198277270145676, 10941274620888120179,
            11693142871022667058, 306186389089741728, 10524424786855933342,
            8136607301146677452, 8332101422058904765, 6215931344642484877,
            17270261617132277633, 13484155073233549231, 5040091220514117480,
            10596830237594186850, 18403699292185779873, 12565676100625672816,
            15937214097180383484, 9145986266726084057, 2521545561146285852,
            14490332804203256105, 9262732965782291301, 16052069408498386422,
            2012514900658959106, 4851386166840481282, 12292183054157138810,
            12139508679861857878, 7319524202191393198, 16056131139463546102,
            2445601317840807269, 12976440137245871676, 10500241373960823632,
            1211454228928495690, 2931510483461322717, 14252799396886324310,
            6217490319246239553, 3253094721785420467, 11224557480718216148,
            17235000084441506492, 12619159779355142232, 5189293263797206570,
            12606612515749494339, 1850950425290819967, 5933835573330569280,
            17649737671476307696, 1240625309976189683, 13611516503114563861,
            11359244008442730831, 463713201815588887, 5603848033623546396,
            5837679654670194627, 13869467824702862516, 13001586210446667388,
            12934789215927278727, 2422944928445377056, 3310549754053175887,
            8519766042450553085, 17839818495653611168, 15503797852889124145,
            16011257830124405835, 862037678550916899, 3197637623672940211,
            5210919022407409764, 14971170165545012763, 12708212522875260313,
            11160345150269715688, 11888460494489868490, 16669255491632516726,
            7618258446600650238, 17993489941568846998, 18188493901990876667,
            11270342415364539415, 10288892439142166224, 7423022476929853822,
            14215600671451202638, 8710936142583354014, 18346051800474256890,
            629718674134230549, 10598630096540703438, 10666243034611769205,
            16077181743459442704, 4303848835390748061, 15183795910155040575,
            17843919060799288312, 15561328988693261185, 15662367820628426663,
            3706272247737428199, 12051713806767926385, 11742603550742019509,
            5704473791139820979, 9787307967224182873, 1637612482787097121,
            8908762506463270222, 17556853009980515212, 4157033003383749538,
            18207866109112763428, 1800584982121391508, 5477894166363593411,
            4674885479076762381, 10160025381792793281, 7550910419722901151,
            8799727354050345442, 11321311575067810671, 4039979115090434978,
            3605513501649795505, 3876110682321388426, 12180869515786039217,
            8620494007958685373, 5854220346205463345, 4855373848161890066,
            15654983601351599195, 5949110547793674363, 5957016279979211145,
            11321480117988196211, 8228060533160592200, 2094843038752308887,
            8801329274201873314, 297395810205168342, 6489982145962516640,
            925952168551929496, 6268205602454985292, 2903841526205938350,
            359914117944187339, 8371662176944962179, 11139146693264846140,
            9807576242525944290, 5795683315677088036, 12688959799593560697,
            1070089889651807102, 6778454470502372484, 17760055623755082862,
            1983224895012736197, 15760908081339863073, 942692161281275413,
            12134286529149333529, 10647676541963177979, 11090026030168016689,
            5245566602671237210, 9195060651485531055, 6368791473535302177,
            3229483537647869491, 15232282204279634326, 928484295759785709,
            1909608352012281665, 10412093924024305118, 5773445318897257735,
            3990834569972524777, 10771395766813261646, 4209783265310087306,
            15318153364378526533, 616435239304311520, 17961392050318287288,
            7798983577523272147, 3913469721920333102, 15424667983992144418,
            6239239264182308800, 1654244791516730287, 17228895932005785491,
            6221161860315361832, 17056602083001532789, 13458912522609437003,
            12917665617485216338, 7337288846716161725, 13022188282781700578,
            12979943748599740071, 510457344639386445, 8796640079689568245,
            13565008864486958290, 6465331256500611624, 11031297210088248644,
            8017026739316632057, 3627975979343775636, 15052215649796371267,
            6222903725779446311, 3527832623857636372, 15597050972685397327,
            8924250025456295612, 14400806714161458836, 10699110515857614396,
            14468157413083537247, 4223238849618215370, 15681850266533497060,
            1140009269240963018, 12966521765762216121, 12695701950206930564,
            3881319844097050799, 16858671235974049358, 17004178443650550617,
            10544522896658866816, 13378871666599081203, 7580967567056532817,
            14279886347066493375, 14791316027199525482, 13540141887354822347,
            15889873206108611120, 13441296750672675768, 11798467976251859403,
            16858792058461978657, 704784010218719535, 9596982322589424841,
            9297677921824001878, 687173692492309888, 2573542046251205823,
            14064986013008197277, 5122261027125484554, 12166444546397347981,
            392580029432520891, 13077660124902070727, 16778702188287612735,
            3451078315256158032, 1238907336018749328, 9205113463181886956, 1667962162104261376, 10830753981784044039, 4479827962372740717, 13723669708721922220, 17895945165757891767, 5275192813757817777, 2148246364622112874, 2290795724393258885, 18193581350273252090, 1776293542351822525, 14757011774120772237, 4313244667902787366, 12281515972708701602, 16810874891151093887, 13231770820477907822, 15338037979535853741, 3321611548688927336, 3305807524324674332, 13385011844708802686, 7248312053715383136, 10692263740491040132, 15834887971838928217, 15164530629649278767, 9112428691881135949, 7848957776938116907, 10951816186743012388, 8896660382367628050, 9603906275513256852, 8762207035762213579, 14987444343672838948, 9409751230138127831, 10591026249259463665, 7197363620976276483, 14301381657157454364, 6373588016705149671, 685071415365890925, 11485719029193745472, 11525714121369126191, 16463451990009075596, 16713578179004591821, 6251124536988276734, 6144308296388004591, 8880818733894805775, 1303007271453773655, 9174156641096830119, 8824404812019774483, 4420129794615782201, 9951556838786075828, 8883975763174874978, 10736884308676275715, 5595889224692918441, 4306406647446967767, 6704191827946442961, 9195534799547011879, 15724940538984617905, 15915014237009546277, 3928039610514994951, 14873195079178728329, 12362539403674935092, 4869881251581666789, 12986343614603388393, 1215083005313393810, 15835354158744478399, 11186056805483324290, 13149236123055901828, 13821214860367539280, 12182689304549523133, 2305696533800337221, 12399248800711438055, 12612571074767202621, 1949121388445288260, 13067734303660960050, 14085928898807657146, 14099042149407050217, 17561987301945706495, 11512458344154956250, 7437568954088789707, 7915171836405846582, 11752651295154297649, 520574178807700830, 9984063241072378277, 16254155646211095029, 8412807604418121470, 5609875541891257226, 11323858615586018348, 8376971840073549054, 1383314287233606303, 15474222835752021056, 5204145074798490767, 2167677454434536938, 10341418833443722943, 8271005071015654673, 15537457915439920220, 10730891177390075310, 11511496483171570656, 16026237624051288806, 11839117319019400126, 11321351259605636133, 5895970210948560438, 3447475526873961356, 7334775646005305872, 15954460007382865005, 6939292427400212706, 8334626163711782046, 1912937584935571784, 12304971244567641760, 8524679326357320614, 2204997376562282123, 3197166419597805379, 4220875528993937793, 2803169229572255230, 5085503808422584221, 14444799216525086860, 4570145336765972565, 9186432380899140933, 11239615222781363662, 9872907954749725788, 10369691348610460342, 11573842626212501214, 18049927275724560211, 15471783285232223897, 16134745906572777443, 13149419803421182712, 14564139292183438565, 2088698177441502777, 15099871677732932330, 5679318949880730421, 16491038769688081874, 1684901764271550206, 6019498834983443029, 8308552077872645018, 2774412133178445207, 2993471197969887147, 8756104692490586069, 7404378077533100169, 11391825116471223489, 17128408637045999621, 5816122712455824169, 5531291136777113635, 7400684525794093602, 2421696223438995901, 2746718911238191773, 2297623779240041360, 15514986454711725499, 13355177993350187464, 2151598180055853022, 14933732441462847914, 17651243408385815107, 4086544267540179726, 3960368502933186560, 16948614951473504462, 11262612224635188739, 12613511070148831882, 2706199935239343179, 10054459213633325149, 17640957734094436437, 15290986714861486531, 16616573458614039565, 2626432152093131908, 14024745482209308341, 12344195406125417964, 7167044992416702836, 11933989054878784040, 1255659969011027721, 3240842176865726111, 795178308456769763, 12389083385239203825, 6408553047871587981, 14331996049216472800, 3362936192376505047, 1486633608756523830, 8937438391818961808, 15513702763578092231, 9242607645174922067, 16999375738341892551, 225631029947824688, 5294122026845313316, 11666909141406975304, 6576914768872977647, 13014342141693467190, 15296769519938257969, 1344590668019013826, 8870296219354404, 1763076921063072981, 11710831831040350446, 11042296215092253456, 12923501896423220822, 2679459049130362043, 15149139477832742400, 2006921612949215342, 2441159149980359103, 4254066403785111886, 10165995291879048302, 17968517685540419316, 4067155115498534723, 14584673823956990486, 7262306400971602773, 2599246507224983677, 1183331494191622178, 9203696637336472112, 8684305384778066392, 452576500022594089, 7158260433795827572, 5749101480176103715, 2141838636388669305, 13319697665469568251, 11739738846189583585, 15704600611932076809, 17288566729036156523, 3345333136360207999, 12225668941959679643, 13135848755558586049, 8127707564878445808, 11020438739076919854, 13800233257954351967, 10719452353263111411, 4467639418469323241, 13341252870622785523, 7043015398453076736, 13802777531561938248, 2597087673064131360, 18196619797102886407, 17222554220133987378, 11603572837337492490, 9373650498706682568, 15247985213323458255, 2826050093225892884, 7047939442312345917, 1975862676241125979, 8471065344236531211, 10781433328192619353, 12710259184248419661, 6983092299355911633, 8891398163252015007, 18232837537224201402, 10128874404256367960, 1184291664448112016, 8752186474456668498, 11883874832968622155, 8304258407043758711, 13031437632736158055, 11394657882570178521, 11346359947151974253, 15207539437603825135, 6743071165850287963, 1895531807983368793, 8070015023023620019, 15994912017468668362, 7264555371116116147, 638838107884199779, 612060626599877907, 16368581545287660539, 2028126038944990910, 8217932366665821866, 12715716898990721499, 4917760284400488853, 4689038209317479950, 15570055495392019914, 7353589116749496814, 6461588461223219363, 16737230234434607639, 10643751583066909176, 13889371344374910415, 14623784806974468748, 6280119077769544053, 5795026310427216669, 15581542564775929183, 5344020438314994897, 17090582320435646615, 13070392342864893666, 2499216570383001617, 5973851566933180981, 11163195574208743088, 10686881252049739702, 7802414647854227001, 7696730671131205892, 11939552629336260711, 8954801150602803298, 5805966293032425995, 10608482480047230587, 4997389530575201269, 7710978612650642680, 7716832357345836839, 15123312752564224361, 16000314919358148208, 5766400084981923062, 11245886267645737076, 8713884558928322285, 7910921931260759656, 17192478743862940141, 3651028258442904531, 4208705969817343911, 3568641929344250749, 7493701010274154640, 2245920858524015772, 13159017457951468389, 12290633441485835508, 17599068061438200851, 18107352842948477138, 3841784002685309084, 3972025232192455038, 7780701379940603769, 14773200954226001784, 16368109790951669962, 11498059885876068682, 331717439817162336, 18209951341142539931, 639100052003347099, 10347169565922244001, 13093097841025825382, 2526013881820679475, 4894708394808468861, 4217798054095379555, 2415982786774940751, 2008219703699744969, 6034935405124924712, 16377935039880138091, 15469949637801139582, 6813989660423069229, 3171782229498906237, 12757488664123869734, 4587441767303016857, 1011542511767058351, 1218420902424652599, 11452069637570869555, 15332250653395824223, 9318912313336593440, 10499356348280572422, 17042034373048666488, 1805505087651779950, 13083730121955101027, 9926866826056072641, 12395083137174176754, 13014086693993705056, 18092419734315653769, 4496402702769466389, 4275128525646469625, 16718947186147009622, 2644524053331857687, 16665345306739798209, 756689505943647349, 6332958748006341455, 5397518675852254155, 3282372277507744968, 15124857616913606283, 9958173582926173484, 550475751710050266, 9535384695938759828, 11027794851313865315, 1895999114042080393, 17795970715748483584, 3512907883609256988, 10170876972722661254, 5100888107877796098, 14766188770308692257, 5664728055166256274, 1867780161745570575, 5069314540135811628, 10826357501146152497, 8428576418859462269, 6489498281288268568, 248384571951887537, 14408891171920865889, 3830179243734057519, 10976374785232997173, 12375273678367885408, 14917570089431431088, 5317296011783481118, 8812437177215009958, 15702128452263965086, 1418237564682130775, 8287918193617750527, 5641726496814939044, 18399300296243087930, 6176181444192939950, 13286219625023629664, 14609847597738937780, 15778618041730427743, 13113915167160321176, 3534397173597697283, 16753315048725296654, 2378655170733740360, 17894101054940110861, 551298419243755034, 14177640314441820846, 18011171644070679608, 1942137629605578202, 17704970308598820532, 10820688583425137796, 319261663834750185, 17320020179565189708, 10828766552733203588, 11254165892366229437, 5921710089078452638, 1692791583615940497, 3154220012138640370, 2462272376968205830, 5215882904155809664, 9063345109742779520, 10012495044321978752, 2282028593076952567, 16490284710305269338, 11358175869672944140, 2648366387851958704, 2535530668932196013, 15386192992268326902, 6797681746413993003, 9131737009282615627, 744965241806492274, 15534171479957703942, 11406512201534848823, 1724859165393741376, 2131804225590070214, 10649852818715990109, 7348272751505534329, 15418610264624661717, 14030296408486517359, 6426639016335384064, 14857241317133980380, 8982836549816060296, 2847738978322528776, 14275200949057556108, 1517491100508351526, 11487065943069529588, 7252270709068430025, 1454069630547688509, 879136823698237927, 764541931096396549, 16628452526739142958, 8210570252116953863, 17419012767447246106, 16656819168530874484, 10879562253146277412, 9340840147615694245, 6892625624787444041, 6239858431661771035, 10484131262376733793, 15135908441777759839, 3591372000141165328, 17394508730963952016, 11925077963498648480, 2231224496660291273, 8127998803539291684, 16292452481085749975, 16488107566197090, 2060923303336906913, 14929791059677233801, 15052228947759922034, 8630622898638529667, 7467898009369859339, 17930561480947107081]

        console.log(computePolyglotHash(game).toString(16));

        async function loadOpeningBook(url) {
            console.log("Attempting to load opening book:", url);
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} for ${url}`);
                }
                const buffer = await response.arrayBuffer();
                const dataView = new DataView(buffer);
                console.log(dataView);
                if (buffer.byteLength % 16 !== 0) {
                    console.warn("Opening book file size is not a multiple of 16 bytes.");
                }
                const entryCount = Math.floor(dataView.byteLength / 16);
                const book = new Map(); // Use a standard Map

                console.log(`Loading ${entryCount} entries from book...`);

                for (let i = 0; i < entryCount; i++) {
                    const entryOffset = i * 16;
                    // Read the key (64 bits, big-endian) as BigInt
                    const key = dataView.getBigUint64(entryOffset, false); // false for big-endian
                    // Read the move (16 bits, big-endian)
                    const move = dataView.getUint16(entryOffset + 8, false);
                    // Read the weight (16 bits, big-endian)
                    const weight = dataView.getUint16(entryOffset + 10, false);
                    // Read learn (32 bits, big-endian) - unused here
                    // const learn = dataView.getUint32(entryOffset + 12, false);

                    if (!book.has(key)) {
                        book.set(key, []);
                    }
                    book.get(key).push({ move, weight });

                    // Optional: Log the first few entries for verification
                    // if (i < 5) {
                    //    console.log(`Entry ${i}: Key=${key.toString(16)}, Move=${move.toString(16)}, Weight=${weight}`);
                    //}
                }
                console.log("Opening book loaded successfully.");
                openingBook.entries = book; // Store in the class instance
                openingBook.loaded = true;  // Mark as loaded
                return book; // Return the map (although it's stored in the global now)

            } catch (error) {
                console.error("Failed to load opening book:", error);
                openingBook.loaded = false;
                return new Map(); // Return empty map on error
            }
        }

        // Calcular hash Zobrist para uma posição do tabuleiro
        function computeHash(board) {
            console.log("computeHash");
            if (!this.initialized) this.initialize();
            
            let hash = 0n; // BigInt para hash de 64 bits
            
            // Peças no tabuleiro
            const boardState = board.board(); // Usa o método .board() corretamente
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = boardState[row][col];
                    if (piece) {
                        const pieceIdx = this.pieceValues[piece.color + piece.type];
                        const squareIdx = row * 8 + col;
                        hash ^= this.randomTable[pieceIdx * 64 + squareIdx];
                    }
                }
            }

            console.log(hash);
            
            // Lado da jogada (brancas ou pretas)
            if (board.turn() === 'b') {
                hash ^= this.randomTable[12 * 64]; // Use índice após todos os valores das peças
            }
            
            // Direitos de roque (ajustado para funcionar com chess.js)
            const castling = { k: false, q: false, K: false, Q: false };
            
            // Verificamos a string de estado FEN para extrair direitos de roque
            const fen = board.fen();
            const fenParts = fen.split(' ');
            if (fenParts.length >= 3) {
                const castlingRights = fenParts[2];
                
                if (castlingRights !== '-') {
                    if (castlingRights.includes('K')) castling.K = true;
                    if (castlingRights.includes('Q')) castling.Q = true;
                    if (castlingRights.includes('k')) castling.k = true;
                    if (castlingRights.includes('q')) castling.q = true;
                }
            }
            
            // Aplica XOR para cada direito de roque
            if (castling.K) hash ^= this.randomTable[12 * 64 + 1]; // Roque curto brancas
            if (castling.Q) hash ^= this.randomTable[12 * 64 + 2]; // Roque longo brancas
            if (castling.k) hash ^= this.randomTable[12 * 64 + 3]; // Roque curto pretas
            if (castling.q) hash ^= this.randomTable[12 * 64 + 4]; // Roque longo pretas
            
            console.log(hash.toString());
            return hash.toString(); // Converte para string para uso como chave no Map
        }

        function computePolyglotHash(game) {
            console.log("computePolyglotHash");
            let hash = 0n;
            // 1. Piece Placement (Indices 0-767)
            // Iterate ranks 1-8, files a-h to match Polyglot square indexing (a1=0, h8=63)
            for (let rank = 1; rank <= 8; rank++) {
                for (let fileIndex = 0; fileIndex < 8; fileIndex++) {
                    const file = 'abcdefgh'[fileIndex];
                    const algebraicSquare = file + rank; // e.g., "a1", "h8"
                    const piece = game.get(algebraicSquare); // Get piece from chess.js

                    if (piece) {
                        const polyglotPiece = getPolyglotPieceIndex(piece);
                        // Calculate Polyglot square index: (rank - 1) * 8 + fileIndex
                        const polyglotSquareIndex = (rank - 1) * 8 + fileIndex; // This is the crucial part

                        // Calculate Zobrist table index for this piece/square combo
                        // Index = piece_index * 64 + square_index
                        const zobristIndex = polyglotPiece * 64 + polyglotSquareIndex;

                        if (zobristIndex < 0 || zobristIndex >= 768) {
                             console.error(`Invalid piece/square zobristIndex: ${zobristIndex} for ${algebraicSquare} (${polyglotSquareIndex}), piece ${polyglotPiece}`);
                             continue; // Should not happen with valid input
                        }
                         // XOR with the corresponding random number
                        hash ^= BigInt(ZOBRIST_TABLE[zobristIndex]);
                        //console.log(`Square: ${algebraicSquare}, Piece: ${piece.color}${piece.type}, PolyPiece: ${polyglotPiece}, PolySqIdx: ${polyglotSquareIndex}, ZobristIdx: ${zobristIndex}, Hash: ${hash.toString(16)}`);
                    }
                }
            }


            // 2. Castling Rights (Indices 768-771)
            const fenParts = game.fen().split(' ');
            const castlingRights = fenParts[2];
            if (castlingRights !== '-') {
                if (castlingRights.includes('K')) hash ^= BigInt(ZOBRIST_TABLE[768]);
                if (castlingRights.includes('Q')) hash ^= BigInt(ZOBRIST_TABLE[769]);
                if (castlingRights.includes('k')) hash ^= BigInt(ZOBRIST_TABLE[770]);
                if (castlingRights.includes('q')) hash ^= BigInt(ZOBRIST_TABLE[771]);
            }
            //console.log(`After castling (${castlingRights}): ${hash.toString(16)}`);

            // 3. En Passant Target Square (Indices 772-779)
            const enPassantTarget = fenParts[3];
            if (enPassantTarget !== '-') {
                // Polyglot only cares about the *file* of the target square
                const file = enPassantTarget.charCodeAt(0) - 'a'.charCodeAt(0); // 0 for 'a', 7 for 'h'
                if (file >= 0 && file < 8) {
                    hash ^= BigInt(ZOBRIST_TABLE[772 + file]);
                    //console.log(`After En Passant (${enPassantTarget}, file ${file}): ${hash.toString(16)}`);
                } else {
                    console.error(`Invalid en passant file index: ${file} from ${enPassantTarget}`);
                }
            } else {
                //console.log(`After En Passant (none): ${hash.toString(16)}`);
            }

            // 4. Side to Move (Index 780)
            // XOR only if it's Black's turn
            if (game.turn() === 'b') {
                hash ^= BigInt(ZOBRIST_TABLE[780]);
                //console.log(`After Side to Move (Black): ${hash.toString(16)}`);
            } else {
                //console.log(`After Side to Move (White): ${hash.toString(16)}`);
            }

            console.log("Final Polyglot Hash:", hash);
            // IMPORTANT: Return the BigInt directly, not the string,
            // to match the keys stored from the binary file.

            return hash;
        }

        function getPolyglotPieceIndex(piece) {
            const offset = piece.color === 'w' ? 0 : 6;
            switch (piece.type) {
                case 'p': return offset + 0;
                case 'n': return offset + 1;
                case 'b': return offset + 2;
                case 'r': return offset + 3;
                case 'q': return offset + 4;
                case 'k': return offset + 5;
                default:  throw new Error(`Invalid piece type: ${piece.type}`);
            }
        }

        function squareIndexToUCI(squareIndex) {
             // Converts Polyglot index (0-63, a1=0) to UCI string (e.g., "a1")
             if (squareIndex < 0 || squareIndex > 63) return "??";
             const file = 'abcdefgh'[squareIndex % 8];
             const rank = Math.floor(squareIndex / 8) + 1;
             return file + rank;
         }

        function decodePolyglotMove(move16) {
            //console.log("decodePolyglotMove", move16);
            // Polyglot move format:
            // 0-5: from square (0-63, a1=0)
            // 6-11: to square (0-63, a1=0)
            // 12-14: promotion piece type (0=N, 1=B, 2=R, 3=Q) -> Actually N=1, B=2, R=3, Q=4 ! Error in some docs. Standard is N=1...
            // Let's use the standard convention: 1=N, 2=B, 3=R, 4=Q (0 means no promotion)

            const fromSquareIndex = move16 & 0x3F;       // 0b0000000000111111
            const toSquareIndex = (move16 >> 6) & 0x3F; // 0b0000111111000000 >> 6
            const promotionType = (move16 >> 12) & 0x7; // 0b0111000000000000 >> 12 (Reads 3 bits) - Standard is 4 types (N,B,R,Q)

            const fromUCI = squareIndexToUCI(fromSquareIndex);
            const toUCI = squareIndexToUCI(toSquareIndex);
            //console.log(`fromIdx=${fromSquareIndex}=${fromUCI}, toIdx=${toSquareIndex}=${toUCI}, promoType=${promotionType}`);

            let promotion = '';
            if (promotionType !== 0) {
                 // Standard Polyglot: 1=N, 2=B, 3=R, 4=Q
                 // Need to map to 'n', 'b', 'r', 'q' for chess.js
                 switch (promotionType) {
                    case 1: promotion = 'n'; break;
                    case 2: promotion = 'b'; break;
                    case 3: promotion = 'r'; break;
                    case 4: promotion = 'q'; break;
                    default: console.warn("Unexpected promotion type in Polyglot move:", promotionType); break;
                 }
             }
            return fromUCI + toUCI + promotion;
        }

        function weightedChoice(entries) {
            //console.log("weightedChoice", entries);
             if (!entries || entries.length === 0) return null; // Handle empty case

            const totalWeight = entries.reduce((acc, entry) => acc + (entry.weight || 0), 0);
            if (totalWeight <= 0) {
                // If weights are zero or invalid, pick randomly without weights
                 return entries[Math.floor(Math.random() * entries.length)].move;
             }

             let random = Math.random() * totalWeight;
             for (const entry of entries) {
                const weight = entry.weight || 0;
                 if (random < weight) {
                     return entry.move; // Return the move data (16-bit number)
                 }
                 random -= weight;
            }
             // Fallback (shouldn't usually happen with correct random/totalWeight)
            return entries[entries.length - 1].move;
        }

        function squareToUCI(square) {
            const file = 'abcdefgh'[square % 8];
            const rank = 8 - Math.floor(square / 8);
            console.log(square, file, rank);
            return file + rank;
        }

        // Função de debug centralizada
        function debug(...args) {
            if (DEBUG_MODE) {
                console.log(...args);
            }
        }

        // Função para tocar o som do movimento
        function playMoveSound() {
            moveSound.currentTime = 0; // Reseta o áudio para o início
            moveSound.play().catch(error => {
                debug("Erro ao tocar som:", error);
            });
        }

        // Função auxiliar para determinar a fase do jogo (simplificado)
        function determineIsEndGame(currentBoard) {
            let whiteMaterial = 0;
            let blackMaterial = 0;
            let queens = 0;

            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                    const piece = currentBoard[i][j];
                    if (piece && piece.type !== 'k' && piece.type !== 'p') {
                        const value = getPieceValue(piece); // Usa a função existente
                        if (piece.color === 'w') {
                            whiteMaterial += value;
                        } else {
                            blackMaterial += value;
                        }
                        if (piece.type === 'q') {
                            queens++;
                        }
                    }
                }
            }
            // Critério: Sem damas OU material total (sem peões/reis) abaixo de um limiar
            const lowMaterialThreshold = KNIGHT_VALUE + BISHOP_VALUE + ROOK_VALUE; // Exemplo de limiar
            return queens === 0 || (whiteMaterial < lowMaterialThreshold && blackMaterial < lowMaterialThreshold);
        }
            
        // --- NOVA FUNÇÃO evaluateBoard ---
        function evaluateBoard(currentBoard, turn) {
            let totalEvaluation = 0;
            
            // Verificação de empate por repetição (adicionar no início da função)
            if (game.in_threefold_repetition()) {
                // Se for a vez das pretas (IA), penalizar fortemente o empate
                // pois queremos que a IA evite repetições
                return turn === 'b' ? -5000 : 5000;
            }
            
            // Verificação de outros tipos de empate
            if (game.in_draw() || game.in_stalemate() || game.insufficient_material()) {
                // Penalizar empates em geral, mas menos que o mate
                return turn === 'b' ? -3000 : 3000;
            }

            let materialScore = 0;
            let positionalScore = 0;
            let structureAndSafetyScore = 0;
            let tacticalBonus = 0; // Bônus para xeque, mate, ataques
            let whiteKingSquare = null;
            let blackKingSquare = null;
            let whiteMinorPiecesDeveloped = 0;
            let blackMinorPiecesDeveloped = 0;
            let whitePawns = []; // Armazena { square: 'e2', col: 4, row: 6 }
            let blackPawns = [];

            const isEndGame = determineIsEndGame(currentBoard);

            // --- FASE 1: Calcular Material e Posição Base (Tabelas) ---
            for (let i = 0; i < 8; i++) { // Linhas (0-7) -> Fileiras (8-1)
                for (let j = 0; j < 8; j++) { // Colunas (0-7) -> Colunas (a-h)
                    const piece = currentBoard[i][j];
                    const square = String.fromCharCode('a'.charCodeAt(0) + j) + (8 - i);

                    if (piece) {
                        // 1.1 Calcular Score Material
                        const pieceValue = getPieceValue(piece);
                        materialScore += (piece.color === 'w' ? pieceValue : -pieceValue);

                        // 1.2 Calcular Score Posicional (usando tabelas)
                        let table = null;
                        switch (piece.type) {
                            case 'p':
                                table = pawnTable;
                                if (piece.color === 'w') whitePawns.push({ square: square, col: j, row: i });
                                else blackPawns.push({ square: square, col: j, row: i });
                                break;
                            case 'n':
                                table = knightTable;
                                // Conta desenvolvimento se não estiver na casa inicial
                                if (piece.color === 'w' && !(i === 7 && (j === 1 || j === 6))) whiteMinorPiecesDeveloped += 10;
                                if (piece.color === 'b' && !(i === 0 && (j === 1 || j === 6))) blackMinorPiecesDeveloped += 10;
                                break;
                            case 'b':
                                table = bishopTable;
                                // Conta desenvolvimento se não estiver na casa inicial
                                if (piece.color === 'w' && !(i === 7 && (j === 2 || j === 5))) whiteMinorPiecesDeveloped += 10;
                                if (piece.color === 'b' && !(i === 0 && (j === 2 || j === 5))) blackMinorPiecesDeveloped += 10;
                                break;
                            case 'r': table = rookTable; break;
                            case 'q': table = queenTable; break;
                            case 'k':
                                table = isEndGame ? kingTableEndGame : kingTable;
                                if (piece.color === 'w') whiteKingSquare = { square: square, row: i, col: j };
                                else blackKingSquare = { square: square, row: i, col: j };
                                break;
                        }

                        if (table) {
                            const tableRow = piece.color === 'w' ? i : 7 - i; // Ajusta linha para tabela (espelha para pretas)
                            const tableCol = j;
                            const tableValue = table[tableRow][tableCol];
                            positionalScore += (piece.color === 'w' ? tableValue : -tableValue);
                        }
                    }
                }
            }

            // --- FASE 2: Calcular Bônus/Penalidades Estruturais e de Segurança ---

            // 2.1 Estrutura de Peões
            let whitePawnStructureScore = 0;
            let blackPawnStructureScore = 0;
            const whitePawnCols = whitePawns.map(p => p.col);
            const blackPawnCols = blackPawns.map(p => p.col);

            // Penalidades/Bônus para Brancas
            whitePawns.forEach(pawn => {
                const col = pawn.col;
                const rank = 8 - pawn.row; // Rank (1-8)
                if (whitePawnCols.filter(c => c === col).length > 1) whitePawnStructureScore += DOUBLED_PAWN_PENALTY;
                if (!whitePawnCols.includes(col - 1) && !whitePawnCols.includes(col + 1)) whitePawnStructureScore += ISOLATED_PAWN_PENALTY;
                // Passados: Checar se não há peões pretos na frente ou adjacentes
                let isPassed = true;
                for (let bpCol = col - 1; bpCol <= col + 1; bpCol++) {
                    if (bpCol >= 0 && bpCol <= 7) {
                        blackPawns.forEach(blackPawn => {
                            if (blackPawn.col === bpCol && blackPawn.row < pawn.row) { // Peão preto está à frente
                                isPassed = false;
                            }
                        });
                    }
                    if (!isPassed) break;
                }
                if (isPassed) whitePawnStructureScore += PASSED_PAWN_BONUS_BASE + (rank - 2) * 5;
                // Bônus centro peão (pode ser redundante se já estiver na tabela, mas explícito aqui)
                if (pawn.square === 'd4' || pawn.square === 'e4') whitePawnStructureScore += CENTER_PAWN_BONUS;
            });

            // Penalidades/Bônus para Pretas
            blackPawns.forEach(pawn => {
                const col = pawn.col;
                const rank = 8 - pawn.row; // Rank (1-8)
                if (blackPawnCols.filter(c => c === col).length > 1) blackPawnStructureScore += DOUBLED_PAWN_PENALTY;
                if (!blackPawnCols.includes(col - 1) && !blackPawnCols.includes(col + 1)) blackPawnStructureScore += ISOLATED_PAWN_PENALTY;
                // Passados: Checar se não há peões brancos na frente ou adjacentes
                let isPassed = true;
                for (let wpCol = col - 1; wpCol <= col + 1; wpCol++) {
                    if (wpCol >= 0 && wpCol <= 7) {
                        whitePawns.forEach(whitePawn => {
                            if (whitePawn.col === wpCol && whitePawn.row > pawn.row) { // Peão branco está à frente
                                isPassed = false;
                            }
                        });
                    }
                     if (!isPassed) break;
                }
                if (isPassed) blackPawnStructureScore += PASSED_PAWN_BONUS_BASE + (7 - rank) * 5; // Bonus aumenta com avanço (para pretas)
                // Bônus centro peão
                if (pawn.square === 'd5' || pawn.square === 'e5') blackPawnStructureScore += CENTER_PAWN_BONUS;
            });

            structureAndSafetyScore += whitePawnStructureScore; // Adiciona score branco
            structureAndSafetyScore -= blackPawnStructureScore; // Subtrai score preto

            // 2.2 Segurança do Rei e Roque
            let whiteKingSafetyScore = 0;
            let blackKingSafetyScore = 0;
            // Verifica roque branco (simplificado)
            let whiteCastled = false;
            if (whiteKingSquare) {
                if (whiteKingSquare.square === 'g1' && currentBoard[7][5]?.type === 'r' && currentBoard[7][5]?.color === 'w') { // Roque curto O-O
                    whiteCastled = true;
                    if (currentBoard[6][5]?.type === 'p' && currentBoard[6][5]?.color === 'w') whiteKingSafetyScore += PAWN_SHIELD_BONUS; // f2
                    if (currentBoard[6][6]?.type === 'p' && currentBoard[6][6]?.color === 'w') whiteKingSafetyScore += PAWN_SHIELD_BONUS; // g2
                    if (currentBoard[6][7]?.type === 'p' && currentBoard[6][7]?.color === 'w') whiteKingSafetyScore += PAWN_SHIELD_BONUS; // h2
                } else if (whiteKingSquare.square === 'c1' && currentBoard[7][3]?.type === 'r' && currentBoard[7][3]?.color === 'w') { // Roque longo O-O-O
                    whiteCastled = true;
                    if (currentBoard[6][0]?.type === 'p' && currentBoard[6][0]?.color === 'w') whiteKingSafetyScore += PAWN_SHIELD_BONUS; // a2
                    if (currentBoard[6][1]?.type === 'p' && currentBoard[6][1]?.color === 'w') whiteKingSafetyScore += PAWN_SHIELD_BONUS; // b2
                    if (currentBoard[6][2]?.type === 'p' && currentBoard[6][2]?.color === 'w') whiteKingSafetyScore += PAWN_SHIELD_BONUS; // c2
                }
                if (whiteCastled) whiteKingSafetyScore += CASTLING_BONUS;
                // else if (!isEndGame && (whiteKingSquare.col > 2 && whiteKingSquare.col < 5)) { // Penalidade se rei estiver no centro no meio-jogo sem rocar?
                //     whiteKingSafetyScore += KING_EXPOSED_PENALTY;
                // }
            }
             // Verifica roque preto (simplificado)
            let blackCastled = false;
             if (blackKingSquare) {
                if (blackKingSquare.square === 'g8' && currentBoard[0][5]?.type === 'r' && currentBoard[0][5]?.color === 'b') { // Roque curto O-O
                    blackCastled = true;
                    if (currentBoard[1][5]?.type === 'p' && currentBoard[1][5]?.color === 'b') blackKingSafetyScore += PAWN_SHIELD_BONUS; // f7
                    if (currentBoard[1][6]?.type === 'p' && currentBoard[1][6]?.color === 'b') blackKingSafetyScore += PAWN_SHIELD_BONUS; // g7
                    if (currentBoard[1][7]?.type === 'p' && currentBoard[1][7]?.color === 'b') blackKingSafetyScore += PAWN_SHIELD_BONUS; // h7
                } else if (blackKingSquare.square === 'c8' && currentBoard[0][3]?.type === 'r' && currentBoard[0][3]?.color === 'b') { // Roque longo O-O-O
                    blackCastled = true;
                    if (currentBoard[1][0]?.type === 'p' && currentBoard[1][0]?.color === 'b') blackKingSafetyScore += PAWN_SHIELD_BONUS; // a7
                    if (currentBoard[1][1]?.type === 'p' && currentBoard[1][1]?.color === 'b') blackKingSafetyScore += PAWN_SHIELD_BONUS; // b7
                    if (currentBoard[1][2]?.type === 'p' && currentBoard[1][2]?.color === 'b') blackKingSafetyScore += PAWN_SHIELD_BONUS; // c7
                }
                if (blackCastled) blackKingSafetyScore += CASTLING_BONUS;
                // else if (!isEndGame && (blackKingSquare.col > 2 && blackKingSquare.col < 5)) {
                //     blackKingSafetyScore += KING_EXPOSED_PENALTY;
                // }
            }
            structureAndSafetyScore += whiteKingSafetyScore;
            structureAndSafetyScore -= blackKingSafetyScore;

            // 2.3 Desenvolvimento de Peças Menores
            structureAndSafetyScore += whiteMinorPiecesDeveloped * DEVELOPMENT_BONUS;
            structureAndSafetyScore -= blackMinorPiecesDeveloped * DEVELOPMENT_BONUS;

            // --- FASE 3: Bônus Táticos (Xeque, Mate, Ataque) ---
            // Usamos a instância global 'game' para verificar estados como xeque/mate
            // A avaliação é da *posição atual*. game.turn() indica quem jogaria *depois*.
            const turnAfterPosition = game.turn();

            if (game.in_checkmate()) {
                // Se é a vez das Brancas jogarem e estão em mate, Pretas venceram (ruim para Brancas -> grande negativo)
                // Se é a vez das Pretas jogarem e estão em mate, Brancas venceram (bom para Brancas -> grande positivo)
                tacticalBonus += (turnAfterPosition === 'w' ? -KING_VALUE * 2 : KING_VALUE * 2);
            } else if (game.in_stalemate() || game.in_draw() || game.insufficient_material() || game.in_threefold_repetition()) {
                // Empates devem ter score próximo de 0, ajustando a partir do material/posição
                // Se um lado tem vantagem material mas força empate, isso é ruim para ele.
                // Vamos retornar 0 diretamente para simplificar, assumindo que empate é neutro.
                // return 0; // Ou ajustar baseado na avaliação atual? Por ora, deixamos somar.
            } else if (game.in_check()) {
                // Se é a vez das Brancas jogarem e estão em xeque, é ruim para Brancas (negativo).
                // Se é a vez das Pretas jogarem e estão em xeque, é bom para Brancas (positivo).
                tacticalBonus += (turnAfterPosition === 'w' ? -50 : 50);
            }

            // 3.2 Bônus de Ataque ao Rei (Proximidade - lógica anterior mantida)
            const enemyColor = turn === 'w' ? 'b' : 'w';
            const enemyKingSquare = enemyColor === 'w' ? whiteKingSquare : blackKingSquare;
            let attackBonus = 0;
            if (enemyKingSquare && !isEndGame) { // Bônus de ataque mais relevante no meio-jogo
                const kingRow = enemyKingSquare.row;
                const kingCol = enemyKingSquare.col;
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const piece = currentBoard[i][j];
                        // Se a peça é da cor que está avaliando (cor de 'turn')
                        if (piece && piece.color === turn) {
                            const distance = Math.abs(i - kingRow) + Math.abs(j - kingCol);
                            // Bônus maior para peças mais próximas (inversamente proporcional à distância)
                            // Ajuste o multiplicador conforme necessário
                            attackBonus += Math.max(0, (14 - distance)) * 2; // Ex: 14 - dist, max 0, mult 2
                        }
                    }
                }
            }
            // O bônus de ataque é bom para quem está atacando (turn)
            tacticalBonus += (turn === 'w' ? attackBonus : -attackBonus);


            // --- FASE 4: Retornar Avaliação Final ---
            // Soma todas as componentes. A avaliação é sempre do ponto de vista das Brancas.
            totalEvaluation = materialScore + positionalScore + structureAndSafetyScore + tacticalBonus;

            debug(`Eval (White's Pov): Material=${materialScore}, Positional=${positionalScore}, Struct/Safe=${structureAndSafetyScore}, Tactical=${tacticalBonus} => Total=${totalEvaluation}`);

            // A função minimax lida com maximizar/minimizar, então retornamos sempre a perspectiva das Brancas.
            return totalEvaluation;
        }

        function getPieceValue(piece) {
            if (piece === null) return 0;
            switch (piece.type) {
                case 'p': return PAWN_VALUE;
                case 'n': return KNIGHT_VALUE;
                case 'b': return BISHOP_VALUE;
                case 'r': return ROOK_VALUE;
                case 'q': return QUEEN_VALUE;
                case 'k': return KING_VALUE;
                default: return 0;
            }
        }

        // Função auxiliar para encontrar a posição do rei
        function findKing(color) {
            var boardState = game.board();
            for (var i = 0; i < 8; i++) {
                for (var j = 0; j < 8; j++) {
                    var piece = boardState[i][j];
                    if (piece && piece.type === 'k' && piece.color === color) {
                        // Converte coordenadas (linha, coluna) para notação de casa (ex: e4)
                        return String.fromCharCode('a'.charCodeAt(0) + j) + (8 - i);
                    }
                }
            }
            return null; // Não deveria acontecer em um jogo normal
        }

        // Implementar uma função de busca seletiva que avalia apenas os movimentos mais promissores
        function minimaxRoot(depth, isMaximizingPlayer) {
            const moves = game.moves({ verbose: true });
            
            // Fase 1: Avaliar todos os movimentos possíveis na primeira camada
            const evaluatedMoves = [];
            
            for (const move of moves) {
                game.move(move.san);
                // Avaliação superficial (profundidade 1)
                const score = evaluateBoard(game.board(), game.turn());
                game.undo();
                
                evaluatedMoves.push({
                    move: move,
                    score: score
                });
            }
            
            // Ordenar os movimentos
            // Para o jogador maximizador (brancas), ordenamos do maior para o menor
            // Para o jogador minimizador (pretas), ordenamos do menor para o maior
            evaluatedMoves.sort((a, b) => {
                return isMaximizingPlayer ? b.score - a.score : a.score - b.score;
            });
            
            // Selecionar apenas os N melhores movimentos
            const bestMoves = evaluatedMoves.slice(0, Math.min(BEAM_WIDTH, evaluatedMoves.length));
            
            // Fase 2: Explorar com profundidade total apenas os melhores movimentos
            let bestMoveFound = null;
            let bestScore = isMaximizingPlayer ? -Infinity : Infinity;
            
            for (const moveObj of bestMoves) {
                game.move(moveObj.move.san);
                // Agora explorar com profundidade total usando seletividade em cada nível
                const value = selectiveSearch(depth - 1, -Infinity, Infinity, !isMaximizingPlayer, BEAM_WIDTH);
                game.undo();
                
                // Atualizar o melhor movimento
                if (isMaximizingPlayer) {
                    if (value > bestScore) {
                        bestScore = value;
                        bestMoveFound = moveObj.move;
                    }
                } else {
                    if (value < bestScore) {
                        bestScore = value;
                        bestMoveFound = moveObj.move;
                    }
                }
            }
            
            // Se por algum motivo não encontrarmos o melhor movimento
            if (bestMoveFound === null && moves.length > 0) {
                return moves[0];
            }
            
            return bestMoveFound;
        }

        // Modificar a função selectiveSearch para considerar capturas como movimentos prioritários
        function selectiveSearch(depth, alpha, beta, isMaximizingPlayer, beamWidth) {
            // Caso base: fim da recursão
            if (depth === 0 || game.game_over()) {
                return evaluateBoard(game.board(), game.turn());
            }
            
            const moves = game.moves({ verbose: true });
            
            // Se estivermos no último nível ou houver poucos movimentos, avaliar todos
            if (depth === 1 || moves.length <= beamWidth) {
                return minimax(depth, alpha, beta, isMaximizingPlayer);
            }
            
            // Separar movimentos de captura e não-captura
            const captureMoves = [];
            const nonCaptureMoves = [];
            
            for (const move of moves) {
                if (move.flags.includes('c')) {
                    captureMoves.push(move);
                } else {
                    nonCaptureMoves.push(move);
                }
            }
            
            // Avaliar superficialmente todos os movimentos neste nível
            const evaluatedCaptures = [];
            const evaluatedNonCaptures = [];
            
            // Avaliar capturas
            for (const move of captureMoves) {
                game.move(move);
                // Avaliação superficial
                const score = evaluateBoard(game.board(), game.turn());
                game.undo();
                
                evaluatedCaptures.push({
                    move: move,
                    score: score
                });
            }
            
            // Avaliar não-capturas
            for (const move of nonCaptureMoves) {
                game.move(move);
                // Avaliação superficial
                const score = evaluateBoard(game.board(), game.turn());
                game.undo();
                
                evaluatedNonCaptures.push({
                    move: move,
                    score: score
                });
            }
            
            // Ordenar os movimentos
            evaluatedCaptures.sort((a, b) => {
                return isMaximizingPlayer ? b.score - a.score : a.score - b.score;
            });
            
            evaluatedNonCaptures.sort((a, b) => {
                return isMaximizingPlayer ? b.score - a.score : a.score - b.score;
            });
            
            // Selecionar os melhores movimentos, priorizando capturas
            let bestMoves = [];
            
            // Adicionar todas as capturas (ou até o limite de beam width)
            bestMoves = bestMoves.concat(evaluatedCaptures.slice(0, beamWidth));
            
            // Adicionar os melhores movimentos não-captura até completar o beam width
            if (bestMoves.length < beamWidth) {
                bestMoves = bestMoves.concat(
                    evaluatedNonCaptures.slice(0, beamWidth - bestMoves.length)
                );
            }
            
            // Agora que temos os melhores movimentos, aplicamos o minimax tradicional
            if (isMaximizingPlayer) {
                let bestScore = -Infinity;
                
                for (const moveObj of bestMoves) {
                    game.move(moveObj.move);
                    const score = selectiveSearch(depth - 1, alpha, beta, false, beamWidth);
                    game.undo();
                    
                    bestScore = Math.max(bestScore, score);
                    alpha = Math.max(alpha, bestScore);
                    
                    if (beta <= alpha) {
                        break; // Poda alpha-beta
                    }
                }
                
                return bestScore;
            } else {
                let bestScore = Infinity;
                
                for (const moveObj of bestMoves) {
                    game.move(moveObj.move);
                    const score = selectiveSearch(depth - 1, alpha, beta, true, beamWidth);
                    game.undo();
                    
                    bestScore = Math.min(bestScore, score);
                    beta = Math.min(beta, bestScore);
                    
                    if (beta <= alpha) {
                        break; // Poda alpha-beta
                    }
                }
                
                return bestScore;
            }
        }

        // Manter a função minimax original para os níveis mais profundos
        function minimax(depth, alpha, beta, isMaximizingPlayer) {
            if (depth === 0 || game.game_over()) {
                return evaluateBoard(game.board(), game.turn());
            }
            
            const moves = game.moves();
            
            if (isMaximizingPlayer) {
                let bestScore = -Infinity;
                
                for (const move of moves) {
                    game.move(move);
                    const score = minimax(depth - 1, alpha, beta, false);
                    game.undo();
                    
                    bestScore = Math.max(bestScore, score);
                    alpha = Math.max(alpha, bestScore);
                    
                    if (beta <= alpha) {
                        break; // Poda alpha-beta
                    }
                }
                
                return bestScore;
            } else {
                let bestScore = Infinity;
                
                for (const move of moves) {
                    game.move(move);
                    const score = minimax(depth - 1, alpha, beta, true);
                    game.undo();
                    
                    bestScore = Math.min(bestScore, score);
                    beta = Math.min(beta, bestScore);
                    
                    if (beta <= alpha) {
                        break; // Poda alpha-beta
                    }
                }
                
                return bestScore;
            }
        }

        // --- Funções de Controle do Jogo ---

        function makeAIMove() {
            if (game.game_over()) return;

            // Calculate the hash (returns BigInt)
            const currentHash = computePolyglotHash(game);
            console.log("Calculated Polyglot Hash for lookup:", currentHash);

            // Look up using the BigInt hash
            const entries = openingBook.get(currentHash);
            //console.log("Book entries found for this hash:", entries);

            if (entries && entries.length > 0) {
                // Filter entries to find valid moves in the *current* position
                const validBookMoves = [];
                const legalMovesSAN = new Set(game.moves()); // Get legal moves in SAN format

                for (const entry of entries) {
                    const uciMove = decodePolyglotMove(entry.move);
                    // Attempt to convert UCI to SAN or directly validate
                    let moveSAN = null;
                    try {
                        // Chess.js doesn't have a direct UCI -> SAN if move is ambiguous
                        // We need to find the matching SAN move among legal moves
                            const possibleMoves = game.moves({ verbose: true });
                            const targetMove = possibleMoves.find(m => m.from + m.to === uciMove.substring(0, 4) && (!m.promotion || m.promotion === uciMove.substring(4)));

                            if (targetMove) {
                            moveSAN = targetMove.san;
                            } else {
                            console.warn(`Could not find legal SAN match for book UCI move: ${uciMove}`);
                            }

                    } catch (e) {
                            console.warn(`Error trying to process book UCI move ${uciMove}:`, e);
                    }


                    if (moveSAN && legalMovesSAN.has(moveSAN)) {
                        // Check if this specific move (decoded) is legal in the current position
                            validBookMoves.push(entry);
                        console.log(`Book move ${moveSAN} (${uciMove}) is legal.`);
                    } else {
                        console.log(`Book move ${moveSAN} (${uciMove}) is NOT currently legal.`);
                    }
                }


                if (validBookMoves.length > 0) {
                    const selectedEntry = weightedChoice(validBookMoves); // Use weighted choice on *valid* moves
                    const uciMoveToPlay = decodePolyglotMove(selectedEntry.move);

                    console.log(`Playing move from opening book: ${uciMoveToPlay}`);

                        // Use chess.js move function with the 'from' and 'to' parts
                    const moveResult = game.move({
                            from: uciMoveToPlay.substring(0, 2),
                            to: uciMoveToPlay.substring(2, 4),
                            promotion: uciMoveToPlay.length > 4 ? uciMoveToPlay.substring(4) : undefined
                        });

                        if (moveResult) {
                        playMoveSound();
                        highlightMove(moveResult.from, moveResult.to); // Highlight using result
                        board.position(game.fen());
                        updateStatus();
                        // Check for captured piece after the move
                        if (moveResult.captured) {
                            const capturedColor = moveResult.color === 'w' ? 'b' : 'w'; // Opposite color was captured
                            console.log("Book move captured:", capturedColor, moveResult.captured);
                            capturedPieces[capturedColor].push(moveResult.captured);
                            updateCapturedPieces();
                            }
                        return; // Exit after playing book move
                    } else {
                            console.error(`Failed to execute validated book move: ${uciMoveToPlay}`);
                            // Fall through to minimax if execution fails unexpectedly
                        }
                } else {
                        console.log("No *valid* book moves found for this hash, using Minimax.");
                }
            } else {
                console.log("Hash not found in opening book, using Minimax.");
            }


            // --- Fallback to Minimax (rest of your makeAIMove logic) ---
            console.log("AI: Falling back to Minimax/other logic.");
            // (Your existing Minimax call logic here...)
             var depth = parseInt(document.getElementById('difficulty').value);
             setThinkingStatus(true);
             window.setTimeout(function() {
                var move = minimaxRoot(depth, false); // Black is minimizer (false)
                setThinkingStatus(false);

                if (move) {
                    const moveResult = game.move(move.san); // Make the move using SAN
                    if (moveResult) {
                        playMoveSound();
                        highlightMove(moveResult.from, moveResult.to);
                        if (moveResult.captured) {
                             const capturedColor = moveResult.color === 'w' ? 'b' : 'w';
                             console.log("Minimax captured:", capturedColor, moveResult.captured);
                             capturedPieces[capturedColor].push(moveResult.captured);
                             updateCapturedPieces();
                        }
                         board.position(game.fen());
                         updateStatus();
                    } else {
                         console.error("AI Minimax chose an illegal move?", move.san, game.fen());
                    }
                 } else {
                    console.error("AI Minimax failed to find a move! State:", game.fen(), game.game_over());
                }
                // Ensure status is updated even if minimax fails
                 updateStatus();
             }, 250); // Keep a small delay
        }

        // Função setThinkingStatus (sem alterações)
        function setThinkingStatus(isThinking) {
            const statusElement = document.getElementById('status');
            if (isThinking) {
                statusElement.textContent = "IA está pensando...";
            } else {
                 updateStatus(); // Restaura o status normal
            }
        }

        // Função auxiliar para obter o nome correto da peça para a URL da imagem
        function getPieceName(pieceName) {
            return pieceName.toUpperCase().slice(-1);
        }

        // Função atualizada para exibir as peças capturadas
        function updateCapturedPieces() {
            const blackCaptured = document.getElementById('blackCaptured');
            const whiteCaptured = document.getElementById('whiteCaptured');

            debug("Estado atual das peças capturadas:", JSON.stringify(capturedPieces, undefined, 4));
            
            blackCaptured.innerHTML = '';
            whiteCaptured.innerHTML = '';
            
            capturedPieces.b.forEach(piece => {
                const img = document.createElement('img');
                img.src = `../assets/images/b${getPieceName(piece)}.png`;
                img.classList.add('captured-piece');
                blackCaptured.appendChild(img);
            });
            
            capturedPieces.w.forEach(piece => {
                const img = document.createElement('img');
                img.src = `../assets/images/w${getPieceName(piece)}.png`;
                img.classList.add('captured-piece');
                whiteCaptured.appendChild(img);
            });
        }

        // Função para remover highlights anteriores
        function removeHighlights() {
            $('#myBoard .square-55d63').removeClass('highlight-white');
            $('#myBoard .square-55d63').removeClass('highlight-black');
        }

        // Função para destacar um movimento
        function highlightMove(source, target) {
            removeHighlights();
            $('#myBoard .square-' + source).addClass('highlight-white');
            $('#myBoard .square-' + target).addClass('highlight-black');
        }

        // Função para remover highlights de movimentos possíveis
        function removeLegalMoveHighlights() {
            $('#myBoard .square-55d63').removeClass('highlight-legal-move');
        }

        // Função para mostrar movimentos possíveis
        function showLegalMoves(square) {
            // Obter movimentos possíveis para a peça
            const moves = game.moves({
                square: square,
                verbose: true
            });

            // Destacar cada movimento possível
            moves.forEach(move => {
                $(`#myBoard .square-${move.to}`).addClass('highlight-legal-move');
            });
        }

        // Modificar a função onDragStart para mostrar movimentos possíveis
        function onDragStart(source, piece, position, orientation) {
            // Remover highlights anteriores
            removeLegalMoveHighlights();
            
            // Não permitir mover se o jogo acabou ou não é a vez do jogador
            if (game.game_over() || game.turn() !== playerColor || piece.search(/^b/) !== -1) {
                return false;
            }

            // Mostrar movimentos possíveis
            showLegalMoves(source);
        }

        // Modificar a função onDrop para limpar os highlights
        function onDrop(source, target) {
            // Remover highlights de movimentos possíveis
            removeLegalMoveHighlights();

            const capturedPiece = game.get(target);
            
            var move = game.move({ 
                from: source, 
                to: target, 
                promotion: 'q'
            });

            if (move === null) return 'snapback';

            // Tocar som do movimento
            playMoveSound();

            // Destacar o movimento do jogador
            highlightMove(source, target);

            if (capturedPiece) {
                const color = capturedPiece.color;
                const type = capturedPiece.type;
                debug("Peça capturada:", color, type);
                capturedPieces[color].push(type);
                updateCapturedPieces();
            }

            updateStatus();
            console.log("updateStatus");

            if (!game.game_over() && game.turn() === aiColor) {
                // Adiciona delay consistente para os primeiros movimentos
                // if (game.history().length <= 4) { // Primeiros 2 lances de cada lado
                //     setTimeout(() => {
                //         const possibleMoves = game.moves();
                //         const randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                        
                //         game.move(randomMove);
                //         playMoveSound();
                        
                //         // Destacar o movimento aleatório da IA
                //         const lastMove = game.history({verbose: true})[game.history().length - 1];
                //         highlightMove(lastMove.from, lastMove.to);
                        
                //         board.position(game.fen());
                //         updateStatus();
                //     }, 400);
                // } else {
                    makeAIMove();
                //}
            }

            return true; // Evita comportamento inesperado
        }

        // Atualiza o status do jogo (turno, xeque, etc.)
        function updateStatus() {
            let status = '';
            let gameEnded = false;

            if (game.in_checkmate()) {
                // Verifica quem ganhou
                const winner = game.turn() === 'w' ? 'Pretas' : 'Brancas';
                status = `Fim de jogo, ${winner} venceram por xeque-mate`;
                gameEnded = true;
                
                // Toca o som apropriado
                if (winner === 'Brancas') {
                    victorySound.play().catch(error => debug("Erro ao tocar som de vitória:", error));
                } else {
                    defeatSound.play().catch(error => debug("Erro ao tocar som de derrota:", error));
                }
            }
            else if (game.in_draw()) {
                status = 'Fim de jogo, empate';
                gameEnded = true;
                defeatSound.play().catch(error => debug("Erro ao tocar som de empate:", error));
            }
            else if (game.in_stalemate()) {
                status = 'Fim de jogo, empate por afogamento';
                gameEnded = true;
                defeatSound.play().catch(error => debug("Erro ao tocar som de empate:", error));
            }
            else if (game.in_threefold_repetition()) {
                status = 'Fim de jogo, empate por tripla repetição';
                gameEnded = true;
                defeatSound.play().catch(error => debug("Erro ao tocar som de empate:", error));
            }
            else if (game.insufficient_material()) {
                status = 'Fim de jogo, empate por material insuficiente';
                gameEnded = true;
                defeatSound.play().catch(error => debug("Erro ao tocar som de empate:", error));
            }
            else {
                status = game.turn() === 'b' ? 'Turno: Pretas' : 'Turno: Brancas';
            }

            if (game.in_check()) {
                status += ' (XEQUE)';
            }

            document.getElementById('turn').textContent = status;
            
            // Se o jogo acabou, desabilita o tabuleiro
            if (gameEnded) {
                board.draggable = false;
            }
        }

        // Configuração inicial do chessboardjs
        var config = {
            draggable: true,
            position: 'start',
            onDragStart: onDragStart,
            onDrop: onDrop,
            onSnapEnd: function() {
                board.position(game.fen());
            },
            onMouseoutSquare: removeLegalMoveHighlights,
            onMouseoverSquare: function(square, piece) {
                // Mostrar movimentos possíveis apenas se for uma peça do jogador
                if (piece && piece.charAt(0) === playerColor) {
                    showLegalMoves(square);
                }
            },
            pieceTheme: '../assets/images/{piece}.png'
            //pieceTheme: 'https://chessboardjs.com/img/chesspieces/alpha/{piece}.png'
            //pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
        };

        board = Chessboard('myBoard', config); // Inicializa o tabuleiro

        // --- Event Listeners ---
        document.getElementById('newGameButton').addEventListener('click', function() {
            game = new Chess();
            board.position('start');
            board.draggable = true;
            loadingOverlay.classList.remove('active');
            capturedPieces.w = [];
            capturedPieces.b = [];
            updateCapturedPieces();
            updateStatus();
            removeHighlights();
            removeLegalMoveHighlights();
            document.getElementById('turn').textContent = 'Turno: Brancas';
            $('#myBoard .square-55d63').removeClass('highlight-check');
        });

        document.getElementById('difficulty').addEventListener('change', function(e) {
            currentDifficultyDepth = parseInt(e.target.value);
            //console.log("Dificuldade alterada para Profundidade: " + currentDifficultyDepth);
            // Opcional: Reiniciar o jogo ao mudar a dificuldade?
            // game = new Chess();
            // board.position('start');
            // updateStatus();
        });

        // --- Inicialização ---
        $(window).resize(board.resize); // Torna o tabuleiro responsivo se a janela mudar de tamanho
        updateStatus(); // Define o status inicial

    </script>

</body>
</html>