<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lazy Gardener: Jardim Zen</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-family: sans-serif;
            color: #333;
        }

        #ui button {
            margin: 2px;
            padding: 5px 8px;
            cursor: pointer;
        }

        #notifications {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-family: sans-serif;
            font-size: 0.9em;
            max-width: 80%;
            display: none;
        }
    </style>
</head>

<body>
    <div id="ui">
        <button id="plantFlower">Flor (30s)</button>
        <button id="plantTree">√Årvore (60s)</button>
        <button id="plantPineTree">Pinheiro (120s)</button>
        <button id="plantMushroom">Cogumelo (20s)</button>
        <button id="plantBamboo">Bambu (40s)</button>
        <button id="plantBerryBush">Arbusto de Bagas (80s)</button>
        <button id="plantLotus">L√≥tus Flutuante (150s)</button>
        <button id="spawnAnimal">Atrair Animais üêæ</button>
        <div id="weatherStatus">Clima: Ensolarado ‚òÄÔ∏è</div>
        <div id="timeStatus">Hora: Dia ‚òÄÔ∏è</div>
    </div>
    <div id="notifications" role="alert"></div>
    <canvas id="gameCanvas"></canvas>
    <audio id="ambientSoundDay" loop src="../lazy_gardner/assets/birds-forest-spring.mp3" preload="auto"></audio>
    <audio id="ambientSoundNight" loop src="../lazy_gardner/assets/night-ambience.mp3" preload="auto"></audio>
    <audio id="rainSound" loop src="../lazy_gardner/assets/rain.mp3" preload="auto"></audio>
    <audio id="notificationSound" src="../lazy_gardner/assets/notification.mp3" preload="auto"></audio>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

        let scene, camera, renderer, ground, sky;
        let clouds = [], plants = [], animals = [], butterflies = [];
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        const clock = new THREE.Clock();
        let currentSeedType = null, simulatedWeather = 'sunny', timeOfDay = 'day', timeAccumulator = 0;

        const animalConfig = {
            rabbit: { speed: 2, color: 0xFFFFFF, diet: ['flower'], eatingDuration: 3 },
            squirrel: { speed: 3, color: 0xD2691E, diet: ['berrybush'], eatingDuration: 2 }
        };

        const timeSpeed = 0.5, dayDuration = 120;
        const growthTimes = {
            flower: { seed: 0, sprout: 5, bud: 15, bloom: 30 },
            tree: { seed: 0, sapling: 10, growing: 30, mature: 60 },
            pinetree: { seed: 0, sapling: 20, growing: 60, mature: 120, ancient: 180 },
            mushroom: { spore: 0, small: 5, grown: 20 },
            bamboo: { seed: 0, shoot: 5, cluster: 15, dense: 40 },
            berrybush: { seed: 0, sapling: 10, foliage: 35, berry: 80 },
            lotus: { spore: 0, pad: 40, bud: 100, bloom: 150 }
        };

        const weatherChangeInterval = 30;
        let timeSinceLastWeatherChange = 0;
        const flowerBloomColors = [0xFF69B4, 0xFFD700, 0xDA70D6, 0xFF4500, 0x4169E1, 0xFFFFFF];

        const uiElement = document.getElementById('ui');
        const notificationElement = document.getElementById('notifications');
        const weatherStatusElement = document.getElementById('weatherStatus');
        const timeStatusElement = document.getElementById('timeStatus');
        const ambientSoundDay = document.getElementById('ambientSoundDay');
        const ambientSoundNight = document.getElementById('ambientSoundNight');
        const rainSound = document.getElementById('rainSound');
        const notificationSound = document.getElementById('notificationSound');

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.bias = -0.001;
            directionalLight.shadow.normalBias = 0.05;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            scene.add(directionalLight.target);

            const fillLight = new THREE.DirectionalLight(0xffffcc, 0.3);
            fillLight.position.set(-5, 0, -5);
            scene.add(fillLight);

            // Sky Dome
            const skyGeo = new THREE.SphereGeometry(500, 32, 32);
            const skyMat = new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide });
            sky = new THREE.Mesh(skyGeo, skyMat);
            scene.add(sky);

            // Ground
            const groundGeo = new THREE.PlaneGeometry(100, 100);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.8 });
            ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onPointerDown);

            // UI Listeners
            document.getElementById('plantFlower').addEventListener('click', () => currentSeedType = 'flower');
            document.getElementById('plantTree').addEventListener('click', () => currentSeedType = 'tree');
            document.getElementById('plantPineTree').addEventListener('click', () => currentSeedType = 'pinetree');
            document.getElementById('plantMushroom').addEventListener('click', () => currentSeedType = 'mushroom');
            document.getElementById('plantBamboo').addEventListener('click', () => currentSeedType = 'bamboo');
            document.getElementById('plantBerryBush').addEventListener('click', () => currentSeedType = 'berrybush');
            document.getElementById('plantLotus').addEventListener('click', () => currentSeedType = 'lotus');
            document.getElementById('spawnAnimal').addEventListener('click', () => {
                const type = Math.random() < 0.5 ? 'rabbit' : 'squirrel';
                spawnAnimal(type);
            });

            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onPointerDown(event) {
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            const intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                const intersect = intersects[0];

                // Check if clicked on a plant (for harvesting/interaction)
                let obj = intersect.object;
                let plantData = null;
                while (obj) {
                    if (obj.userData && obj.userData.plantData) {
                        plantData = obj.userData.plantData;
                        break;
                    }
                    obj = obj.parent;
                }

                if (plantData) {
                    if (plantData.type === 'berrybush' && getPlantStages('berrybush')[plantData.growthStage] === 'berry') {
                        plantData.growthStage = 2; // Reset to foliage
                        scene.remove(plantData.mesh);
                        plantData.mesh = createPlantMesh(plantData);
                        if (plantData.mesh) {
                            plantData.mesh.position.copy(plantData.position);
                            if (plantData.mesh.type === 'Group') {
                                plantData.mesh.position.y = plantData.position.y;
                            } else {
                                plantData.mesh.position.y = plantData.position.y + (plantData.mesh.geometry?.parameters?.height / 2 || plantData.mesh.geometry?.parameters?.radius || 0.1);
                            }
                            plantData.mesh.castShadow = true;
                            plantData.mesh.userData.plantData = plantData;
                            scene.add(plantData.mesh);
                        }
                        showNotification("Voc√™ colheu as bagas! üçí", 2000);
                        return;
                    }
                    if (plantData.type === 'flower' && getPlantStages('flower')[plantData.growthStage] === 'bloom') {
                        showNotification("Que flor linda! üå∏", 2000);
                        return;
                    }
                }

                // Planting logic
                if (intersect.object === ground && currentSeedType) {
                    plantSeed(intersect.point, currentSeedType);
                    currentSeedType = null; // Reset selection
                }
            }
        }

        function plantSeed(position, type) {
            const sizeVariation = 0.85 + Math.random() * 0.3;

            const plantData = {
                id: THREE.MathUtils.generateUUID(),
                type: type,
                position: position.clone(),
                plantedTime: clock.getElapsedTime(),
                growthStage: 0,
                mesh: null,
                notifiedStages: {},
                sizeVariation: sizeVariation,
                bloomColor: type === 'flower' ? flowerBloomColors[Math.floor(Math.random() * flowerBloomColors.length)] : null
            };

            plantData.mesh = createPlantMesh(plantData);
            if (plantData.mesh) {
                plantData.mesh.position.copy(position);
                if (plantData.mesh.type === 'Group') {
                    plantData.mesh.position.y = position.y;
                } else {
                    plantData.mesh.position.y = position.y + (plantData.mesh.geometry?.parameters?.height / 2 || plantData.mesh.geometry?.parameters?.radius || 0.1);
                }
                plantData.mesh.castShadow = true;
                plantData.mesh.userData.plantData = plantData;
                scene.add(plantData.mesh);
                plants.push(plantData);
            }
        }

        function getPlantStages(type) {
            switch (type) {
                case 'flower': return ['seed', 'sprout', 'bud', 'bloom'];
                case 'tree': return ['seed', 'sapling', 'growing', 'mature'];
                case 'pinetree': return ['seed', 'sapling', 'growing', 'mature', 'ancient'];
                case 'mushroom': return ['spore', 'small', 'grown'];
                case 'bamboo': return ['seed', 'shoot', 'cluster', 'dense'];
                case 'berrybush': return ['seed', 'sapling', 'foliage', 'berry'];
                case 'lotus': return ['spore', 'pad', 'bud', 'bloom'];
                default: return [];
            }
        }

        function getGrowthDuration(type, stageName) {
            if (growthTimes[type] && growthTimes[type][stageName] !== undefined) {
                let duration = growthTimes[type][stageName];
                // Modificador de clima
                if (simulatedWeather === 'sunny' && type !== 'mushroom') duration *= 0.8;
                if (simulatedWeather === 'rainy' && type === 'mushroom') duration *= 0.7;
                if (simulatedWeather === 'rainy' && type === 'bamboo') duration *= 0.8;
                if (timeOfDay === 'day' && type === 'berrybush') duration *= 0.9;
                if (simulatedWeather === 'rainy' && type === 'lotus') duration *= 0.75;
                if (simulatedWeather === 'rainy' && type !== 'mushroom' && type !== 'bamboo' && type !== 'lotus') duration *= 1.2;
                return duration;
            }
            return Infinity;
        }

        function createCloudMesh() {
            const cloudGroup = new THREE.Group();
            const cloudMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff, flatShading: true, transparent: true, opacity: 0.9
            });

            const numBlobs = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < numBlobs; i++) {
                const radius = 1 + Math.random() * 1.5;
                const geometry = new THREE.SphereGeometry(radius, 8, 8);
                const blob = new THREE.Mesh(geometry, cloudMaterial);
                blob.position.set(
                    (Math.random() - 0.5) * 3,
                    (Math.random() - 0.5) * 1.5,
                    (Math.random() - 0.5) * 2
                );
                cloudGroup.add(blob);
            }
            return cloudGroup;
        }

        function addCloud() {
            const cloud = createCloudMesh();
            cloud.position.set(
                (Math.random() - 0.5) * 80,
                15 + Math.random() * 10,
                (Math.random() - 0.5) * 80
            );
            cloud.userData = {
                speed: 0.5 + Math.random() * 1.5
            };
            scene.add(cloud);
            clouds.push(cloud);
        }

        function updateClouds(deltaTime) {
            clouds.forEach(cloud => {
                cloud.position.x += cloud.userData.speed * deltaTime;
                if (cloud.position.x > 50) {
                    cloud.position.x = -50;
                    cloud.position.z = (Math.random() - 0.5) * 80;
                }
            });
        }

        function spawnAnimal(type) {
            const angle = Math.random() * Math.PI * 2;
            const distance = 10 + Math.random() * 10;
            const position = new THREE.Vector3(Math.cos(angle) * distance, 0, Math.sin(angle) * distance);

            const mesh = createAnimalMesh(type);
            mesh.position.copy(position);
            scene.add(mesh);

            const animal = {
                id: THREE.MathUtils.generateUUID(),
                type: type,
                mesh: mesh,
                state: 'wander',
                stateTimer: 0,
                targetPosition: null,
                targetPlant: null,
                hunger: 0
            };
            animals.push(animal);
            showNotification(`Um ${type === 'rabbit' ? 'coelho' : 'esquilo'} apareceu! üêæ`, 3000);
        }

        function updateAnimals(deltaTime) {
            animals.forEach(animal => {
                animal.stateTimer -= deltaTime;
                const config = animalConfig[animal.type];

                if (animal.state === 'idle') {
                    if (animal.stateTimer <= 0) {
                        animal.hunger += 10;
                        if (animal.hunger > 30) {
                            let closestPlant = null;
                            let minDist = Infinity;
                            plants.forEach(plant => {
                                if (config.diet.includes(plant.type)) {
                                    const stages = getPlantStages(plant.type);
                                    const currentStage = stages[plant.growthStage];
                                    let isEdible = false;
                                    if (animal.type === 'rabbit' && currentStage === 'bloom') isEdible = true;
                                    if (animal.type === 'squirrel' && currentStage === 'berry') isEdible = true;

                                    if (isEdible) {
                                        const dist = animal.mesh.position.distanceTo(plant.position);
                                        if (dist < minDist) { minDist = dist; closestPlant = plant; }
                                    }
                                }
                            });

                            if (closestPlant) {
                                animal.state = 'seek';
                                animal.targetPlant = closestPlant;
                                animal.targetPosition = closestPlant.position.clone();
                            } else {
                                animal.state = 'wander';
                                animal.targetPosition = new THREE.Vector3((Math.random() - 0.5) * 40, 0, (Math.random() - 0.5) * 40);
                                animal.stateTimer = 2 + Math.random() * 2;
                            }
                        } else {
                            animal.state = 'wander';
                            animal.targetPosition = new THREE.Vector3((Math.random() - 0.5) * 40, 0, (Math.random() - 0.5) * 40);
                            animal.stateTimer = 2 + Math.random() * 2;
                        }
                    }
                } else if (animal.state === 'wander') {
                    if (animal.stateTimer <= 0) {
                        animal.state = 'idle';
                        animal.stateTimer = 1 + Math.random() * 2;
                    } else {
                        const direction = new THREE.Vector3().subVectors(animal.targetPosition, animal.mesh.position).normalize();
                        animal.mesh.position.add(direction.multiplyScalar(config.speed * deltaTime));
                        animal.mesh.lookAt(animal.targetPosition);
                        if (animal.mesh.position.distanceTo(animal.targetPosition) < 0.5) {
                            animal.state = 'idle';
                            animal.stateTimer = 1;
                        }
                    }
                } else if (animal.state === 'seek') {
                    if (!animal.targetPlant || !plants.includes(animal.targetPlant)) {
                        animal.state = 'idle';
                        return;
                    }
                    const direction = new THREE.Vector3().subVectors(animal.targetPosition, animal.mesh.position).normalize();
                    animal.mesh.position.add(direction.multiplyScalar(config.speed * deltaTime));
                    animal.mesh.lookAt(animal.targetPosition);

                    if (animal.mesh.position.distanceTo(animal.targetPosition) < 1.0) {
                        animal.state = 'eat';
                        animal.stateTimer = config.eatingTime;
                    }
                } else if (animal.state === 'eat') {
                    if (animal.stateTimer <= 0) {
                        if (animal.targetPlant && plants.includes(animal.targetPlant)) {
                            if (animal.targetPlant.type === 'flower') {
                                animal.targetPlant.growthStage = 0;
                            } else if (animal.targetPlant.type === 'berrybush') {
                                animal.targetPlant.growthStage = 2;
                            }

                            scene.remove(animal.targetPlant.mesh);
                            animal.targetPlant.mesh = createPlantMesh(animal.targetPlant);
                            if (animal.targetPlant.mesh) {
                                animal.targetPlant.mesh.position.copy(animal.targetPlant.position);
                                if (animal.targetPlant.mesh.type === 'Group') {
                                    animal.targetPlant.mesh.position.y = animal.targetPlant.position.y;
                                } else {
                                    animal.targetPlant.mesh.position.y = animal.targetPlant.position.y + (animal.targetPlant.mesh.geometry?.parameters?.height / 2 || 0.1);
                                }
                                animal.targetPlant.mesh.castShadow = true;
                                animal.targetPlant.mesh.userData.plantData = animal.targetPlant;
                                scene.add(animal.targetPlant.mesh);
                            }
                            animal.hunger = 0;
                            showNotification(`${animal.type === 'rabbit' ? 'Coelho' : 'Esquilo'} comeu! üòã`, 2000);
                        }
                        animal.state = 'idle';
                        animal.stateTimer = 1;
                        animal.targetPlant = null;
                    }
                }
            });
        }

        function createAnimalMesh(type) {
            const mesh = new THREE.Group();
            const material = new THREE.MeshStandardMaterial({ color: animalConfig[type].color, roughness: 0.8 });

            if (type === 'rabbit') {
                const bodyGeo = new THREE.SphereGeometry(0.2, 8, 8);
                const body = new THREE.Mesh(bodyGeo, material);
                body.position.y = 0.2;
                mesh.add(body);

                const headGeo = new THREE.SphereGeometry(0.12, 8, 8);
                const head = new THREE.Mesh(headGeo, material);
                head.position.set(0.15, 0.35, 0);
                mesh.add(head);

                const earGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.15, 4);
                const ear1 = new THREE.Mesh(earGeo, material);
                ear1.position.set(0.15, 0.5, 0.05);
                ear1.rotation.z = -0.2;
                mesh.add(ear1);

                const ear2 = new THREE.Mesh(earGeo, material);
                ear2.position.set(0.15, 0.5, -0.05);
                ear2.rotation.z = -0.2;
                mesh.add(ear2);
            } else if (type === 'squirrel') {
                const bodyGeo = new THREE.CapsuleGeometry(0.15, 0.3, 4, 8);
                const body = new THREE.Mesh(bodyGeo, material);
                body.rotation.z = Math.PI / 4;
                body.position.y = 0.2;
                mesh.add(body);

                const headGeo = new THREE.SphereGeometry(0.1, 8, 8);
                const head = new THREE.Mesh(headGeo, material);
                head.position.set(0.2, 0.35, 0);
                mesh.add(head);

                const tailGeo = new THREE.CylinderGeometry(0.05, 0.1, 0.4, 8);
                const tail = new THREE.Mesh(tailGeo, material);
                tail.position.set(-0.2, 0.3, 0);
                tail.rotation.z = -Math.PI / 4;
                mesh.add(tail);
            }

            mesh.castShadow = true;
            return mesh;
        }

        function createPlantMesh(plantData) {
            const stages = getPlantStages(plantData.type);
            const stageName = stages[plantData.growthStage];
            let geometry, material, mesh;
            const sizeVariation = plantData.sizeVariation || 1.0;

            switch (plantData.type) {
                case 'flower':
                    material = new THREE.MeshStandardMaterial({ roughness: 0.8 });
                    if (stageName === 'seed') {
                        geometry = new THREE.SphereGeometry(0.08 * sizeVariation, 8, 6);
                        material.color.set(0x8B4513);
                    } else if (stageName === 'sprout') {
                        geometry = new THREE.ConeGeometry(0.12 * sizeVariation, 0.3 * sizeVariation, 8);
                        material.color.set(0x90EE90);
                        mesh = new THREE.Mesh(geometry, material);
                        mesh.position.y = 0.15 * sizeVariation;
                        return mesh;
                    } else if (stageName === 'bud') {
                        geometry = new THREE.SphereGeometry(0.2 * sizeVariation, 8, 6);
                        material.color.set(0xFFC0CB);
                    } else {
                        geometry = new THREE.SphereGeometry(0.3 * sizeVariation, 16, 12);
                        material.color.set(plantData.bloomColor || 0xFF69B4);
                    }
                    break;

                case 'tree':
                    material = new THREE.MeshStandardMaterial({ roughness: 0.8 });
                    const trunkHeight = [0.1, 0.8, 1.5, 3.0][plantData.growthStage] * sizeVariation;
                    const trunkRadius = [0.05, 0.1, 0.2, 0.4][plantData.growthStage] * sizeVariation;
                    const leavesRadius = [0.1, 0.5, 1.0, 1.8][plantData.growthStage] * sizeVariation;
                    const leavesColor = stageName === 'seed' ? 0x8B4513 : 0x006400;

                    const trunkGeo = new THREE.CylinderGeometry(trunkRadius * 0.8, trunkRadius, trunkHeight, 8);
                    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                    const trunkMesh = new THREE.Mesh(trunkGeo, trunkMat);
                    trunkMesh.castShadow = true;
                    trunkMesh.position.y = trunkHeight / 2;

                    mesh = new THREE.Group();
                    mesh.add(trunkMesh);

                    if (stageName !== 'seed') {
                        const leavesGeo = new THREE.SphereGeometry(leavesRadius, 16, 12);
                        const colorVariation = -0.1 + Math.random() * 0.2;
                        const baseColor = new THREE.Color(leavesColor);
                        baseColor.r = Math.max(0, Math.min(1, baseColor.r * (1 + colorVariation * 0.3)));
                        baseColor.g = Math.max(0, Math.min(1, baseColor.g * (1 + colorVariation)));
                        baseColor.b = Math.max(0, Math.min(1, baseColor.b * (1 + colorVariation * 0.3)));
                        const leavesMat = new THREE.MeshStandardMaterial({ color: baseColor });
                        const leavesMesh = new THREE.Mesh(leavesGeo, leavesMat);
                        leavesMesh.castShadow = true;
                        leavesMesh.position.y = trunkHeight + leavesRadius * 0.7;
                        mesh.add(leavesMesh);
                    }
                    return mesh;

                case 'pinetree':
                    material = new THREE.MeshStandardMaterial({ roughness: 0.8 });
                    const pineHeight = [0.1, 1.5, 3.0, 6.0, 11.0][plantData.growthStage] * sizeVariation;
                    const pineTrunkRadius = [0.05, 0.1, 0.2, 0.35, 0.5][plantData.growthStage] * sizeVariation;
                    const pineTrunkColor = 0x5C4033;

                    const pineTrunkGeo = new THREE.CylinderGeometry(pineTrunkRadius * 0.8, pineTrunkRadius, pineHeight, 10);
                    const pineTrunkMat = new THREE.MeshStandardMaterial({ color: pineTrunkColor });
                    const pineTrunkMesh = new THREE.Mesh(pineTrunkGeo, pineTrunkMat);
                    pineTrunkMesh.castShadow = true;
                    pineTrunkMesh.position.y = pineHeight / 2;

                    mesh = new THREE.Group();
                    mesh.add(pineTrunkMesh);

                    if (stageName !== 'seed') {
                        const numLayers = plantData.growthStage === 1 ? 1 : plantData.growthStage === 2 ? 3 : plantData.growthStage === 3 ? 4 : 5;
                        let pineGreen = plantData.growthStage === 4 ? 0x1A4D2E : 0x2E8B57;
                        const colorVariation = -0.1 + Math.random() * 0.2;
                        const baseColor = new THREE.Color(pineGreen);
                        baseColor.g = Math.max(0, Math.min(1, baseColor.g * (1 + colorVariation)));
                        baseColor.b = Math.max(0, Math.min(1, baseColor.b * (1 + colorVariation * 0.5)));
                        pineGreen = baseColor;

                        for (let i = 0; i < numLayers; i++) {
                            const layerVariation = 0.95 + Math.random() * 0.1;
                            const layerHeight = pineHeight * (0.45 - i * 0.05) * layerVariation;
                            const layerRadius = pineHeight * (0.35 - i * 0.03) * layerVariation;
                            const layerY = pineHeight * (stageName === 'ancient' ? (0.5 + i * 0.12) : (0.55 + i * 0.15));

                            const coneGeo = new THREE.ConeGeometry(layerRadius, layerHeight, 10);
                            const coneMat = new THREE.MeshStandardMaterial({ color: pineGreen, roughness: 0.9, flatShading: true });
                            const coneMesh = new THREE.Mesh(coneGeo, coneMat);
                            coneMesh.castShadow = true;
                            coneMesh.position.y = layerY;
                            mesh.add(coneMesh);
                        }

                        if (stageName === 'ancient') {
                            const barkDetails = 15 + Math.floor(Math.random() * 10);
                            for (let i = 0; i < barkDetails; i++) {
                                const barkSize = (0.1 + Math.random() * 0.2) * sizeVariation;
                                const barkGeo = new THREE.BoxGeometry(barkSize, barkSize * 0.5, barkSize);
                                const barkMat = new THREE.MeshStandardMaterial({ color: 0x4B3621, roughness: 1.0 });
                                const barkMesh = new THREE.Mesh(barkGeo, barkMat);
                                const angle = Math.random() * Math.PI * 2;
                                const trunkOffset = pineTrunkRadius * 0.9;
                                const height = Math.random() * pineHeight * 0.8;
                                barkMesh.position.set(Math.cos(angle) * trunkOffset, height, Math.sin(angle) * trunkOffset);
                                barkMesh.rotation.set(Math.random() * 0.5, Math.random() * Math.PI * 2, Math.random() * 0.5);
                                mesh.add(barkMesh);
                            }
                        }
                    }
                    return mesh;

                case 'mushroom':
                    material = new THREE.MeshStandardMaterial({ roughness: 0.7 });
                    const mushStemHeight = [0.05, 0.2, 0.4][plantData.growthStage] * sizeVariation;
                    const mushCapRadius = [0.05, 0.25, 0.5][plantData.growthStage] * sizeVariation;

                    const stemHue = Math.random() * 0.1;
                    const stemColor = new THREE.Color(0xFFFACD).lerp(new THREE.Color(0xFFF0C0), stemHue);

                    const capHue = Math.random() * 0.2;
                    const baseCapColor = stageName === 'spore' ? 0xD2B48C : 0xDC143C;
                    const capColor = new THREE.Color(baseCapColor).lerp(stageName === 'spore' ? new THREE.Color(0xC2A478) : new THREE.Color(0xFF0000), capHue);

                    const stemGeo = new THREE.CylinderGeometry(mushStemHeight * 0.3, mushStemHeight * 0.4, mushStemHeight, 8);
                    const stemMat = new THREE.MeshStandardMaterial({ color: stemColor });
                    const stemMesh = new THREE.Mesh(stemGeo, stemMat);
                    stemMesh.castShadow = true;
                    stemMesh.position.y = mushStemHeight / 2;

                    mesh = new THREE.Group();
                    mesh.add(stemMesh);

                    if (stageName !== 'spore') {
                        const capGeo = new THREE.SphereGeometry(mushCapRadius, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
                        const capMat = new THREE.MeshStandardMaterial({ color: capColor });
                        const capMesh = new THREE.Mesh(capGeo, capMat);
                        capMesh.castShadow = true;
                        capMesh.position.y = mushStemHeight;
                        mesh.add(capMesh);
                    }
                    return mesh;

                case 'bamboo':
                    material = new THREE.MeshStandardMaterial({ roughness: 0.6 });
                    const bambooColor = 0x6B8E23;
                    if (stageName === 'seed') {
                        geometry = new THREE.SphereGeometry(0.05 * sizeVariation, 8, 6);
                        material.color.set(0x8B4513);
                    } else {
                        mesh = new THREE.Group();
                        const numStalks = stageName === 'shoot' ? 1 : (stageName === 'cluster' ? 4 : 10);
                        const heightBase = stageName === 'shoot' ? 0.5 : (stageName === 'cluster' ? 1.2 : 2.5);

                        for (let i = 0; i < numStalks; i++) {
                            const h = heightBase * (0.8 + Math.random() * 0.4) * sizeVariation;
                            const r = 0.03 * sizeVariation;
                            const stalkGeo = new THREE.CylinderGeometry(r, r, h, 6);
                            const stalkMat = new THREE.MeshStandardMaterial({ color: bambooColor });
                            const stalk = new THREE.Mesh(stalkGeo, stalkMat);
                            stalk.castShadow = true;

                            const offset = stageName === 'shoot' ? 0 : (0.1 + Math.random() * 0.2);
                            const angle = Math.random() * Math.PI * 2;
                            stalk.position.set(Math.cos(angle) * offset, h / 2, Math.sin(angle) * offset);
                            stalk.rotation.x = (Math.random() - 0.5) * 0.2;
                            stalk.rotation.z = (Math.random() - 0.5) * 0.2;
                            mesh.add(stalk);

                            if (stageName !== 'shoot') {
                                const numLeaves = stageName === 'cluster' ? 2 : 5;
                                for (let j = 0; j < numLeaves; j++) {
                                    const leafGeo = new THREE.ConeGeometry(0.05, 0.2, 4);
                                    const leafMat = new THREE.MeshStandardMaterial({ color: 0x9ACD32 });
                                    const leaf = new THREE.Mesh(leafGeo, leafMat);
                                    const leafH = Math.random() * h;
                                    leaf.position.set(0, leafH - h / 2, 0);
                                    leaf.rotation.z = Math.PI / 3;
                                    leaf.rotation.y = Math.random() * Math.PI * 2;
                                    stalk.add(leaf);
                                }
                            }
                        }
                        return mesh;
                    }
                    break;

                case 'berrybush':
                    material = new THREE.MeshStandardMaterial({ roughness: 0.8 });
                    if (stageName === 'seed') {
                        geometry = new THREE.SphereGeometry(0.06 * sizeVariation, 8, 6);
                        material.color.set(0x8B4513);
                    } else if (stageName === 'sapling') {
                        mesh = new THREE.Group();
                        const trunkGeo = new THREE.CylinderGeometry(0.02 * sizeVariation, 0.03 * sizeVariation, 0.4 * sizeVariation, 6);
                        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                        trunk.position.y = 0.2 * sizeVariation;
                        mesh.add(trunk);

                        const foliageGeo = new THREE.SphereGeometry(0.15 * sizeVariation, 8, 8);
                        const foliageMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
                        const foliage = new THREE.Mesh(foliageGeo, foliageMat);
                        foliage.position.y = 0.4 * sizeVariation;
                        mesh.add(foliage);
                        return mesh;
                    } else {
                        mesh = new THREE.Group();
                        const mainBushGeo = new THREE.SphereGeometry(0.5 * sizeVariation, 16, 12);
                        const bushColor = 0x006400;
                        const bushMat = new THREE.MeshStandardMaterial({ color: bushColor, roughness: 1.0 });
                        const mainBush = new THREE.Mesh(mainBushGeo, bushMat);
                        mainBush.position.y = 0.4 * sizeVariation;
                        mainBush.scale.y = 0.8;
                        mesh.add(mainBush);

                        if (stageName === 'berry') {
                            const numBerries = 10 + Math.floor(Math.random() * 10);
                            const berryGeo = new THREE.SphereGeometry(0.05 * sizeVariation, 6, 6);
                            const berryMat = new THREE.MeshStandardMaterial({ color: 0xFF0000, roughness: 0.4 });

                            for (let i = 0; i < numBerries; i++) {
                                const berry = new THREE.Mesh(berryGeo, berryMat);
                                const u = Math.random();
                                const v = Math.random();
                                const theta = 2 * Math.PI * u;
                                const phi = Math.acos(2 * v - 1);
                                const r = 0.45 * sizeVariation;
                                berry.position.set(
                                    r * Math.sin(phi) * Math.cos(theta),
                                    0.4 * sizeVariation + r * Math.sin(phi) * Math.sin(theta) * 0.8,
                                    r * Math.cos(phi)
                                );
                                mesh.add(berry);
                            }
                        }
                        return mesh;
                    }
                    break;

                case 'lotus':
                    material = new THREE.MeshStandardMaterial({ roughness: 0.5 });
                    if (stageName === 'spore') {
                        geometry = new THREE.SphereGeometry(0.04 * sizeVariation, 8, 6);
                        material.color.set(0x4B0082); // Indigo
                    } else {
                        mesh = new THREE.Group();
                        // Pad (Folha)
                        const padGeo = new THREE.CircleGeometry(0.3 * sizeVariation, 16);
                        const padMat = new THREE.MeshStandardMaterial({ color: 0x228B22, side: THREE.DoubleSide });
                        const pad = new THREE.Mesh(padGeo, padMat);
                        pad.rotation.x = -Math.PI / 2;
                        pad.position.y = 0.05; // Flutuando levemente
                        mesh.add(pad);

                        if (stageName === 'bud' || stageName === 'bloom') {
                            const budSize = stageName === 'bud' ? 0.1 : 0.25;
                            const budColor = 0xFF69B4; // HotPink
                            const budGeo = new THREE.SphereGeometry(budSize * sizeVariation, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2);
                            const budMat = new THREE.MeshStandardMaterial({ color: budColor });

                            if (stageName === 'bloom') {
                                budMat.emissive = new THREE.Color(0xFF1493); // Brilho base
                                budMat.emissiveIntensity = 0.2; // L√≥gica de brilho noturno ser√° tratada no updateTimeOfDay
                            }

                            const flower = new THREE.Mesh(budGeo, budMat);
                            flower.position.y = 0.05;
                            mesh.add(flower);
                        }
                        return mesh;
                    }
                    break;
            }

            if (!mesh && geometry) {
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.y = (geometry.parameters.height || geometry.parameters.radius * 2 || 0.2) / 2;
            }
            return mesh;
        }

        function updatePlantGrowth(deltaTime) {
            const currentTime = clock.getElapsedTime();
            plants.forEach(plant => {
                if (!plant.mesh) return;
                const stages = getPlantStages(plant.type);
                const currentStageName = stages[plant.growthStage];
                const timeElapsed = currentTime - plant.plantedTime;

                if (plant.growthStage < stages.length - 1) {
                    const nextStageName = stages[plant.growthStage + 1];
                    let cumulativeTime = 0;
                    for (let i = 1; i <= plant.growthStage + 1; i++) {
                        cumulativeTime += getGrowthDuration(plant.type, stages[i]);
                    }

                    if (timeElapsed >= cumulativeTime) {
                        plant.growthStage++;
                        const newStageName = stages[plant.growthStage];
                        console.log(`${plant.type} ${plant.id.substring(0, 4)} advanced to ${newStageName}`);

                        scene.remove(plant.mesh);
                        plant.mesh = createPlantMesh(plant);
                        if (plant.mesh) {
                            plant.mesh.position.copy(plant.position);
                            if (plant.mesh.type === 'Group') {
                                plant.mesh.position.y = plant.position.y;
                            } else {
                                plant.mesh.position.y = plant.position.y + (plant.mesh.geometry?.parameters?.height / 2 || plant.mesh.geometry?.parameters?.radius || 0.1);
                            }
                            plant.mesh.castShadow = true;
                            plant.mesh.userData.plantData = plant;
                            scene.add(plant.mesh);

                            if ((plant.type === 'flower' && newStageName === 'bloom') ||
                                (plant.type === 'tree' && newStageName === 'mature') ||
                                (plant.type === 'pinetree' && (newStageName === 'mature' || newStageName === 'ancient')) ||
                                (plant.type === 'mushroom' && newStageName === 'grown') ||
                                (plant.type === 'bamboo' && newStageName === 'dense') ||
                                (plant.type === 'berrybush' && newStageName === 'berry') ||
                                (plant.type === 'lotus' && newStageName === 'bloom')) {
                                if (!plant.notifiedStages[newStageName]) {
                                    const messages = {
                                        'flower': `Sua ${plant.type} desabrochou! üå∏`,
                                        'tree': `Sua ${plant.type} est√° madura! üå≥`,
                                        'pinetree': newStageName === 'ancient' ? `Seu pinheiro se tornou uma √°rvore ancestral! üå≤` : `Seu pinheiro atingiu o tamanho m√°ximo! üå≤`,
                                        'mushroom': `Seu ${plant.type} cresceu! üçÑ`,
                                        'bamboo': `Seu bambuzal est√° denso! üéã`,
                                        'berrybush': `Seu arbusto deu frutos! üçí`,
                                        'lotus': `Sua l√≥tus desabrochou e brilha! ü™∑`
                                    };
                                    const message = plant.type === 'pinetree' ? messages['pinetree'] : messages[plant.type];
                                    showNotification(message, 5000);
                                    try { notificationSound.play(); } catch (e) { console.warn("Audio play failed", e); }
                                    plant.notifiedStages[newStageName] = true;
                                }
                            }
                        }
                    }
                }
            });
        }

        function updateWeather(deltaTime = 0) {
            timeSinceLastWeatherChange += deltaTime;
            if (timeSinceLastWeatherChange > weatherChangeInterval) {
                timeSinceLastWeatherChange = 0;
                const prevState = simulatedWeather;
                simulatedWeather = Math.random() < 0.7 ? 'sunny' : 'rainy';
                console.log(`Weather changed to: ${simulatedWeather}`);
                if (prevState !== simulatedWeather) {
                    updateAudio();
                    updateSkyColor();
                }
            }
            weatherStatusElement.textContent = `Clima: ${simulatedWeather === 'sunny' ? 'Ensolarado ‚òÄÔ∏è' : 'Chuva Leve üåßÔ∏è'}`;
        }

        function updateTimeOfDay(deltaTime) {
            timeAccumulator += deltaTime * timeSpeed;
            const cycleTime = timeAccumulator % dayDuration;
            const dayProgress = cycleTime / dayDuration;
            const prevTimeOfDay = timeOfDay;

            if (dayProgress < 0.45 || dayProgress > 0.95) {
                // Dia (0 - 0.45) e (0.95 - 1 -> amanhecer)
                timeOfDay = 'day';
            } else if (dayProgress >= 0.45 && dayProgress < 0.55) {
                // Crep√∫sculo (0.45 - 0.55)
                timeOfDay = 'evening';
            } else {
                // Noite (0.55 - 0.95)
                timeOfDay = 'night';
            }

            if (prevTimeOfDay !== timeOfDay) {
                console.log(`Time changed to: ${timeOfDay}`);
                updateAudio();
                updateSkyColor();

                // Se mudou de noite para outro per√≠odo, remove todos os vagalumes
                if (prevTimeOfDay === 'night' && timeOfDay !== 'night') {
                    for (let i = butterflies.length - 1; i >= 0; i--) {
                        scene.remove(butterflies[i]);
                    }
                    butterflies.length = 0;
                }
            }

            timeStatusElement.textContent = `Hora: ${timeOfDay === 'day' ? 'Dia ‚òÄÔ∏è' : (timeOfDay === 'evening' ? 'Entardecer üåá' : 'Noite üåô')}`;

            // Atualizar luz direcional (simular sol/lua)
            const sunAngle = dayProgress * Math.PI * 2 - Math.PI / 2; // Ciclo completo de 2PI, come√ßando do horizonte leste
            const light = scene.getObjectByProperty('isDirectionalLight', true);
            if (light) {
                light.position.set(Math.cos(sunAngle) * 15, Math.sin(sunAngle) * 10 + 5, 10); // Movimento no c√©u
                light.intensity = timeOfDay === 'night' ? 0.3 : (timeOfDay === 'evening' ? 0.8 : 1.5); // Mais fraco √† noite
                light.color.set(timeOfDay === 'night' ? 0xaaaaff : (timeOfDay === 'evening' ? 0xffccaa : 0xffffff)); // Cor da luz
                light.target.position.set(0, 0, 0); // Manter olhando para o centro
            }

            const ambient = scene.getObjectByProperty('isAmbientLight', true);
            if (ambient) {
                ambient.intensity = timeOfDay === 'night' ? 0.2 : (timeOfDay === 'evening' ? 0.4 : 0.6);
            }

            // Atualizar brilho da L√≥tus
            plants.forEach(plant => {
                if (plant.type === 'lotus' && plant.growthStage === 3 && plant.mesh) { // Bloom
                    // Encontrar a parte da flor (√∫ltimo filho adicionado)
                    const flower = plant.mesh.children[plant.mesh.children.length - 1];
                    if (flower && flower.material) {
                        flower.material.emissiveIntensity = timeOfDay === 'night' ? 1.0 : 0.2;
                    }
                }
            });
        }

        function updateSkyColor() {
            let skyCol = new THREE.Color(0x87CEEB); // Dia
            let groundCol = new THREE.Color(0x228B22); // Grama dia

            if (timeOfDay === 'evening') {
                skyCol.set(0xFF8C00); // Laranja
                groundCol.lerp(new THREE.Color(0x556B2F), 0.3); // Verde mais escuro
            } else if (timeOfDay === 'night') {
                skyCol.set(0x000033); // Azul escuro
                groundCol.set(0x1A4D2E); // Verde bem escuro
            }

            // Modificador de chuva
            if (simulatedWeather === 'rainy') {
                skyCol.lerp(new THREE.Color(0x778899), 0.6); // Cinza
                groundCol.lerp(new THREE.Color(0x1E5631), 0.4); // Verde mais escuro/molhado
            }

            if (sky && sky.material) {
                sky.material.color = skyCol;
            }
            if (ground && ground.material) {
                ground.material.color = groundCol;
            }
        }

        function updateButterflies(deltaTime) {
            if (timeOfDay !== 'night') return;

            // Adicionar novos vagalumes ocasionalmente
            if (butterflies.length < 15 && Math.random() < 0.05) { addFirefly(); }

            butterflies.forEach(firefly => {
                firefly.userData.angle += deltaTime * firefly.userData.speed;
                firefly.position.x += Math.cos(firefly.userData.angle) * 0.05;
                firefly.position.z += Math.sin(firefly.userData.angle) * 0.05;
                firefly.position.y += (Math.random() - 0.5) * 0.05;

                // Manter dentro dos limites
                if (firefly.position.y < 0.5) firefly.position.y = 0.5;
                if (firefly.position.y > 4) firefly.position.y = 4;
            });
        }

        function addFirefly() {
            const geometry = new THREE.SphereGeometry(0.05, 4, 4);
            const material = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
            const firefly = new THREE.Mesh(geometry, material);

            firefly.position.set(
                (Math.random() - 0.5) * 20,
                0.5 + Math.random() * 2,
                (Math.random() - 0.5) * 20
            );

            firefly.userData = {
                angle: Math.random() * Math.PI * 2,
                speed: 0.5 + Math.random()
            };

            scene.add(firefly);
            butterflies.push(firefly);
        }

        function showNotification(message, duration = 3000) {
            notificationElement.textContent = message;
            notificationElement.style.display = 'block';
            setTimeout(() => {
                notificationElement.style.display = 'none';
            }, duration);
        }

        function updateAudio() {
            // L√≥gica simples de √°udio baseada no estado
            if (simulatedWeather === 'rainy') {
                rainSound.volume = 0.5;
                if (rainSound.paused) rainSound.play().catch(e => { });
            } else {
                if (!rainSound.paused) rainSound.pause();
            }

            if (timeOfDay === 'day') {
                ambientSoundDay.volume = 0.3;
                if (ambientSoundDay.paused) ambientSoundDay.play().catch(e => { });
                if (!ambientSoundNight.paused) ambientSoundNight.pause();
            } else {
                ambientSoundNight.volume = 0.3;
                if (ambientSoundNight.paused) ambientSoundNight.play().catch(e => { });
                if (!ambientSoundDay.paused) ambientSoundDay.pause();
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();

            updatePlantGrowth(deltaTime);
            updateWeather(deltaTime);
            updateTimeOfDay(deltaTime);
            updateButterflies(deltaTime);
            updateClouds(deltaTime);
            updateAnimals(deltaTime);

            renderer.render(scene, camera);
        }

        // Iniciar
        init();

    </script>
</body>

</html>