<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lazy Gardener: Jardim Zen</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            /* C√©u inicial */
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-family: sans-serif;
            color: #333;
        }

        #ui button {
            margin: 2px;
            padding: 5px 8px;
            cursor: pointer;
        }

        #notifications {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-family: sans-serif;
            font-size: 0.9em;
            max-width: 80%;
            display: none;
            /* Come√ßa escondido */
        }
    </style>
</head>

<body>
    <div id="ui">
        <span>Plantar:</span>
        <button id="plantFlower">Flor (30s)</button>
        <button id="plantTree">√Årvore (60s)</button>
        <button id="plantPineTree">Pinheiro (120s)</button>
        <button id="plantMushroom">Cogumelo (20s)</button>
        <button id="plantBamboo">Bambu (40s)</button>
        <button id="plantBerryBush">Arbusto de Bagas (80s)</button>
        <button id="plantLotus">L√≥tus Flutuante (150s)</button>
        <br>
        <span id="weatherStatus">Clima: Ensolarado</span> |
        <span id="timeStatus">Hora: Dia</span>
    </div>

    <div id="notifications" role="alert"></div>

    <canvas id="gameCanvas"></canvas>

    <audio id="ambientSoundDay" loop src="../lazy_gardner/assets/birds-forest-spring.mp3" preload="auto"></audio>
    <audio id="ambientSoundNight" loop src="../lazy_gardner/assets/night-ambience.mp3" preload="auto"></audio>
    <audio id="rainSound" loop src="../lazy_gardner/assets/rain.mp3" preload="auto"></audio>
    <audio id="notificationSound" src="../lazy_gardner/assets/notification.mp3" preload="auto"></audio>

    <!-- Import map para Three.js (maneira moderna de importar m√≥dulos) -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

        // --- Configura√ß√£o Inicial ---
        let scene, camera, renderer;
        let ground, sky;
        let bearModel; // Vari√°vel para armazenar o modelo do urso
        const plants = [];
        const butterflies = [];
        const clouds = [];
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        const clock = new THREE.Clock();

        let currentSeedType = null; // 'flower', 'tree', 'mushroom'
        let simulatedWeather = 'sunny'; // 'sunny', 'rainy'
        let timeOfDay = 'day'; // 'day', 'night'
        let timeAccumulator = 0;
        const timeSpeed = 0.5; // Controla a velocidade da passagem do tempo (1 = normal)
        const dayDuration = 120; // Segundos para um ciclo dia/noite completo

        const growthTimes = { // Em segundos (reduzido para demonstra√ß√£o)
            flower: { seed: 0, sprout: 5, bud: 15, bloom: 30 },
            tree: { seed: 0, sapling: 10, growing: 30, mature: 60 },
            pinetree: { seed: 0, sapling: 20, growing: 60, mature: 120, ancient: 180 },
            mushroom: { spore: 0, small: 5, grown: 20 },
            bamboo: { seed: 0, shoot: 5, cluster: 15, dense: 40 },
            berrybush: { seed: 0, sapling: 10, foliage: 35, berry: 80 },
            lotus: { spore: 0, pad: 40, bud: 100, bloom: 150 }
        };

        const weatherChangeInterval = 30; // Mudar clima a cada 30 segundos
        let timeSinceLastWeatherChange = 0;

        const flowerBloomColors = [
            0xFF69B4, // HotPink (original)
            0xFFD700, // Gold
            0xDA70D6, // Orchid
            0xFF4500, // OrangeRed
            0x4169E1, // RoyalBlue
            0xFFFFFF  // White
        ];

        // Elementos da UI
        const uiElement = document.getElementById('ui');
        const notificationElement = document.getElementById('notifications');
        const weatherStatusElement = document.getElementById('weatherStatus');
        const timeStatusElement = document.getElementById('timeStatus');

        // Elementos de √Åudio
        const ambientSoundDay = document.getElementById('ambientSoundDay');
        const ambientSoundNight = document.getElementById('ambientSoundNight');
        const rainSound = document.getElementById('rainSound');
        const notificationSound = document.getElementById('notificationSound');

        function init() {
            // Cena
            scene = new THREE.Scene();
            // scene.background = new THREE.Color(0x87CEEB); // C√©u azul inicial

            // C√¢mera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // Habilitar sombras
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Sombras mais suaves
            renderer.outputEncoding = THREE.sRGBEncoding; // Importante para texturas
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // Melhor reprodu√ß√£o de cores
            renderer.toneMappingExposure = 1.0; // Ajuste da exposi√ß√£o

            // Luzes
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2); // Reduzir um pouco a intensidade
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true;

            // Melhorar configura√ß√µes de sombra
            directionalLight.shadow.mapSize.width = 2048; // Aumentar resolu√ß√£o
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.bias = -0.001; // Corrigir artefatos de sombra
            directionalLight.shadow.normalBias = 0.05; // Ajuda com acne de sombra em modelos

            // Ajustar a √°rea da sombra
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;

            scene.add(directionalLight);
            scene.add(directionalLight.target);

            // Adicionar uma luz suave de preenchimento do lado oposto para evitar sombras muito duras
            const fillLight = new THREE.DirectionalLight(0xffffcc, 0.3); // Luz amarelada suave
            fillLight.position.set(-5, 8, -7.5); // Posi√ß√£o oposta √† luz principal
            scene.add(fillLight);

            // Ch√£o (Ground)
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, side: THREE.DoubleSide }); // Verde grama
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2; // Deitar o plano
            ground.receiveShadow = true;
            scene.add(ground);

            // Sky Dome (Simples)
            const skyGeometry = new THREE.SphereGeometry(500, 32, 16); // Raio grande
            const skyMaterial = new THREE.MeshBasicMaterial({ side: THREE.BackSide }); // Material vis√≠vel por dentro
            sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
            updateSkyColor(); // Definir cor inicial

            // --- Create initial clouds ---
            for (let i = 0; i < 20; i++) {
                addCloud();
            }

            // --- Event Listeners ---
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onPointerDown); // Usar pointerdown para mouse e toque

            document.getElementById('plantFlower').addEventListener('click', () => setSeedType('flower'));
            document.getElementById('plantTree').addEventListener('click', () => setSeedType('tree'));
            document.getElementById('plantPineTree').addEventListener('click', () => setSeedType('pinetree'));
            document.getElementById('plantMushroom').addEventListener('click', () => setSeedType('mushroom'));
            document.getElementById('plantBamboo').addEventListener('click', () => setSeedType('bamboo'));
            document.getElementById('plantBerryBush').addEventListener('click', () => setSeedType('berrybush'));
            document.getElementById('plantLotus').addEventListener('click', () => setSeedType('lotus'));

            // Iniciar loop de anima√ß√£o
            animate();
            updateWeather(); // Define o clima inicial
            updateAudio(); // Tenta iniciar o √°udio

            // Carregar o modelo do urso
            // loadBearModel();
        }

        function setSeedType(type) {
            currentSeedType = type;
            showNotification(`Semente de ${type} selecionada. Toque no ch√£o para plantar.`, 3000);
            console.log(`Selected seed: ${type}`);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onPointerDown(event) {
            // Calcular posi√ß√£o do ponteiro em coordenadas normalizadas (-1 a +1)
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Atualizar o raycaster com a c√¢mera e a posi√ß√£o do ponteiro
            raycaster.setFromCamera(pointer, camera);

            // Calcular objetos intersectando o raio
            const intersects = raycaster.intersectObject(ground); // Intersectar apenas com o ch√£o

            if (intersects.length > 0 && currentSeedType) {
                const intersectPoint = intersects[0].point;
                plantSeed(intersectPoint, currentSeedType);
                //currentSeedType = null; // Desselecionar ap√≥s plantar
                console.log(`Planted ${currentSeedType} at`, intersectPoint);
            } else if (intersects.length === 0) {
                // Tentar tocar nas plantas (opcional - colher melodia)
                const plantIntersects = raycaster.intersectObjects(plants.map(p => p.mesh).filter(m => m)); // Pega os meshes das plantas
                if (plantIntersects.length > 0) {
                    const plant = plantIntersects[0].object.userData.plantData;
                    console.log(`Tocou na planta: ${plant.type}`);
                    // Aqui poderia tocar um som aleat√≥rio (Web Audio API seria melhor)
                    try { notificationSound.play(); } catch (e) { console.warn("Audio play failed", e); }

                    if (plant.type === 'berrybush' && plant.growthStage === 3) {
                        plant.growthStage = 2; // Voltar para 'foliage'
                        scene.remove(plant.mesh);
                        plant.mesh = createPlantMesh(plant);
                        plant.mesh.position.copy(plant.position);
                        if (plant.mesh.type === 'Group') {
                            plant.mesh.position.y = plant.position.y;
                        } else {
                            plant.mesh.position.y = plant.position.y + (plant.mesh.geometry?.parameters?.height / 2 || plant.mesh.geometry?.parameters?.radius || 0.1);
                        }
                        plant.mesh.castShadow = true;
                        plant.mesh.userData.plantData = plant;
                        scene.add(plant.mesh);
                        showNotification("Colheu bagas! A vida √© doce. üçí", 3000);
                    } else {
                        showNotification(`üé∂ Melodia suave da ${plant.type} üé∂`, 1500);
                    }
                }
            }
        }

        function plantSeed(position, type) {
            // Adicionar variabilidade de tamanho para cada planta individual
            const sizeVariation = 0.85 + Math.random() * 0.3; // Varia√ß√£o de 85% a 115% do tamanho normal

            const plantData = {
                id: THREE.MathUtils.generateUUID(),
                type: type,
                position: position.clone(),
                plantedTime: clock.getElapsedTime(),
                growthStage: 0,
                mesh: null,
                notifiedStages: {},
                sizeVariation: sizeVariation, // Armazenar o fator de escala para esta planta
                bloomColor: type === 'flower' ? flowerBloomColors[Math.floor(Math.random() * flowerBloomColors.length)] : null
            };

            plantData.mesh = createPlantMesh(plantData);
            plantData.mesh.position.copy(position); // Colocar na posi√ß√£o correta
            plantData.mesh.position.y += 0.1; // Elevar um pouco para evitar z-fighting inicial
            plantData.mesh.castShadow = true;

            plantData.mesh.userData.plantData = plantData;
            scene.add(plantData.mesh);
            plants.push(plantData);
        }

        function getPlantStages(type) {
            switch (type) {
                case 'flower': return ['seed', 'sprout', 'bud', 'bloom'];
                case 'tree': return ['seed', 'sapling', 'growing', 'mature'];
                case 'pinetree': return ['seed', 'sapling', 'growing', 'mature', 'ancient'];
                case 'mushroom': return ['spore', 'small', 'grown'];
                case 'bamboo': return ['seed', 'shoot', 'cluster', 'dense'];
                case 'berrybush': return ['seed', 'sapling', 'foliage', 'berry'];
                case 'lotus': return ['spore', 'pad', 'bud', 'bloom'];
                default: return [];
            }
        }

        function getGrowthDuration(type, stageName) {
            if (growthTimes[type] && growthTimes[type][stageName] !== undefined) {
                let duration = growthTimes[type][stageName];
                // Modificador de clima
                if (simulatedWeather === 'sunny' && type !== 'mushroom') duration *= 0.8; // Cresce 20% mais r√°pido no sol
                if (simulatedWeather === 'rainy' && type === 'mushroom') duration *= 0.7; // Cogumelos 30% mais r√°pidos na chuva
                if (simulatedWeather === 'rainy' && type === 'bamboo') duration *= 0.8; // Bambu 20% mais r√°pido na chuva
                if (timeOfDay === 'day' && type === 'berrybush') duration *= 0.9; // Arbusto 10% mais r√°pido de dia
                if (simulatedWeather === 'rainy' && type === 'lotus') duration *= 0.75; // L√≥tus 25% mais r√°pido na chuva
                if (simulatedWeather === 'rainy' && type !== 'mushroom' && type !== 'bamboo' && type !== 'lotus') duration *= 1.2; // Outras plantas 20% mais lentas na chuva
                return duration;
            }
            return Infinity;
        }

        function createCloudMesh() {
            const cloudGroup = new THREE.Group();
            const cloudMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, flatShading: true, transparent: true, opacity: 0.9 });

            const numBlobs = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < numBlobs; i++) {
                const radius = 1 + Math.random() * 1.5;
                const geometry = new THREE.SphereGeometry(radius, 8, 8);
                const blob = new THREE.Mesh(geometry, cloudMaterial);
                blob.position.set(
                    (Math.random() - 0.5) * 3,
                    (Math.random() - 0.5) * 1.5,
                    (Math.random() - 0.5) * 2
                );
                cloudGroup.add(blob);
            }
            return cloudGroup;
        }

        function addCloud() {
            const cloud = createCloudMesh();
            cloud.position.set(
                (Math.random() - 0.5) * 80,
                15 + Math.random() * 10,
                (Math.random() - 0.5) * 80
            );
            cloud.userData = {
                speed: 0.5 + Math.random() * 1.5
            };
            scene.add(cloud);
            clouds.push(cloud);
        }

        function updateClouds(deltaTime) {
            clouds.forEach(cloud => {
                cloud.position.x += cloud.userData.speed * deltaTime;
                if (cloud.position.x > 50) {
                    cloud.position.x = -50;
                    cloud.position.z = (Math.random() - 0.5) * 80;
                }
            });
        }

        function createPlantMesh(plantData) {
            const stages = getPlantStages(plantData.type);
            const stageName = stages[plantData.growthStage];
            let geometry, material, mesh;
            const sizeVariation = plantData.sizeVariation || 1.0;

            switch (plantData.type) {
                case 'flower':
                    material = new THREE.MeshStandardMaterial({ roughness: 0.8 });
                    if (stageName === 'seed') {
                        geometry = new THREE.SphereGeometry(0.08 * sizeVariation, 8, 6);
                        material.color.set(0x8B4513);
                    } else if (stageName === 'sprout') {
                        geometry = new THREE.ConeGeometry(0.12 * sizeVariation, 0.3 * sizeVariation, 8);
                        material.color.set(0x90EE90);
                        mesh = new THREE.Mesh(geometry, material);
                        mesh.position.y = 0.15 * sizeVariation;
                        return mesh;
                    } else if (stageName === 'bud') {
                        geometry = new THREE.SphereGeometry(0.2 * sizeVariation, 8, 6);
                        material.color.set(0xFFC0CB);
                    } else {
                        geometry = new THREE.SphereGeometry(0.3 * sizeVariation, 16, 12);
                        material.color.set(plantData.bloomColor || 0xFF69B4);
                    }
                    break;

                case 'tree':
                    material = new THREE.MeshStandardMaterial({ roughness: 0.8 });
                    const trunkHeight = [0.1, 0.8, 1.5, 3.0][plantData.growthStage] * sizeVariation;
                    const trunkRadius = [0.05, 0.1, 0.2, 0.4][plantData.growthStage] * sizeVariation;
                    const leavesRadius = [0.1, 0.5, 1.0, 1.8][plantData.growthStage] * sizeVariation;
                    const leavesColor = stageName === 'seed' ? 0x8B4513 : 0x006400;

                    const trunkGeo = new THREE.CylinderGeometry(trunkRadius * 0.8, trunkRadius, trunkHeight, 8);
                    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                    const trunkMesh = new THREE.Mesh(trunkGeo, trunkMat);
                    trunkMesh.castShadow = true;
                    trunkMesh.position.y = trunkHeight / 2;

                    mesh = new THREE.Group();
                    mesh.add(trunkMesh);

                    if (stageName !== 'seed') {
                        const leavesGeo = new THREE.SphereGeometry(leavesRadius, 16, 12);
                        const colorVariation = -0.1 + Math.random() * 0.2;
                        const baseColor = new THREE.Color(leavesColor);
                        baseColor.r = Math.max(0, Math.min(1, baseColor.r * (1 + colorVariation * 0.3)));
                        baseColor.g = Math.max(0, Math.min(1, baseColor.g * (1 + colorVariation)));
                        baseColor.b = Math.max(0, Math.min(1, baseColor.b * (1 + colorVariation * 0.3)));

                        const leavesMat = new THREE.MeshStandardMaterial({ color: baseColor });
                        const leavesMesh = new THREE.Mesh(leavesGeo, leavesMat);
                        leavesMesh.castShadow = true;
                        leavesMesh.position.y = trunkHeight + leavesRadius * 0.7;
                        mesh.add(leavesMesh);
                    }
                    return mesh;

                case 'pinetree':
                    material = new THREE.MeshStandardMaterial({ roughness: 0.8 });
                    const pineHeight = [0.1, 1.5, 3.0, 6.0, 11.0][plantData.growthStage] * sizeVariation;
                    const pineTrunkRadius = [0.05, 0.1, 0.2, 0.35, 0.5][plantData.growthStage] * sizeVariation;
                    const pineTrunkColor = 0x5C4033;

                    const pineTrunkGeo = new THREE.CylinderGeometry(pineTrunkRadius * 0.8, pineTrunkRadius, pineHeight, 10);
                    const pineTrunkMat = new THREE.MeshStandardMaterial({ color: pineTrunkColor });
                    const pineTrunkMesh = new THREE.Mesh(pineTrunkGeo, pineTrunkMat);
                    pineTrunkMesh.castShadow = true;
                    pineTrunkMesh.position.y = pineHeight / 2;

                    mesh = new THREE.Group();
                    mesh.add(pineTrunkMesh);

                    if (stageName !== 'seed') {
                        const numLayers = plantData.growthStage === 1 ? 1 :
                            plantData.growthStage === 2 ? 3 :
                                plantData.growthStage === 3 ? 4 : 5;

                        let pineGreen = plantData.growthStage === 4 ? 0x1A4D2E : 0x2E8B57;
                        const colorVariation = -0.1 + Math.random() * 0.2;
                        const baseColor = new THREE.Color(pineGreen);
                        baseColor.g = Math.max(0, Math.min(1, baseColor.g * (1 + colorVariation)));
                        baseColor.b = Math.max(0, Math.min(1, baseColor.b * (1 + colorVariation * 0.5)));
                        pineGreen = baseColor;

                        for (let i = 0; i < numLayers; i++) {
                            const layerVariation = 0.95 + Math.random() * 0.1;
                            const layerHeight = pineHeight * (0.45 - i * 0.05) * layerVariation;
                            const layerRadius = pineHeight * (0.35 - i * 0.03) * layerVariation;
                            const layerY = pineHeight * (stageName === 'ancient' ? (0.5 + i * 0.12) : (0.55 + i * 0.15));

                            const coneGeo = new THREE.ConeGeometry(layerRadius, layerHeight, 10);
                            const coneMat = new THREE.MeshStandardMaterial({ color: pineGreen, roughness: 0.9, flatShading: true });
                            const coneMesh = new THREE.Mesh(coneGeo, coneMat);
                            coneMesh.castShadow = true;
                            coneMesh.position.y = layerY;
                            mesh.add(coneMesh);
                        }

                        if (stageName === 'ancient') {
                            const barkDetails = 15 + Math.floor(Math.random() * 10);
                            for (let i = 0; i < barkDetails; i++) {
                                const barkSize = (0.1 + Math.random() * 0.2) * sizeVariation;
                                const barkGeo = new THREE.BoxGeometry(barkSize, barkSize * 0.5, barkSize);
                                const barkMat = new THREE.MeshStandardMaterial({ color: 0x4B3621, roughness: 1.0 });
                                const barkMesh = new THREE.Mesh(barkGeo, barkMat);
                                const angle = Math.random() * Math.PI * 2;
                                const trunkOffset = pineTrunkRadius * 0.9;
                                const height = Math.random() * pineHeight * 0.8;
                                barkMesh.position.set(Math.cos(angle) * trunkOffset, height, Math.sin(angle) * trunkOffset);
                                barkMesh.rotation.set(Math.random() * 0.5, Math.random() * Math.PI * 2, Math.random() * 0.5);
                                mesh.add(barkMesh);
                            }
                        }
                    }
                    return mesh;

                case 'mushroom':
                    material = new THREE.MeshStandardMaterial({ roughness: 0.7 });
                    const mushStemHeight = [0.05, 0.2, 0.4][plantData.growthStage] * sizeVariation;
                    const mushCapRadius = [0.05, 0.25, 0.5][plantData.growthStage] * sizeVariation;

                    const stemHue = Math.random() * 0.1;
                    const stemColor = new THREE.Color(0xFFFACD).lerp(new THREE.Color(0xFFF0C0), stemHue);
                    const capHue = Math.random() * 0.2;
                    const baseCapColor = stageName === 'spore' ? 0xD2B48C : 0xDC143C;
                    const capColor = new THREE.Color(baseCapColor).lerp(stageName === 'spore' ? new THREE.Color(0xC2A478) : new THREE.Color(0xFF0000), capHue);

                    const stemGeo = new THREE.CylinderGeometry(mushStemHeight * 0.3, mushStemHeight * 0.4, mushStemHeight, 8);
                    const stemMat = new THREE.MeshStandardMaterial({ color: stemColor });
                    const stemMesh = new THREE.Mesh(stemGeo, stemMat);
                    stemMesh.castShadow = true;
                    stemMesh.position.y = mushStemHeight / 2;

                    mesh = new THREE.Group();
                    mesh.add(stemMesh);

                    if (stageName !== 'spore') {
                        const capGeo = new THREE.SphereGeometry(mushCapRadius, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
                        const capMat = new THREE.MeshStandardMaterial({ color: capColor });
                        const capMesh = new THREE.Mesh(capGeo, capMat);
                        capMesh.castShadow = true;
                        capMesh.position.y = mushStemHeight;
                        mesh.add(capMesh);
                    }
                    return mesh;

                case 'bamboo':
                    material = new THREE.MeshStandardMaterial({ roughness: 0.6 });
                    const bambooColor = 0x6B8E23;
                    if (stageName === 'seed') {
                        geometry = new THREE.SphereGeometry(0.05 * sizeVariation, 8, 6);
                        material.color.set(0x8B4513);
                    } else {
                        mesh = new THREE.Group();
                        const numStalks = stageName === 'shoot' ? 1 : (stageName === 'cluster' ? 4 : 10);
                        const heightBase = stageName === 'shoot' ? 0.5 : (stageName === 'cluster' ? 1.2 : 2.5);

                        for (let i = 0; i < numStalks; i++) {
                            const h = heightBase * (0.8 + Math.random() * 0.4) * sizeVariation;
                            const r = 0.03 * sizeVariation;
                            const stalkGeo = new THREE.CylinderGeometry(r, r, h, 6);
                            const stalkMat = new THREE.MeshStandardMaterial({ color: bambooColor });
                            const stalk = new THREE.Mesh(stalkGeo, stalkMat);
                            stalk.castShadow = true;
                            const offset = stageName === 'shoot' ? 0 : (0.1 + Math.random() * 0.2);
                            const angle = Math.random() * Math.PI * 2;
                            stalk.position.set(Math.cos(angle) * offset, h / 2, Math.sin(angle) * offset);
                            stalk.rotation.x = (Math.random() - 0.5) * 0.2;
                            stalk.rotation.z = (Math.random() - 0.5) * 0.2;
                            mesh.add(stalk);

                            if (stageName !== 'shoot') {
                                const numLeaves = stageName === 'cluster' ? 2 : 5;
                                for (let j = 0; j < numLeaves; j++) {
                                    const leafGeo = new THREE.ConeGeometry(0.05, 0.2, 4);
                                    const leafMat = new THREE.MeshStandardMaterial({ color: 0x9ACD32 });
                                    const leaf = new THREE.Mesh(leafGeo, leafMat);
                                    const leafH = Math.random() * h;
                                    leaf.position.set(0, leafH - h / 2, 0);
                                    leaf.rotation.z = Math.PI / 3;
                                    leaf.rotation.y = Math.random() * Math.PI * 2;
                                    stalk.add(leaf);
                                }
                            }
                        }
                        return mesh;
                    }
                    break;

                case 'berrybush':
                    material = new THREE.MeshStandardMaterial({ roughness: 0.8 });
                    if (stageName === 'seed') {
                        geometry = new THREE.SphereGeometry(0.06 * sizeVariation, 8, 6);
                        material.color.set(0x8B4513);
                    } else if (stageName === 'sapling') {
                        mesh = new THREE.Group();
                        const trunkGeo = new THREE.CylinderGeometry(0.02 * sizeVariation, 0.03 * sizeVariation, 0.4 * sizeVariation, 6);
                        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                        trunk.position.y = 0.2 * sizeVariation;
                        mesh.add(trunk);

                        const foliageGeo = new THREE.SphereGeometry(0.15 * sizeVariation, 8, 8);
                        const foliageMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
                        const foliage = new THREE.Mesh(foliageGeo, foliageMat);
                        foliage.position.y = 0.4 * sizeVariation;
                        mesh.add(foliage);
                        return mesh;
                    } else {
                        mesh = new THREE.Group();
                        const mainBushGeo = new THREE.SphereGeometry(0.5 * sizeVariation, 16, 12);
                        const bushColor = 0x006400;
                        const bushMat = new THREE.MeshStandardMaterial({ color: bushColor, roughness: 1.0 });
                        const mainBush = new THREE.Mesh(mainBushGeo, bushMat);
                        mainBush.position.y = 0.4 * sizeVariation;
                        mainBush.scale.y = 0.8;
                        mesh.add(mainBush);

                        if (stageName === 'berry') {
                            const numBerries = 10 + Math.floor(Math.random() * 10);
                            const berryGeo = new THREE.SphereGeometry(0.05 * sizeVariation, 6, 6);
                            const berryMat = new THREE.MeshStandardMaterial({ color: 0xFF0000, roughness: 0.4 });

                            for (let i = 0; i < numBerries; i++) {
                                const berry = new THREE.Mesh(berryGeo, berryMat);
                                const u = Math.random();
                                const v = Math.random();
                                const theta = 2 * Math.PI * u;
                                const phi = Math.acos(2 * v - 1);
                                const r = 0.45 * sizeVariation;
                                berry.position.set(
                                    r * Math.sin(phi) * Math.cos(theta),
                                    0.4 * sizeVariation + r * Math.sin(phi) * Math.sin(theta) * 0.8,
                                    r * Math.cos(phi)
                                );
                                mesh.add(berry);
                            }
                        }
                        return mesh;
                    }
                    break;

                case 'lotus':
                    material = new THREE.MeshStandardMaterial({ roughness: 0.5 });
                    if (stageName === 'spore') {
                        geometry = new THREE.SphereGeometry(0.04 * sizeVariation, 8, 6);
                        material.color.set(0x4B0082); // Indigo
                    } else {
                        mesh = new THREE.Group();

                        // Pad (Folha)
                        const padGeo = new THREE.CircleGeometry(0.3 * sizeVariation, 16);
                        const padMat = new THREE.MeshStandardMaterial({ color: 0x228B22, side: THREE.DoubleSide });
                        const pad = new THREE.Mesh(padGeo, padMat);
                        pad.rotation.x = -Math.PI / 2;
                        pad.position.y = 0.05; // Flutuando levemente
                        mesh.add(pad);

                        // Corte na folha (estilo vit√≥ria r√©gia) - visual simples
                        // (Poderia ser feito com geometria customizada, mas c√≠rculo serve por enquanto)

                        if (stageName === 'bud' || stageName === 'bloom') {
                            const budSize = stageName === 'bud' ? 0.1 : 0.25;
                            const budColor = 0xFF69B4; // HotPink
                            const budGeo = new THREE.SphereGeometry(budSize * sizeVariation, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2);
                            const budMat = new THREE.MeshStandardMaterial({ color: budColor });

                            if (stageName === 'bloom') {
                                budMat.emissive = new THREE.Color(0xFF1493); // Brilho base
                                budMat.emissiveIntensity = 0.2;
                                // L√≥gica de brilho noturno ser√° tratada no updateTimeOfDay ou aqui se tiver acesso ao timeOfDay
                            }

                            const flower = new THREE.Mesh(budGeo, budMat);
                            flower.position.y = 0.05;
                            mesh.add(flower);
                        }
                        return mesh;
                    }
                    break;
            }

            if (!mesh && geometry) {
                mesh = new THREE.Mesh(geometry, material);
                mesh.position.y = (geometry.parameters.height || geometry.parameters.radius * 2 || 0.2) / 2;
            }
            return mesh;
        }

        function updatePlantGrowth(deltaTime) {
            const currentTime = clock.getElapsedTime();
            plants.forEach(plant => {
                if (!plant.mesh) return;
                const stages = getPlantStages(plant.type);
                const currentStageName = stages[plant.growthStage];
                const timeElapsed = currentTime - plant.plantedTime;

                if (plant.growthStage < stages.length - 1) {
                    const nextStageName = stages[plant.growthStage + 1];
                    let cumulativeTime = 0;
                    for (let i = 1; i <= plant.growthStage + 1; i++) {
                        cumulativeTime += getGrowthDuration(plant.type, stages[i]);
                    }

                    if (timeElapsed >= cumulativeTime) {
                        plant.growthStage++;
                        const newStageName = stages[plant.growthStage];
                        console.log(`${plant.type} ${plant.id.substring(0, 4)} advanced to ${newStageName}`);

                        scene.remove(plant.mesh);
                        plant.mesh = createPlantMesh(plant);
                        if (plant.mesh) {
                            plant.mesh.position.copy(plant.position);
                            if (plant.mesh.type === 'Group') {
                                plant.mesh.position.y = plant.position.y;
                            } else {
                                plant.mesh.position.y = plant.position.y + (plant.mesh.geometry?.parameters?.height / 2 || plant.mesh.geometry?.parameters?.radius || 0.1);
                            }
                            plant.mesh.castShadow = true;
                            plant.mesh.userData.plantData = plant;
                            scene.add(plant.mesh);

                            if ((plant.type === 'flower' && newStageName === 'bloom') ||
                                (plant.type === 'tree' && newStageName === 'mature') ||
                                (plant.type === 'pinetree' && (newStageName === 'mature' || newStageName === 'ancient')) ||
                                (plant.type === 'mushroom' && newStageName === 'grown') ||
                                (plant.type === 'bamboo' && newStageName === 'dense') ||
                                (plant.type === 'berrybush' && newStageName === 'berry') ||
                                (plant.type === 'lotus' && newStageName === 'bloom')) {
                                if (!plant.notifiedStages[newStageName]) {
                                    const messages = {
                                        'flower': `Sua ${plant.type} desabrochou! üå∏`,
                                        'tree': `Sua ${plant.type} est√° madura! üå≥`,
                                        'pinetree': newStageName === 'ancient' ? `Seu pinheiro se tornou uma √°rvore ancestral! üå≤` : `Seu pinheiro atingiu o tamanho m√°ximo! üå≤`,
                                        'mushroom': `Seu ${plant.type} cresceu! üçÑ`,
                                        'bamboo': `Seu bambuzal est√° denso! üéã`,
                                        'berrybush': `Seu arbusto deu frutos! üçí`,
                                        'lotus': `Sua l√≥tus desabrochou e brilha! ü™∑`
                                    };
                                    const message = plant.type === 'pinetree' ? messages['pinetree'] : messages[plant.type];
                                    showNotification(message, 5000);
                                    try { notificationSound.play(); } catch (e) { console.warn("Audio play failed", e); }
                                    plant.notifiedStages[newStageName] = true;
                                }
                            }
                        }
                    }
                }
            });
        }

        function updateWeather(deltaTime = 0) {
            timeSinceLastWeatherChange += deltaTime;
            if (timeSinceLastWeatherChange > weatherChangeInterval) {
                timeSinceLastWeatherChange = 0;
                const prevState = simulatedWeather;
                simulatedWeather = Math.random() < 0.7 ? 'sunny' : 'rainy';
                console.log(`Weather changed to: ${simulatedWeather}`);
                if (prevState !== simulatedWeather) {
                    updateAudio();
                    updateSkyColor();
                }
            }
            weatherStatusElement.textContent = `Clima: ${simulatedWeather === 'sunny' ? 'Ensolarado ‚òÄÔ∏è' : 'Chuva Leve üåßÔ∏è'}`;
        }

        function updateTimeOfDay(deltaTime) {
            timeAccumulator += deltaTime * timeSpeed;
            const cycleTime = timeAccumulator % dayDuration;
            const dayProgress = cycleTime / dayDuration;

            const prevTimeOfDay = timeOfDay;

            if (dayProgress < 0.45 || dayProgress > 0.95) { // Dia (0-0.45) e (0.95-1 -> amanhecer)
                timeOfDay = 'day';
            } else if (dayProgress >= 0.45 && dayProgress < 0.55) { // Crep√∫sculo (0.45-0.55)
                timeOfDay = 'evening';
            } else { // Noite (0.55 - 0.95)
                timeOfDay = 'night';
            }


            if (prevTimeOfDay !== timeOfDay) {
                console.log(`Time changed to: ${timeOfDay}`);
                updateAudio(); // Atualiza o som ambiente
                updateSkyColor();

                // Se mudou de noite para outro per√≠odo, remove todos os vagalumes
                if (prevTimeOfDay === 'night' && timeOfDay !== 'night') {
                    // Remover todos os vagalumes quando o dia come√ßa
                    for (let i = butterflies.length - 1; i >= 0; i--) {
                        scene.remove(butterflies[i]);
                    }
                    butterflies.length = 0; // Limpar o array
                }
            }
            timeStatusElement.textContent = `Hora: ${timeOfDay === 'day' ? 'Dia ‚òÄÔ∏è' : (timeOfDay === 'evening' ? 'Entardecer üåá' : 'Noite üåô')}`;

            // Atualizar luz direcional (simular sol/lua)
            const sunAngle = dayProgress * Math.PI * 2 - Math.PI / 2; // Ciclo completo de 2PI, come√ßando do horizonte leste
            const light = scene.getObjectByProperty('isDirectionalLight', true);
            if (light) {
                light.position.set(Math.cos(sunAngle) * 15, Math.sin(sunAngle) * 10 + 5, 10); // Movimento no c√©u
                light.intensity = timeOfDay === 'night' ? 0.3 : (timeOfDay === 'evening' ? 0.8 : 1.5); // Mais fraco √† noite
                light.color.set(timeOfDay === 'night' ? 0xaaaaff : (timeOfDay === 'evening' ? 0xffccaa : 0xffffff)); // Cor da luz
                light.target.position.set(0, 0, 0); // Manter olhando para o centro
            }
            const ambient = scene.getObjectByProperty('isAmbientLight', true);
            if (ambient) {
                ambient.intensity = timeOfDay === 'night' ? 0.2 : (timeOfDay === 'evening' ? 0.4 : 0.6);
            }

            // Atualizar brilho da L√≥tus
            plants.forEach(plant => {
                if (plant.type === 'lotus' && plant.growthStage === 3 && plant.mesh) { // Bloom
                    // Encontrar a parte da flor (√∫ltimo filho adicionado)
                    const flower = plant.mesh.children[plant.mesh.children.length - 1];
                    if (flower && flower.material) {
                        flower.material.emissiveIntensity = timeOfDay === 'night' ? 1.0 : 0.2;
                    }
                }
            });
        }

        function updateSkyColor() {
            let skyCol = new THREE.Color(0x87CEEB); // Dia
            let groundCol = new THREE.Color(0x228B22); // Grama dia

            if (timeOfDay === 'evening') {
                skyCol.set(0xFF8C00); // Laranja
                groundCol.lerp(new THREE.Color(0x556B2F), 0.3); // Verde mais escuro
            } else if (timeOfDay === 'night') {
                skyCol.set(0x000033); // Azul escuro
                groundCol.set(0x1A4D2E); // Verde bem escuro
            }

            // Modificador de chuva
            if (simulatedWeather === 'rainy') {
                skyCol.lerp(new THREE.Color(0x778899), 0.6); // Cinza
                groundCol.lerp(new THREE.Color(0x1E5631), 0.4); // Verde mais escuro/molhado
            }

            // scene.background = skyCol; // Muda o fundo da cena
            if (sky && sky.material) {
                sky.material.color = skyCol; // Muda a cor do sky dome
            }
            if (ground && ground.material) {
                ground.material.color = groundCol;
            }
        }

        function updateButterflies(deltaTime) {
            if (timeOfDay !== 'night') return; // Apenas √† noite

            // Adicionar novos vagalumes ocasionalmente
            if (butterflies.length < 15 && Math.random() < 0.05) {
                addFirefly();
            }

            butterflies.forEach(firefly => {
                firefly.userData.angle += deltaTime * firefly.userData.speed;
                firefly.position.x += Math.cos(firefly.userData.angle) * 0.05;
                firefly.position.z += Math.sin(firefly.userData.angle) * 0.05;
                firefly.position.y += (Math.random() - 0.5) * 0.05;

                // Manter dentro dos limites
                if (firefly.position.y < 0.5) firefly.position.y = 0.5;
                if (firefly.position.y > 4) firefly.position.y = 4;
            });
        }

        function addFirefly() {
            const geometry = new THREE.SphereGeometry(0.05, 4, 4);
            const material = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
            const firefly = new THREE.Mesh(geometry, material);

            firefly.position.set(
                (Math.random() - 0.5) * 20,
                0.5 + Math.random() * 2,
                (Math.random() - 0.5) * 20
            );

            firefly.userData = {
                angle: Math.random() * Math.PI * 2,
                speed: 0.5 + Math.random()
            };

            scene.add(firefly);
            butterflies.push(firefly);
        }

        function showNotification(message, duration = 3000) {
            notificationElement.textContent = message;
            notificationElement.style.display = 'block';
            setTimeout(() => {
                notificationElement.style.display = 'none';
            }, duration);
        }

        function updateAudio() {
            // L√≥gica simples de √°udio baseada no estado
            if (simulatedWeather === 'rainy') {
                rainSound.volume = 0.5;
                if (rainSound.paused) rainSound.play().catch(e => { });
            } else {
                if (!rainSound.paused) rainSound.pause();
            }

            if (timeOfDay === 'day') {
                ambientSoundDay.volume = 0.3;
                if (ambientSoundDay.paused) ambientSoundDay.play().catch(e => { });
                if (!ambientSoundNight.paused) ambientSoundNight.pause();
            } else {
                ambientSoundNight.volume = 0.3;
                if (ambientSoundNight.paused) ambientSoundNight.play().catch(e => { });
                if (!ambientSoundDay.paused) ambientSoundDay.pause();
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();

            updatePlantGrowth(deltaTime);
            updateWeather(deltaTime);
            updateTimeOfDay(deltaTime);
            updateButterflies(deltaTime);
            updateClouds(deltaTime);

            renderer.render(scene, camera);
        }

        // Iniciar
        init();

    </script>
</body>

</html>