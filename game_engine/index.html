<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple 3D Engine Interface</title>
    <style>
        body { margin: 0; font-family: sans-serif; display: flex; flex-direction: column; height: 100vh; background-color: #333; color: #eee; }
        #toolbar { background-color: #444; padding: 5px; border-bottom: 1px solid #555; flex-shrink: 0; }
        #toolbar button { margin: 0 5px; padding: 3px 8px; background-color: #555; border: 1px solid #666; color: #eee; cursor: pointer; }
        #toolbar button:hover { background-color: #666; }
        #main-content { display: flex; flex-grow: 1; overflow: hidden; /* Prevent layout issues */ }

        #left-panel { width: 200px; background-color: #3a3a3a; border-right: 1px solid #555; display: flex; flex-direction: column; flex-shrink: 0; }
        #hierarchy { padding: 10px; overflow-y: auto; flex-grow: 1; }
        #hierarchy h3 { margin-top: 0; font-size: 1em; border-bottom: 1px solid #555; padding-bottom: 5px; }
        #hierarchy ul { list-style: none; padding: 0; margin: 0; }
        #hierarchy li { padding: 4px; cursor: pointer; border-radius: 3px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #hierarchy li:hover { background-color: #555; }
        #hierarchy li.selected { background-color: #0078d4; color: white; }

        #center-panel { flex-grow: 1; position: relative; /* Needed for canvas absolute positioning */ }
        #sceneCanvas { display: block; width: 100%; height: 100%; background-color: #222; } /* Ensure canvas fills */

        #right-panel { width: 250px; background-color: #3a3a3a; border-left: 1px solid #555; display: flex; flex-direction: column; flex-shrink: 0; }
        #inspector { padding: 10px; overflow-y: auto; flex-grow: 1; }
        #inspector h3 { margin-top: 0; font-size: 1em; border-bottom: 1px solid #555; padding-bottom: 5px; }
        .inspector-section { margin-bottom: 15px; }
        .inspector-section h4 { margin: 5px 0; font-size: 0.9em; color: #ccc; }
        .inspector-section label { display: block; margin-bottom: 3px; font-size: 0.8em; color: #bbb; }
        .inspector-section input[type="text"],
        .inspector-section input[type="number"],
        .inspector-section select {
            width: calc(100% - 12px); /* Account for padding */
            padding: 4px;
            background-color: #2a2a2a;
            border: 1px solid #555;
            color: #eee;
            border-radius: 3px;
            margin-bottom: 5px;
        }
        .vector3-input { display: flex; gap: 5px; }
        .vector3-input > div { flex: 1; }
        .vector3-input label { display: inline; margin-right: 3px; color: #999; }
        .vector3-input input { width: calc(100% - 25px); } /* Adjust for label */
        .inspector-section input[type="checkbox"] { margin-right: 5px; }
        .inspector-section button { width: 100%; padding: 5px; background-color: #c04040; border: 1px solid #d05050; color: white; cursor: pointer; margin-top: 10px; }
        .inspector-section button:hover { background-color: #d05050; }
        #inspector-placeholder { color: #888; text-align: center; margin-top: 20px; font-style: italic; }
        .transform-mode-btn {
            background-color: #555;
        }
        .transform-mode-btn.active {
            background-color: #0078d4 !important;
            border-color: #0095ff !important;
        }
    </style>
</head>
<body>

    <div id="toolbar">
        <button id="newSceneBtn">Nova Cena</button>
        <span>Adicionar Objeto:</span>
        <button id="addCubeBtn">Cubo</button>
        <button id="addSphereBtn">Esfera</button>
        <span>Adicionar Luz:</span>
        <button id="addAmbientLightBtn">Ambiente</button>
        <button id="addDirectionalLightBtn">Direcional</button>
        <span>|</span>
        <button id="transformModeTranslate" class="transform-mode-btn active">Mover</button>
        <button id="transformModeRotate" class="transform-mode-btn">Rotacionar</button>
        <button id="transformModeScale" class="transform-mode-btn">Escalar</button>
        <span>|</span>
        <button id="playBtn">‚ñ∂ Play</button>
    </div>

    <div id="main-content">
        <div id="left-panel">
            <div id="hierarchy">
                <h3>Hierarquia</h3>
                <ul id="hierarchyList">
                    <!-- Itens da cena ser√£o adicionados aqui -->
                </ul>
            </div>
        </div>

        <div id="center-panel">
            <canvas id="sceneCanvas"></canvas>
        </div>

        <div id="right-panel">
            <div id="inspector">
                <h3>Inspetor</h3>
                <div id="inspectorContent">
                    <div id="inspector-placeholder">Selecione um objeto na Hierarquia.</div>
                    <!-- Conte√∫do do inspetor ser√° preenchido dinamicamente -->
                </div>
            </div>
        </div>
    </div>

    <!-- Import maps for Three.js -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let sceneObjects = []; // Objects: { id, name, type, threeObject (mesh/light), physics, collision }
        let selectedObject = null;
        let isPlaying = false; // Added: Play mode state
        let groundPlane;
        const clock = new THREE.Clock();
        const sceneCanvas = document.getElementById('sceneCanvas');
        const hierarchyList = document.getElementById('hierarchyList');
        const inspectorContent = document.getElementById('inspectorContent');
        const inspectorPlaceholder = document.getElementById('inspector-placeholder');
        // Keep track of lights separately for potential specific handling
        let ambientLights = [];
        let directionalLights = [];
        let transformMode = 'translate'; // 'translate', 'rotate', 'scale'
        let transformControl; // Gizmo control
        let isDragging = false;
        let raycaster = new THREE.Raycaster();
        let pointer = new THREE.Vector2();

        // Vari√°veis para o controle de arrastamento
        let selectedAxis = null;
        let dragStartPosition = new THREE.Vector3();
        let objectStartPosition = new THREE.Vector3();
        let dragPlane = new THREE.Plane();
        let dragIntersection = new THREE.Vector3();

        // --- Initialization ---
        function initThree() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x404040); // Cor de fundo da cena

            // Camera
            camera = new THREE.PerspectiveCamera(75, sceneCanvas.clientWidth / sceneCanvas.clientHeight, 0.1, 1000);
            camera.position.set(5, 5, 10);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: sceneCanvas, antialias: true });
            renderer.setSize(sceneCanvas.clientWidth, sceneCanvas.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // Para telas de alta resolu√ß√£o
            renderer.shadowMap.enabled = true; // Habilitar sombras

            // --- Remove default lights - they will be added via buttons ---
            // const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            // scene.add(ambientLight);
            // const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            // directionalLight.position.set(5, 10, 7);
            // directionalLight.castShadow = true;
            // scene.add(directionalLight);

            // Ground Plane (Helper)
            const gridHelper = new THREE.GridHelper(50, 50);
            scene.add(gridHelper);
            groundPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(50, 50),
                new THREE.MeshStandardMaterial({ color: 0x555555, side: THREE.DoubleSide, name: 'GroundMaterial' }) // Give material a name
            );
            groundPlane.rotation.x = -Math.PI / 2;
            groundPlane.receiveShadow = true;
            groundPlane.name = "GroundPlane"; // Give the mesh a name
            scene.add(groundPlane);


            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Efeito de suaviza√ß√£o
            controls.dampingFactor = 0.1;

            // Initial Resize
            handleResize();

            // Animation Loop
            animate();

            // Setup transform controls
            setupTransformControls();

            // Add mouse event listeners for gizmo interaction
            sceneCanvas.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);

            // Add transform mode button listeners
            document.getElementById('transformModeTranslate').addEventListener('click', () => {
                setTransformMode('translate');
            });
            document.getElementById('transformModeRotate').addEventListener('click', () => {
                setTransformMode('rotate');
            });
            document.getElementById('transformModeScale').addEventListener('click', () => {
                setTransformMode('scale');
            });
        }

        function handleResize() {
            const width = sceneCanvas.clientWidth;
            const height = sceneCanvas.clientHeight;
            if (width > 0 && height > 0) {
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            }
        }

        // --- Scene Management ---
        function createNewScene() {
            // Clear internal state
            selectedObject = null;
            sceneObjects = [];
            ambientLights = []; // Clear light arrays
            directionalLights = []; // Clear light arrays
            isPlaying = false; // Stop play mode
            updatePlayButton(); // Update button text


            // Clear Three.js scene (keep grid, ground)
            const objectsToRemove = [];
            scene.children.forEach(child => {
                // Keep camera, grid, and ground plane
                if (child !== camera && !(child instanceof THREE.GridHelper) && child !== groundPlane) {
                     objectsToRemove.push(child);
                }
            });
            objectsToRemove.forEach(obj => {
                 // Dispose geometry/material if it's a mesh before removing
                if (obj.isMesh || obj.isLight) {
                    disposeObject3D(obj);
                 } else if (obj.isGroup) { // Handle groups recursively
                     obj.traverse(node => {
                         if (node.isMesh) {
                             disposeObject3D(node);
                         }
                     });
                 }
                scene.remove(obj)
            });

            // Clear UI
            updateHierarchyList();
            clearInspector();
            console.log("Nova cena criada.");
        }

        // --- Object & Light Management ---

        // Helper to dispose Three.js resources
        function disposeObject3D(obj) {
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) {
                // Handle multi-materials
                if (Array.isArray(obj.material)) {
                    obj.material.forEach(material => material.dispose());
                } else {
                    obj.material.dispose();
                }
            }
            // Dispose textures if necessary (more complex, requires tracking)
         }


        function addObject(type) {
            let geometry;
            let defaultName;
            let mesh; // Define mesh outside switch

            switch(type) {
                case 'cube':
                    geometry = new THREE.BoxGeometry(1, 1, 1);
                    defaultName = "Cubo";
                    break;
                case 'sphere':
                    geometry = new THREE.SphereGeometry(0.5, 32, 16);
                    defaultName = "Esfera";
                    break;
                // --- Add cases for lights ---
                case 'ambient_light':
                     addAmbientLight(); // Call specific function
                     return; // Exit addObject
                case 'directional_light':
                     addDirectionalLight(); // Call specific function
                     return; // Exit addObject
                // -------------------------
                default:
                    console.error("Tipo de objeto desconhecido:", type);
                    return;
            }

            // This part is only for Mesh objects
            const material = new THREE.MeshStandardMaterial({
                 color: Math.random() * 0xffffff, // Cor aleat√≥ria
                 roughness: 0.5,
                 metalness: 0.2
            });
             mesh = new THREE.Mesh(geometry, material);
             mesh.castShadow = true;
             mesh.receiveShadow = true; // Objetos podem receber sombras de outros
             mesh.position.set(
                (Math.random() - 0.5) * 4,
                 type === 'sphere' ? 0.5 : 0.5, // Initial Y based on type
                (Math.random() - 0.5) * 4
            );

            const id = THREE.MathUtils.generateUUID();
            const newObjectData = {
                id: id,
                name: `${defaultName}_${id.substring(0, 4)}`,
                type: type, // 'cube', 'sphere'
                threeObject: mesh, // Store the mesh/light here
                physics: {
                    enabled: false,
                    isKinematic: false,
                    shape: type === 'cube' ? 'box' : 'sphere',
                    velocity: new THREE.Vector3(0, 0, 0),
                    mass: 1.0
                },
                collision: {
                    enabled: false,
                    isTrigger: false,
                    radius: type === 'sphere' ? 0.5 : Math.sqrt(3) / 2, // For sphere use radius, for cube use half diagonal
                    lastCollision: null // To track collision state
                }
            };

            mesh.userData.objectId = id; // Link back for selection
            sceneObjects.push(newObjectData);
            scene.add(mesh);
            updateHierarchyList();
            selectObject(id);
            console.log(`Objeto ${type} adicionado: ${newObjectData.name}`);
        }

        function addAmbientLight() {
            const light = new THREE.AmbientLight(0xffffff, 0.6); // Default white, moderate intensity
            const id = THREE.MathUtils.generateUUID();
            light.name = `AmbientLight_${id.substring(0, 4)}`;

            const lightData = {
                id: id,
                name: light.name,
                type: 'ambient_light',
                threeObject: light,
                // Lights don't typically have physics/collision in this context
                physics: null,
                collision: null
            };

            light.userData.objectId = id; // Link back
            sceneObjects.push(lightData);
            ambientLights.push(light); // Keep track if needed
            scene.add(light);
            updateHierarchyList();
            selectObject(id); // Select the new light
            console.log(`Luz Ambiente adicionada: ${lightData.name}`);
        }

        function addDirectionalLight() {
            const light = new THREE.DirectionalLight(0xffffff, 1.0); // Default white, full intensity
            light.position.set(5, 10, 7); // Default position
            light.castShadow = true;
            // Configure shadow properties (optional defaults)
             light.shadow.mapSize.width = 1024;
             light.shadow.mapSize.height = 1024;
             light.shadow.camera.near = 0.5;
             light.shadow.camera.far = 50;
             light.shadow.camera.left = -10;
             light.shadow.camera.right = 10;
             light.shadow.camera.top = 10;
             light.shadow.camera.bottom = -10;

            const id = THREE.MathUtils.generateUUID();
             light.name = `DirectionalLight_${id.substring(0, 4)}`;

            const lightData = {
                id: id,
                name: light.name,
                type: 'directional_light',
                threeObject: light,
                physics: null,
                collision: null
            };

            light.userData.objectId = id; // Link back
            sceneObjects.push(lightData);
            directionalLights.push(light); // Keep track if needed
            scene.add(light);
            // Directional lights also have a target object
            scene.add(light.target); // Add target to scene as well

            updateHierarchyList();
            selectObject(id); // Select the new light
            console.log(`Luz Direcional adicionada: ${lightData.name}`);
        }


        function deleteObject(id) {
             const index = sceneObjects.findIndex(obj => obj.id === id);
             if (index !== -1) {
                 const objectToRemove = sceneObjects[index];
                 const threeObj = objectToRemove.threeObject;

                 scene.remove(threeObj); // Remove from Three.js scene

                 // If it's a directional light, remove its target too
                 if (threeObj instanceof THREE.DirectionalLight) {
                     scene.remove(threeObj.target);
                 }

                 // Dispose geometry/material if it's a mesh
                 if (threeObj.isMesh) {
                     disposeObject3D(threeObj);
                 } else if (threeObj.isGroup) {
                      threeObj.traverse(node => {
                         if (node.isMesh) disposeObject3D(node);
                      });
                 } else if (threeObj.isLight) {
                     threeObj.dispose(); // Lights have a dispose method
                 }

                 sceneObjects.splice(index, 1); // Remove from our list

                 // Remove from specific light lists if applicable
                  if (objectToRemove.type === 'ambient_light') {
                      ambientLights = ambientLights.filter(l => l !== threeObj);
                  } else if (objectToRemove.type === 'directional_light') {
                      directionalLights = directionalLights.filter(l => l !== threeObj);
                  }


                 console.log(`Objeto ${objectToRemove.name} removido.`);

                 if (selectedObject && selectedObject.id === id) {
                     selectedObject = null;
                     clearInspector();
                      removeSelectionHighlight(); // Remove highlight
                 }
                 updateHierarchyList();

             } else {
                 console.warn("Tentativa de deletar objeto n√£o encontrado:", id);
             }
        }


        function selectObject(id) {
            const objectData = sceneObjects.find(obj => obj.id === id);
            if (objectData) {
                selectedObject = objectData;
                updateHierarchyList();
                updateInspector();
                console.log("Objeto selecionado:", selectedObject.name);
                
                // Add highlight only if it's a mesh or group (lights don't have boxes)
                if (selectedObject.threeObject.isMesh || selectedObject.threeObject.isGroup) {
                    addSelectionHighlight(selectedObject.threeObject);
                    updateGizmoPosition(); // Atualiza o gizmo para a posi√ß√£o do objeto selecionado
                    console.log("Gizmo deveria estar vis√≠vel agora");
                } else {
                    removeSelectionHighlight(); // Remove if selecting a non-mesh
                    transformControl.visible = false; // Oculte o gizmo para objetos que n√£o s√£o mesh
                }
            } else {
                selectedObject = null;
                updateHierarchyList();
                clearInspector();
                removeSelectionHighlight();
                transformControl.visible = false; // Oculte o gizmo quando n√£o h√° objeto selecionado
            }
        }

        // --- Play Mode ---
        function togglePlayMode() {
            isPlaying = !isPlaying;
            console.log(`Play Mode: ${isPlaying ? 'Iniciado' : 'Parado'}`);
            updatePlayButton();

            if (isPlaying) {
                // Logic to start the simulation (e.g., enable physics)
                controls.enabled = false; // Disable orbit controls in play mode
                // Potentially switch camera, reset player, start physics simulation etc.
                 // For now, just disable controls
                 removeSelectionHighlight(); // Hide selection in play mode
                 if(selectedObject) { // Deselect object
                    selectedObject = null;
                    updateHierarchyList();
                    clearInspector();
                 }

            } else {
                // Logic to stop the simulation (e.g., disable physics, reset positions)
                 controls.enabled = true; // Re-enable orbit controls
            }
            // Update UI elements based on play state if needed
        }

        function updatePlayButton() {
            const playBtn = document.getElementById('playBtn');
            playBtn.textContent = isPlaying ? '‚èπ Stop' : '‚ñ∂ Play';
             playBtn.style.backgroundColor = isPlaying ? '#c04040' : '#555'; // Red when playing
             playBtn.style.borderColor = isPlaying ? '#d05050' : '#666';
        }


        // --- UI Updates ---

        function updateHierarchyList() {
            hierarchyList.innerHTML = ''; // Clear list
            sceneObjects.forEach(obj => {
                const li = document.createElement('li');
                // Add prefix based on type for clarity
                let prefix = '';
                if (obj.type === 'cube' || obj.type === 'sphere') prefix = 'üì¶ ';
                else if (obj.type === 'ambient_light') prefix = 'üí° ';
                else if (obj.type === 'directional_light') prefix = '‚òÄÔ∏è ';

                li.textContent = prefix + obj.name;
                li.dataset.id = obj.id; // Store ID for click handling
                if (selectedObject && obj.id === selectedObject.id) {
                    li.classList.add('selected');
                }
                li.addEventListener('click', (e) => {
                    // Don't allow selection if in play mode
                     if (isPlaying) {
                         e.stopPropagation(); // Prevent potential deselection?
                         return;
                     };
                    selectObject(obj.id);
                });
                hierarchyList.appendChild(li);
            });
        }

        function clearInspector() {
            inspectorContent.innerHTML = ''; // Clear specific content
            inspectorContent.appendChild(inspectorPlaceholder); // Show placeholder
            inspectorPlaceholder.style.display = 'block';
        }

        function updateInspector() {
            if (!selectedObject || isPlaying) { // Don't show inspector if playing
                clearInspector();
                return;
            }

            inspectorPlaceholder.style.display = 'none'; // Hide placeholder
            inspectorContent.innerHTML = ''; // Clear previous content

            const obj = selectedObject;
            const threeObj = obj.threeObject;

            // --- Nome ---
            const nameSection = createInspectorSection('Nome');
            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.value = obj.name;
            nameInput.addEventListener('change', (e) => {
                obj.name = e.target.value;
                 threeObj.name = obj.name; // Update Three.js object name too
                updateHierarchyList(); // Update name in hierarchy
            });
            nameSection.appendChild(nameInput);
            inspectorContent.appendChild(nameSection);

            // --- Transform (Common to Meshes and Lights) ---
             const transformSection = createInspectorSection('Transform');
             // Position
             transformSection.appendChild(createVector3Input('Posi√ß√£o', threeObj.position, (axis, value) => { threeObj.position[axis] = value; }));
             // Rotation (Euler degrees - Only for Meshes/Groups, not really for lights)
            if (threeObj.isMesh || threeObj.isGroup) {
                 const rotationDeg = {
                     x: THREE.MathUtils.radToDeg(threeObj.rotation.x),
                     y: THREE.MathUtils.radToDeg(threeObj.rotation.y),
                     z: THREE.MathUtils.radToDeg(threeObj.rotation.z)
                 };
                 transformSection.appendChild(createVector3Input('Rota√ß√£o', rotationDeg, (axis, value) => {
                     threeObj.rotation[axis] = THREE.MathUtils.degToRad(value);
                 }, 0.1)); // Step for degrees
            }
            // Scale (Only for Meshes/Groups)
            if (threeObj.isMesh || threeObj.isGroup) {
                transformSection.appendChild(createVector3Input('Escala', threeObj.scale, (axis, value) => { threeObj.scale[axis] = value; }, 0.01));
            }
             inspectorContent.appendChild(transformSection);

             // --- Light Specific Properties ---
             if (threeObj.isLight) {
                 const lightSection = createInspectorSection('Propriedades da Luz');
                // Color
                 lightSection.appendChild(createColorInput('Cor', threeObj.color, (hexColor) => {
                     threeObj.color.set(hexColor);
                 }));
                // Intensity
                 lightSection.appendChild(createNumberInput('Intensidade', threeObj.intensity, (value) => {
                     threeObj.intensity = value;
                 }, 0.01, 0)); // Step 0.01, min 0

                 // Directional Light Specific
                 if (threeObj.isDirectionalLight) {
                    // Shadow toggle
                     lightSection.appendChild(createCheckbox('Projetar Sombra', threeObj.castShadow, (checked) => {
                         threeObj.castShadow = checked;
                     }));
                     // Could add shadow map size, bias etc. here
                 }
                 inspectorContent.appendChild(lightSection);
             }

             // --- Material Properties ---
             if (threeObj.isMesh) {
                 // Material Properties Section
                 const materialSection = createInspectorSection('Material');
                 
                 // Color picker for mesh
                 if (threeObj.material && threeObj.material.color) {
                     materialSection.appendChild(createColorInput('Cor', threeObj.material.color, (hexColor) => {
                         threeObj.material.color.set(hexColor);
                     }));
                 }

                 // Add more material properties if needed in the future
                 // (roughness, metalness, etc.)
                 
                 inspectorContent.appendChild(materialSection);
             }

             // --- Physics (Conceptual - Only for Meshes) ---
             if (obj.physics && (threeObj.isMesh || threeObj.isGroup)) {
                 const physicsSection = createInspectorSection('F√≠sica (Conceitual)');
                 physicsSection.appendChild(createCheckbox('Habilitar F√≠sica', obj.physics.enabled, (checked) => {
                     obj.physics.enabled = checked;
                     console.log(`${obj.name} - F√≠sica habilitada: ${checked}`);
                     updateInspector(); // Redraw if needed
                 }));
                 
                 if (obj.physics.enabled) {
                     physicsSection.appendChild(createCheckbox('Cinem√°tico', obj.physics.isKinematic, (checked) => { 
                         obj.physics.isKinematic = checked; 
                     }));
                     physicsSection.appendChild(createDropdown('Forma Colisor', ['box', 'sphere', 'capsule', 'mesh'], obj.physics.shape, (value) => { 
                         obj.physics.shape = value; 
                         // Update collision radius based on shape
                         if (obj.collision) {
                             obj.collision.radius = (value === 'sphere') ? 0.5 : Math.sqrt(3) / 2;
                         }
                     }));
                     
                     // Add mass control
                     physicsSection.appendChild(createNumberInput('Massa', obj.physics.mass, (value) => {
                         obj.physics.mass = Math.max(0.1, value); // Ensure mass is positive
                     }, 0.1, 0.1));
                 }
                 inspectorContent.appendChild(physicsSection);
             }

            // --- Collision (Conceptual - Only for Meshes) ---
             if (obj.collision && (threeObj.isMesh || threeObj.isGroup)) {
                 const collisionSection = createInspectorSection('Colis√£o (Conceitual)');
                 collisionSection.appendChild(createCheckbox('Habilitar Colis√£o', obj.collision.enabled, (checked) => { 
                     obj.collision.enabled = checked; 
                 }));
                 
                 if (obj.collision.enabled) {
                     collisionSection.appendChild(createCheckbox('√â Trigger', obj.collision.isTrigger, (checked) => { 
                         obj.collision.isTrigger = checked; 
                     }));
                     
                     collisionSection.appendChild(createNumberInput('Raio de Colis√£o', obj.collision.radius, (value) => {
                         obj.collision.radius = Math.max(0.1, value); // Ensure radius is positive
                     }, 0.1, 0.1));
                 }
                 
                 inspectorContent.appendChild(collisionSection);
             }

             // --- Delete Button ---
             const deleteSection = createInspectorSection(''); // No title
             const deleteBtn = document.createElement('button');
             deleteBtn.textContent = `Deletar ${obj.name}`;
             deleteBtn.addEventListener('click', () => {
                 if (confirm(`Tem certeza que deseja deletar ${obj.name}?`)) {
                     deleteObject(obj.id);
                 }
             });
             deleteSection.appendChild(deleteBtn);
             inspectorContent.appendChild(deleteSection);
        }

        // --- Inspector Helper Functions (Add Color and Number) ---
        function createNumberInput(label, value, onChange, step = 0.01, min = null, max = null) {
            const container = document.createElement('div');
            container.style.marginBottom = '8px';
            const labelElement = document.createElement('label');
            labelElement.textContent = label;
            container.appendChild(labelElement);

            const input = document.createElement('input');
            input.type = 'number';
            input.step = step;
            input.value = value;
            if (min !== null) input.min = min;
            if (max !== null) input.max = max;

            input.addEventListener('change', (e) => {
                const newValue = parseFloat(e.target.value);
                if (!isNaN(newValue)) {
                    onChange(newValue);
                    // Reformat to handle precision if needed
                    // e.target.value = newValue; // Or format as needed
                } else {
                    e.target.value = value; // Reset if invalid
                }
            });
            container.appendChild(input);
            return container;
        }

        function createColorInput(label, colorObject, onChange) {
             const container = document.createElement('div');
             container.style.marginBottom = '8px';
             const labelElement = document.createElement('label');
             labelElement.textContent = label;
             container.appendChild(labelElement);

             const input = document.createElement('input');
             input.type = 'color';
             input.value = `#${colorObject.getHexString()}`; // Get hex string from THREE.Color

             input.addEventListener('input', (e) => { // Use 'input' for live update
                 onChange(e.target.value); // Pass the hex string directly
             });
             container.appendChild(input);
             return container;
         }

        // --- Selection Highlight (Visual Helper) ---
        let selectionBox = null;
        function addSelectionHighlight(targetMesh) {
             removeSelectionHighlight(); // Remove previous one if exists
             if (targetMesh) {
                 selectionBox = new THREE.BoxHelper(targetMesh, 0x00ff00); // Green box
                 scene.add(selectionBox);
             }
        }
         function removeSelectionHighlight() {
             if (selectionBox) {
                 scene.remove(selectionBox);
                 selectionBox.dispose(); // Dispose geometry
                 selectionBox = null;
             }
         }


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();

            // --- Game Logic (Runs only when isPlaying is true) ---
            if (isPlaying) {
                // Apply physics to objects
                applyPhysicsAndCollisions(deltaTime);
                
                // Hide transform controls in play mode
                transformControl.visible = false;
            } else {
                // Update transform controls position in edit mode
                if (!isDragging && selectedObject) {
                    updateGizmoPosition();
                }
            }

            // Update controls only if not playing and not dragging
            if (!isPlaying && !isDragging) {
                controls.update(); // Required if enableDamping is true
            }

            // Update selection box if object moved/scaled and not playing
            if (selectionBox && selectedObject && !isPlaying) {
                selectionBox.update();
            }

            renderer.render(scene, camera);
        }

        // New function to handle physics and collisions
        function applyPhysicsAndCollisions(deltaTime) {
            // First, apply gravity and movement to all physics objects
            sceneObjects.forEach(obj => {
                if (obj.physics?.enabled && obj.threeObject.isMesh) {
                    // Get reference to the mesh and physics properties
                    const mesh = obj.threeObject;
                    const physics = obj.physics;
                    
                    // Skip if it's a kinematic object (moved by script, not physics)
                    if (!physics.isKinematic) {
                        // Apply gravity
                        physics.velocity.y -= 9.81 * deltaTime; // Acceleration due to gravity
                        
                        // Apply velocity to position
                        mesh.position.x += physics.velocity.x * deltaTime;
                        mesh.position.y += physics.velocity.y * deltaTime;
                        mesh.position.z += physics.velocity.z * deltaTime;
                        
                        // Basic ground collision
                        if (mesh.position.y < (obj.type === 'sphere' ? 0.5 : 0.5)) {
                            mesh.position.y = (obj.type === 'sphere' ? 0.5 : 0.5);
                            // Bounce with energy loss
                            if (Math.abs(physics.velocity.y) > 0.1) { // Only bounce if moving fast enough
                                physics.velocity.y = -physics.velocity.y * 0.6; // 60% bounce efficiency
                            } else {
                                physics.velocity.y = 0; // Stop if moving too slow
                            }
                        }
                    }
                }
            });
            
            // Then check for collisions between all pairs of collidable objects
            for (let i = 0; i < sceneObjects.length; i++) {
                const objA = sceneObjects[i];
                
                // Skip if not a mesh or collision not enabled
                if (!objA.collision?.enabled || !objA.threeObject.isMesh) continue;
                
                for (let j = i + 1; j < sceneObjects.length; j++) {
                    const objB = sceneObjects[j];
                    
                    // Skip if not a mesh or collision not enabled
                    if (!objB.collision?.enabled || !objB.threeObject.isMesh) continue;
                    
                    // Simple distance-based collision check
                    const meshA = objA.threeObject;
                    const meshB = objB.threeObject;
                    
                    const distance = meshA.position.distanceTo(meshB.position);
                    const combinedRadius = objA.collision.radius + objB.collision.radius;
                    
                    // If the distance is less than combined radius, collision has occurred
                    if (distance < combinedRadius) {
                        // Handle collision
                        handleCollision(objA, objB, distance, combinedRadius);
                    } else {
                        // Reset collision state
                        if (objA.collision.lastCollision === objB.id) {
                            objA.collision.lastCollision = null;
                        }
                        if (objB.collision.lastCollision === objA.id) {
                            objB.collision.lastCollision = null;
                        }
                    }
                }
            }
        }
        
        function handleCollision(objA, objB, distance, combinedRadius) {
            // Prevent responding to the same collision multiple times
            if (objA.collision.lastCollision === objB.id && objB.collision.lastCollision === objA.id) {
                return; // Already handling this collision
            }
            
            // Record collision
            objA.collision.lastCollision = objB.id;
            objB.collision.lastCollision = objA.id;
            
            console.log(`Collision between ${objA.name} and ${objB.name}`);
            
            // Handle different collision responses
            const meshA = objA.threeObject;
            const meshB = objB.threeObject;
            
            // If both have physics enabled, do physical response
            if (objA.physics?.enabled && objB.physics?.enabled && 
                !objA.physics.isKinematic && !objB.physics.isKinematic) {
                
                // Simple collision resolution - push objects apart
                const collisionNormal = new THREE.Vector3().subVectors(meshB.position, meshA.position).normalize();
                const overlap = combinedRadius - distance;
                
                // Push objects apart based on their masses
                const totalMass = objA.physics.mass + objB.physics.mass;
                const ratioA = objB.physics.mass / totalMass;
                const ratioB = objA.physics.mass / totalMass;
                
                meshA.position.sub(collisionNormal.clone().multiplyScalar(overlap * ratioA));
                meshB.position.add(collisionNormal.clone().multiplyScalar(overlap * ratioB));
                
                // Exchange momentum
                const velAAlongNormal = objA.physics.velocity.dot(collisionNormal);
                const velBAlongNormal = objB.physics.velocity.dot(collisionNormal);
                
                // Simple elastic collision formula
                const newVelA = velAAlongNormal * (objA.physics.mass - objB.physics.mass) + 
                               2 * objB.physics.mass * velBAlongNormal;
                const newVelB = velBAlongNormal * (objB.physics.mass - objA.physics.mass) + 
                               2 * objA.physics.mass * velAAlongNormal;
                
                // Apply new velocities
                objA.physics.velocity.addScaledVector(collisionNormal, newVelA - velAAlongNormal);
                objB.physics.velocity.addScaledVector(collisionNormal, newVelB - velBAlongNormal);
                
                // Add some energy loss
                objA.physics.velocity.multiplyScalar(0.95);
                objB.physics.velocity.multiplyScalar(0.95);
            } 
            else if (objA.collision.isTrigger || objB.collision.isTrigger) {
                // Handle trigger volumes - objects that don't physically block
                // but can trigger events (not implemented yet)
                console.log(`Trigger collision between ${objA.name} and ${objB.name}`);
            }
            else {
                // If no physics or one is kinematic, just push the non-kinematic one
                if (objA.physics?.enabled && !objA.physics.isKinematic) {
                    const pushDir = new THREE.Vector3().subVectors(meshA.position, meshB.position).normalize();
                    meshA.position.add(pushDir.multiplyScalar(combinedRadius - distance));
                } else if (objB.physics?.enabled && !objB.physics.isKinematic) {
                    const pushDir = new THREE.Vector3().subVectors(meshB.position, meshA.position).normalize();
                    meshB.position.add(pushDir.multiplyScalar(combinedRadius - distance));
                }
            }
        }

        // --- Event Listeners ---
         // ... handleResize, resizeObserver ...

        document.getElementById('newSceneBtn').addEventListener('click', createNewScene);
        document.getElementById('addCubeBtn').addEventListener('click', () => addObject('cube'));
        document.getElementById('addSphereBtn').addEventListener('click', () => addObject('sphere'));
        // Add listeners for new buttons
        document.getElementById('addAmbientLightBtn').addEventListener('click', addAmbientLight);
        document.getElementById('addDirectionalLightBtn').addEventListener('click', addDirectionalLight);
        document.getElementById('playBtn').addEventListener('click', togglePlayMode);


        // --- Start ---
        initThree();
        createNewScene(); // Start with an empty scene setup
        // Optionally add default lights on startup
        // addAmbientLight();
        // addDirectionalLight();

        // --- Inspector Helper Functions ---
        function createInspectorSection(title) {
            const section = document.createElement('div');
            section.className = 'inspector-section';
            if (title) {
                const heading = document.createElement('h4');
                heading.textContent = title;
                section.appendChild(heading);
            }
            return section;
        }

        function createVector3Input(label, vector, onChange, step = 0.01) {
            const container = document.createElement('div');
            container.style.marginBottom = '8px';
            const labelElement = document.createElement('label');
            labelElement.textContent = label;
            container.appendChild(labelElement);

            const inputGroup = document.createElement('div');
            inputGroup.className = 'vector3-input';

            ['x', 'y', 'z'].forEach(axis => {
                const axisDiv = document.createElement('div');
                const axisLabel = document.createElement('label');
                axisLabel.textContent = axis.toUpperCase();
                const input = document.createElement('input');
                input.type = 'number';
                input.step = step;
                input.value = vector[axis].toFixed(2); // Format
                input.addEventListener('change', (e) => { // Use change instead of input for less frequent updates
                    const newValue = parseFloat(e.target.value);
                    if (!isNaN(newValue)) {
                        onChange(axis, newValue);
                         // Re-read and format to handle potential precision issues or THREE updates
                         e.target.value = vector[axis].toFixed(2);
                    } else {
                        // Reset if invalid input
                        e.target.value = vector[axis].toFixed(2);
                    }
                });
                 axisDiv.appendChild(axisLabel);
                 axisDiv.appendChild(input);
                 inputGroup.appendChild(axisDiv);
            });

            container.appendChild(inputGroup);
            return container;
        }

         function createCheckbox(label, isChecked, onChange) {
             const container = document.createElement('div');
             container.style.marginBottom = '5px';
             const checkbox = document.createElement('input');
             checkbox.type = 'checkbox';
             checkbox.checked = isChecked;
             checkbox.id = `check_${label.replace(/\s+/g, '_')}`; // Create unique ID
             checkbox.addEventListener('change', (e) => onChange(e.target.checked));

             const labelElement = document.createElement('label');
             labelElement.textContent = label;
             labelElement.htmlFor = checkbox.id; // Associate label with checkbox

             container.appendChild(checkbox);
             container.appendChild(labelElement);
             return container;
         }

        function createDropdown(label, options, selectedValue, onChange) {
            const container = document.createElement('div');
            container.style.marginBottom = '8px';
            const labelElement = document.createElement('label');
            labelElement.textContent = label;
            container.appendChild(labelElement);

            const select = document.createElement('select');
            options.forEach(option => {
                const optElement = document.createElement('option');
                optElement.value = option;
                optElement.textContent = option.charAt(0).toUpperCase() + option.slice(1); // Capitalize
                if (option === selectedValue) {
                    optElement.selected = true;
                }
                select.appendChild(optElement);
            });
            select.addEventListener('change', (e) => onChange(e.target.value));
            container.appendChild(select);
            return container;
        }

        // Fun√ß√£o para configurar o gizmo de transforma√ß√£o
        function setupTransformControls() {
            // Crie os eixos de transforma√ß√£o (gizmos)
            const gizmoGroup = new THREE.Group();
            gizmoGroup.name = "TransformGizmo";
            scene.add(gizmoGroup);

            // Eixos X, Y, Z com cores distintas
            const axisLength = 1.5;
            const axisRadius = 0.03;
            
            // Eixo X (vermelho)
            const xAxisGeometry = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8);
            xAxisGeometry.rotateZ(Math.PI/2);
            const xAxisMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                depthTest: false,  // Isso far√° o eixo sempre vis√≠vel
                transparent: true,
                opacity: 0.8
            });
            const xAxis = new THREE.Mesh(xAxisGeometry, xAxisMaterial);
            xAxis.position.set(axisLength/2, 0, 0);
            xAxis.name = "x-axis";
            xAxis.renderOrder = 1; // Maior renderOrder ser√° renderizado depois
            
            // Cone para o eixo X
            const xConeGeometry = new THREE.ConeGeometry(axisRadius*2, axisRadius*6, 8);
            xConeGeometry.rotateZ(-Math.PI/2);
            const xCone = new THREE.Mesh(xConeGeometry, xAxisMaterial);
            xCone.position.set(axisLength, 0, 0);
            xCone.name = "x-cone";
            xCone.renderOrder = 1;
            
            // Eixo Y (verde)
            const yAxisGeometry = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8);
            const yAxisMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00,
                depthTest: false,
                transparent: true,
                opacity: 0.8
            });
            const yAxis = new THREE.Mesh(yAxisGeometry, yAxisMaterial);
            yAxis.position.set(0, axisLength/2, 0);
            yAxis.name = "y-axis";
            yAxis.renderOrder = 1;
            
            // Cone para o eixo Y
            const yConeGeometry = new THREE.ConeGeometry(axisRadius*2, axisRadius*6, 8);
            const yCone = new THREE.Mesh(yConeGeometry, yAxisMaterial);
            yCone.position.set(0, axisLength, 0);
            yCone.name = "y-cone";
            yCone.renderOrder = 1;
            
            // Eixo Z (azul)
            const zAxisGeometry = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 8);
            zAxisGeometry.rotateX(Math.PI/2);
            const zAxisMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x0000ff,
                depthTest: false,
                transparent: true,
                opacity: 0.8
            });
            const zAxis = new THREE.Mesh(zAxisGeometry, zAxisMaterial);
            zAxis.position.set(0, 0, axisLength/2);
            zAxis.name = "z-axis";
            zAxis.renderOrder = 1;
            
            // Cone para o eixo Z
            const zConeGeometry = new THREE.ConeGeometry(axisRadius*2, axisRadius*6, 8);
            zConeGeometry.rotateX(Math.PI/2);
            const zCone = new THREE.Mesh(zConeGeometry, zAxisMaterial);
            zCone.position.set(0, 0, axisLength);
            zCone.name = "z-cone";
            zCone.renderOrder = 1;
            
            // Adicione os eixos ao grupo
            gizmoGroup.add(xAxis, xCone, yAxis, yCone, zAxis, zCone);
            
            // Configure o controle de transforma√ß√£o
            transformControl = gizmoGroup;
            transformControl.visible = false; // Inicialmente oculto
            
            console.log("Gizmo criado:", transformControl);
            
            return transformControl;
        }

        // Fun√ß√£o que atualiza a posi√ß√£o do gizmo para acompanhar o objeto selecionado
        function updateGizmoPosition() {
            if (selectedObject && selectedObject.threeObject && 
               (selectedObject.threeObject.isMesh || selectedObject.threeObject.isGroup)) {
                transformControl.position.copy(selectedObject.threeObject.position);
                transformControl.visible = true;
                console.log("Gizmo atualizado para posi√ß√£o:", 
                     selectedObject.threeObject.position.x,
                     selectedObject.threeObject.position.y,
                     selectedObject.threeObject.position.z);
            } else {
                transformControl.visible = false;
            }
        }

        // Fun√ß√µes de manipula√ß√£o de eventos de mouse
        function onMouseDown(event) {
            if (isPlaying || !selectedObject) return;
            
            // Calcule as coordenadas corretas do mouse relativas √† canvas, n√£o √† janela
            const rect = sceneCanvas.getBoundingClientRect();
            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Configure o raycaster
            raycaster.setFromCamera(pointer, camera);
            
            // Verifique interse√ß√µes com os eixos do gizmo
            if (transformControl.visible) {
                // Obtenha todos os objetos do gizmo (incluindo cones e eixos)
                const gizmoObjects = [];
                transformControl.traverse(object => {
                    if (object.isMesh) gizmoObjects.push(object);
                });
                
                const intersects = raycaster.intersectObjects(gizmoObjects);
                
                if (intersects.length > 0) {
                    isDragging = true;
                    controls.enabled = false; // Desabilite os controles orbitais durante o arrasto
                    
                    // Extraia apenas o identificador do eixo (x, y, z)
                    selectedAxis = intersects[0].object.name.split('-')[0]; 
                    console.log("Selecionou eixo:", selectedAxis, "Modo:", transformMode);
                    
                    // Guarde a posi√ß√£o inicial do objeto
                    objectStartPosition.copy(selectedObject.threeObject.position);
                    
                    // Configure o plano de arrasto com base no eixo selecionado
                    const planeNormal = new THREE.Vector3();
                    if (selectedAxis === 'x') {
                        planeNormal.set(0, 1, 1).normalize();
                    } else if (selectedAxis === 'y') {
                        planeNormal.set(1, 0, 1).normalize();
                    } else if (selectedAxis === 'z') {
                        planeNormal.set(1, 1, 0).normalize();
                    }
                    
                    dragPlane.setFromNormalAndCoplanarPoint(
                        planeNormal, 
                        selectedObject.threeObject.position
                    );
                    
                    // Encontre o ponto de interse√ß√£o inicial no plano
                    raycaster.ray.intersectPlane(dragPlane, dragStartPosition);
                }
            }
        }

        function onMouseMove(event) {
            if (!isDragging || !selectedAxis) return;
            
            // Calcule as coordenadas corretas do mouse
            const rect = sceneCanvas.getBoundingClientRect();
            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            // Configure o raycaster
            raycaster.setFromCamera(pointer, camera);
            
            // Encontre o novo ponto de interse√ß√£o no plano
            if (raycaster.ray.intersectPlane(dragPlane, dragIntersection)) {
                // Calcule o deslocamento
                const delta = new THREE.Vector3().subVectors(dragIntersection, dragStartPosition);
                
                // Aplique o deslocamento com base no modo de transforma√ß√£o
                console.log("Movendo no modo:", transformMode, "Eixo:", selectedAxis);
                
                if (transformMode === 'translate') {
                    const newPosition = new THREE.Vector3().copy(objectStartPosition);
                    // Modo de transla√ß√£o
                    if (selectedAxis === 'x') newPosition.x += delta.x;
                    else if (selectedAxis === 'y') newPosition.y += delta.y;
                    else if (selectedAxis === 'z') newPosition.z += delta.z;
                    
                    // Atualize a posi√ß√£o do objeto
                    selectedObject.threeObject.position.copy(newPosition);
                    
                } else if (transformMode === 'rotate') {
                    // Modo de rota√ß√£o (implementa√ß√£o simplificada)
                    const rotationSpeed = 0.01;
                    let rotationAxis = new THREE.Vector3();
                    
                    if (selectedAxis === 'x') {
                        rotationAxis.set(1, 0, 0);
                        selectedObject.threeObject.rotateOnAxis(rotationAxis, rotationSpeed * delta.y);
                    } else if (selectedAxis === 'y') {
                        rotationAxis.set(0, 1, 0);
                        selectedObject.threeObject.rotateOnAxis(rotationAxis, rotationSpeed * delta.x);
                    } else if (selectedAxis === 'z') {
                        rotationAxis.set(0, 0, 1);
                        const dragAmount = (delta.x + delta.y) * 0.5;
                        selectedObject.threeObject.rotateOnAxis(rotationAxis, rotationSpeed * dragAmount);
                    }
                    
                } else if (transformMode === 'scale') {
                    // Modo de escala
                    const scaleSpeed = 0.01;
                    const scaleDelta = delta.length() * scaleSpeed * (delta.dot(camera.position) > 0 ? 1 : -1);
                    
                    if (selectedAxis === 'x') {
                        selectedObject.threeObject.scale.x = Math.max(0.1, selectedObject.threeObject.scale.x + scaleDelta);
                    } else if (selectedAxis === 'y') {
                        selectedObject.threeObject.scale.y = Math.max(0.1, selectedObject.threeObject.scale.y + scaleDelta);
                    } else if (selectedAxis === 'z') {
                        selectedObject.threeObject.scale.z = Math.max(0.1, selectedObject.threeObject.scale.z + scaleDelta);
                    }
                }
                
                // Atualize a posi√ß√£o do gizmo para acompanhar o objeto
                updateGizmoPosition();
                
                // Se houver selection box, atualize-o
                if (selectionBox) {
                    selectionBox.update();
                }
            }
        }

        function onMouseUp() {
            isDragging = false;
            selectedAxis = null;
            controls.enabled = true; // Reabilite os controles orbitais
        }

        // Fun√ß√£o para definir o modo de transforma√ß√£o
        function setTransformMode(mode) {
            transformMode = mode;
            console.log("Modo de transforma√ß√£o alterado para:", mode);
            
            // Atualize a UI para mostrar qual bot√£o est√° ativo
            document.querySelectorAll('.transform-mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            document.getElementById(`transformMode${mode.charAt(0).toUpperCase() + mode.slice(1)}`).classList.add('active');
            
            // Voc√™ pode tamb√©m querer alterar a apar√™ncia do gizmo com base no modo
            if (selectedObject && transformControl) {
                // Exemplo: poder√≠amos mudar a apar√™ncia do gizmo com base no modo
                // (n√£o implementado mas poderia ser adicionado)
            }
        }

        // Ao final da inicializa√ß√£o, certifique-se que o modo padr√£o √© aplicado:
        setTransformMode('translate'); // Aplica o modo padr√£o

    </script>
</body>
</html>