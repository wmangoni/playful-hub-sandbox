<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KM6SHZXP');</script>
    <!-- End Google Tag Manager -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Canvas Doom-Style Shooter</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111; /* Dark background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
             font-family: 'Arial', sans-serif; /* Basic fallback font */
        }
        #gameContainer {
            position: relative; /* Needed for overlays */
             width: 800px;
             height: 600px;
             box-shadow: 0 0 20px rgba(255, 0, 0, 0.3); /* Subtle red glow */
             border: 2px solid #444;
        }
        canvas {
            display: block;
            background-color: #000; /* Fallback if rendering fails */
             width: 100%;
             height: 100%;
        }
         #ad-container {
             position: absolute;
             bottom: -80px; /* Position below canvas initially */
             left: 50%;
             transform: translateX(-50%);
             width: 728px; /* Standard banner size */
             height: 90px;
             display: none; /* Hidden until start screen */
             background: #222; /* Placeholder bg */
             border: 1px solid #444;
         }
        /* --- Styles for UI Elements --- */
         .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
             font-family: 'Courier New', Courier, monospace; /* Retro font */
             padding: 20px;
             box-sizing: border-box;
             opacity: 0;
             visibility: hidden;
             transition: opacity 0.5s, visibility 0s linear 0.5s;
             z-index: 10;
        }
         .overlay.show {
             opacity: 1;
             visibility: visible;
             transition: opacity 0.5s;
         }
         .overlay h1 {
             color: #FF4500; /* Orange-Red */
             font-size: 3.5em;
             margin-bottom: 20px;
             text-shadow: 3px 3px 0px #8B0000; /* Dark Red shadow */
         }
          .overlay h2 {
             color: #FFCC00; /* Yellow */
             font-size: 1.8em;
             margin-bottom: 30px;
         }
         .overlay p {
             font-size: 1.2em;
             line-height: 1.6;
             margin-bottom: 15px;
             max-width: 600px;
         }
         .overlay button {
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.5em;
            font-weight: bold;
            padding: 15px 30px;
            background-color: #8B0000; /* Dark Red */
            color: #FFCC00; /* Yellow text */
            border: 3px solid #FFCC00;
            cursor: pointer;
            margin-top: 20px;
            transition: background-color 0.2s, color 0.2s;
            box-shadow: 4px 4px 0px #400;
         }
         .overlay button:hover {
            background-color: #FF4500;
             color: white;
              box-shadow: 4px 4px 0px #800;
         }
          .control-info {
             display: flex;
             justify-content: center;
             gap: 20px;
             margin-top: 20px;
             font-size: 1em;
          }
          .control-info div {
             background: #333;
             padding: 5px 10px;
             border-radius: 4px;
             border: 1px solid #666;
         }
          .control-info span {
             font-weight: bold;
             color: #FFCC00;
          }
    </style>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KM6SHZXP"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <!-- Overlays for UI States -->
        <div id="startScreen" class="overlay show">
            <h1>RETRO SHOOTER</h1>
            <h2>Canvas Mayhem</h2>
            <p>Eliminate all hostile entities. Use WASD/Arrows to move, Mouse to aim/turn, Click/Space to shoot, Keys 1/2 to switch weapons. ESC to Pause.</p>
             <div class="control-info">
                <div><span>Move:</span> WASD / ↑↓</div>
                 <div><span>Strafe:</span> A / D</div>
                 <div><span>Turn:</span> ←→ / Mouse</div>
                 <div><span>Shoot:</span> Click / Space</div>
                 <div><span>Weapon:</span> 1 / 2</div>
                <div><span>Pause:</span> ESC</div>
            </div>
            <button id="startButton">BEGIN CARNAGE</button>
            <!-- Ad container visible only on start screen initially -->
             <div id="ad-container" style="margin-top: 20px;">
                <!-- publi_lateral -->
                <ins class="adsbygoogle"
                     style="display:block"
                     data-ad-client="ca-pub-6741914590073026"
                     data-ad-slot="6424450308"
                     data-ad-format="auto"
                     data-full-width-responsive="true"></ins>
                <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script>
            </div>
        </div>

        <div id="pauseScreen" class="overlay">
            <h1>PAUSED</h1>
            <p>Take a breather... but not for too long.</p>
            <button id="resumeButton">RESUME</button>
        </div>

        <div id="gameOverScreen" class="overlay">
            <h1>YOU DIED</h1>
            <h2 id="finalScore">Final Score: 0</h2>
            <p>The darkness consumes you. Try again?</p>
            <button id="restartButton">RESTART</button>
        </div>

    </div>

    <script>
        const DEBUG = false;
        // --- Add near the top with other constants ---
        const OPTIMIZE_MODE = 1; // 0 = High Quality (potentially slow), 1 = Optimized, 2 = Max Performance (lower res)

        // --- Modify Screen Width based on mode (Adjust these values as needed) ---
        const baseScreenWidth = 800;
        const screenWidth = (OPTIMIZE_MODE === 2) ? baseScreenWidth / 2 : baseScreenWidth; // Halve resolution in Max Perf mode
        const screenHeight = (OPTIMIZE_MODE === 2) ? 600 / 2 : 600; // Adjust height proportionally if desired, or keep original for stretching

        // --- Canvas and Context ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = screenWidth;
        canvas.height = screenHeight;

        // --- UI Elements ---
        const startScreen = document.getElementById('startScreen');
        const pauseScreen = document.getElementById('pauseScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startButton = document.getElementById('startButton');
        const resumeButton = document.getElementById('resumeButton');
        const restartButton = document.getElementById('restartButton');
        const finalScoreElement = document.getElementById('finalScore');
        const adContainer = document.getElementById('ad-container');

        // --- Game State ---
        let gameStarted = false;
        let isPaused = false;
        let isGameOver = false;
        let player = {}; // Initialize later
        let enemies = []; // Initialize later
        let map = []; // Initialize later
        let pickups = []; // Health / Ammo
        let particles = []; // For impacts, etc.
        let zBuffer = new Array(screenWidth).fill(Infinity);
        let lastTimestamp = 0;
        let deltaTime = 0; // Time difference between frames in seconds
        let weaponBobAngle = 0;
        let currentRecoil = 0; // For weapon animation
        const maxRecoil = 0.1;
        const recoilRecovery = 5; // Higher = faster recovery
        let damageOverlayAlpha = 0; // For red screen flash


        // --- Constants ---
        const FOV = 65 * Math.PI / 180; // Field of View
        const angleStep = FOV / screenWidth;
        const moveSpeedBase = 3.0; // Units per second
        const rotSpeedKey = 2.5; // Radians per second (Keyboard)
        const rotSpeedMouse = 0.0025; // Radians per pixel moved
        const fogDepth = 12; // Distance where fog becomes thick
        const wallHeightMultiplier = 1.0; // Adjust overall wall height scale
        const pickupBobSpeed = 2;
        const pickupBobAmount = 0.05;

        // Map Data (1-4: Walls, 5: Health Pickup, 6: Ammo Pickup)
        const mapData = [
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 6, 0, 0, 1],
          [1, 0, 2, 2, 0, 1, 1, 0, 1, 1, 0, 3, 0, 1, 0, 0, 0, 0, 0, 1],
          [1, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 3, 0, 1, 1, 1, 1, 0, 1, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 1, 0, 0, 1],
          [1, 1, 1, 0, 1, 1, 1, 4, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 1, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 3, 3, 0, 0, 1, 4, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1],
          [1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1],
          [1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 5, 1],
          [1, 5, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [1, 0, 4, 4, 4, 4, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 4, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 1],
          [1, 0, 4, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];
        const mapWidth = mapData[0].length;
        const mapHeight = mapData.length;

        // Texture/Color Definitions
        const wallColors = {
          1: {
            base: '#8B4513',
            pattern: 'lines',
            color1: '#A0522D',
            color2: '#6B3E1A'
          }, // Brown Brick
          2: {
            base: '#696969',
            pattern: 'grid',
            color1: '#808080',
            color2: '#505050'
          }, // Grey Metal
          3: {
            base: '#A52A2A',
            pattern: 'noise',
            color1: '#BF3A3A',
            color2: '#8B2222'
          }, // Dark Red Stone
          4: {
            base: '#006400',
            pattern: 'slime',
            color1: '#2E8B57',
            color2: '#004000'
          }, // Green Slime/Moss
        };
        const floorColor1 = "#4A3A2A"; // Darker brown
        const floorColor2 = "#5A4A3A"; // Lighter brown
        const ceilingColor1 = "#465058"; // Dark grey-blue
        const ceilingColor2 = "#5A6874"; // Lighter grey-blue

        // --- Enemy Definitions ---
        const enemyTypes = {
          grunt: {
            health: 50,
            speed: 1.5,
            damage: 8,
            size: 0.5,
            color: '#1E6F5C',
            scoreValue: 100,
            attackRange: 1.5,
            sightRange: 10,
            soundHurt: 'gruntHurt',
            soundDeath: 'gruntDeath',
            soundAlert: 'gruntAlert'
          },
          demon: {
            health: 150,
            speed: 1.0,
            damage: 20,
            size: 0.7,
            color: '#D21D1D',
            scoreValue: 250,
            attackRange: 2.0,
            sightRange: 12,
            soundHurt: 'demonHurt',
            soundDeath: 'demonDeath',
            soundAlert: 'demonAlert'
          }
        };

        // Add sound keys to weapon definitions
        const weapons = {
          pistol: {
            name: "Pistol",
            damage: 18,
            fireRate: 0.3,
            ammo: 15,
            maxAmmo: 60,
            reloadTime: 1.5,
            spread: 0.03,
            projectiles: 1,
            sound: 'shootPistol',
            automatic: false,
            sprite: {
              w: 80,
              h: 100,
              color1: '#555',
              color2: '#333'
            }
          },
          shotgun: {
            name: "Shotgun",
            damage: 12,
            fireRate: 0.8,
            ammo: 8,
            maxAmmo: 24,
            reloadTime: 2.5,
            spread: 0.25,
            projectiles: 6,
            sound: 'shootShotgun',
            automatic: false,
            sprite: {
              w: 100,
              h: 90,
              color1: '#4a2e1a',
              color2: '#2a1a0e'
            }
          },
          // Add other weapons if any
        };

        // Variable to hold the looping proximity sound instance
        let proximitySoundInstance = null;

        // Sound key for proximity sound
        const ENEMY_PROXIMITY_SOUND_KEY = 'enemyCloseLoop';
        const ENEMY_PROXIMITY_THRESHOLD = 4.5; // Units distance to trigger sound

        const defaultWeapon = 'pistol';

        // --- Pickup Definitions ---
        const pickupTypes = {
          health_small: {
            type: 5,
            size: 0.3,
            color: '#ff6b6b',
            bob: true,
            amount: 25,
            target: 'health',
            sound: 'pickupHealth'
          },
          ammo_small: {
            type: 6,
            size: 0.3,
            color: '#4ecdc4',
            bob: true,
            amount: 10,
            target: 'ammo',
            sound: 'pickupAmmo'
          },
          // Gives ammo for current weapon
        };

        // --- Input Tracking ---
        const keys = {
          w: false,
          a: false,
          s: false,
          d: false,
          ArrowUp: false,
          ArrowDown: false,
          ArrowLeft: false,
          ArrowRight: false,
          ' ': false,
          Escape: false,
          '1': false,
          '2': false
        };
        let mouseX = 0;
        let mouseY = 0;
        let isMouseDown = false;
        let mouseDeltaX = 0;


        // --- Sound System (Web Audio API) ---
        let audioContext;
        let masterGain;
        const soundBuffers = {}; // Store loaded audio buffers
        const activeSounds = new Set(); // Track currently playing sounds for stopping/panning
        let isAudioInitialized = false;

        // --- Initialize Game ---
        function initializeGame() {
          map = mapData.map(row => [...row]); // Deep copy map data
          player = {
            x: 3.5,
            y: 3.5, // Start in an open area
            angle: Math.PI * 1.5, // Look down
            health: 100,
            maxHealth: 100,
            currentWeapon: defaultWeapon,
            weapons: JSON.parse(JSON.stringify(weapons)), // Deep copy weapon stats
            lastShotTimestamp: 0,
            isReloading: false,
            reloadTimer: 0,
            score: 0,
            isMoving: false
          };
          enemies = [ // Initial enemy placement
            {
              x: 6.5,
              y: 1.5,
              type: 'grunt',
              id: `enemy_${Date.now()}_0`
            },
            {
              x: 14.5,
              y: 6.5,
              type: 'demon',
              id: `enemy_${Date.now()}_1`
            },
            {
              x: 10.5,
              y: 10.5,
              type: 'grunt',
              id: `enemy_${Date.now()}_2`
            },
            {
              x: 1.5,
              y: 8.5,
              type: 'grunt',
              id: `enemy_${Date.now()}_3`
            },
            {
              x: 16.5,
              y: 14.5,
              type: 'demon',
              id: `enemy_${Date.now()}_4`
            },
            {
              x: 2.5,
              y: 15.5,
              type: 'grunt',
              id: `enemy_${Date.now()}_5`
            }
          ].map(e => ({
            ...e,
            ...enemyTypes[e.type], // Copy base stats
            angle: Math.random() * Math.PI * 2,
            state: 'idle', // idle, chase, attack, dying, dead
            lastAttackTimestamp: 0,
            targetPos: null,
            currentHealth: enemyTypes[e.type].health,
            lastHitTimestamp: 0,
            isHit: false,
            isVisible: true,
          }));
          pickups = []; // Clear previous pickups
          particles = []; // Clear particles
          scanMapForPickups(); // Populate pickups based on map codes
          isGameOver = false;
          isPaused = false;
          damageOverlayAlpha = 0;
          finalScoreElement.textContent = 'Score: 0'; // Use a separate score element for HUD later?
          updateHUD(); // Initial HUD update
        }

        function scanMapForPickups() {
          for (let y = 0; y < mapHeight; y++) {
            for (let x = 0; x < mapWidth; x++) {
              const cellType = mapData[y][x]; // Check original data
              for (const key in pickupTypes) {
                if (pickupTypes[key].type === cellType) {
                  pickups.push({
                    x: x + 0.5,
                    y: y + 0.5,
                    id: `pickup_${x}_${y}`,
                    ...pickupTypes[key]
                  });
                  // Optional: clear the pickup number from the playable map array
                  // map[y][x] = 0;
                }
              }
            }
          }
        }

        // --- Audio Functions ---
        async function initAudio() {
          if (isAudioInitialized || !document.hasFocus()) return; // Avoid init if tab not focused
          try {
            audioContext = new(window.AudioContext || window.webkitAudioContext)();
            masterGain = audioContext.createGain();
            masterGain.gain.value = 0.7; // Master volume
            masterGain.connect(audioContext.destination);
            isAudioInitialized = true;
            console.log("Audio Context Initialized.");
            // --- Preload basic sounds (replace with actual file loading) ---
            // Example: loadSound('shootPistol', 'sounds/pistol.wav');
            // loadSound('pickupHealth', 'sounds/health_pickup.wav');
            // For now, we'll just use placeholders
          } catch (e) {
            console.error("Error initializing Audio Context:", e);
            isAudioInitialized = false;
          }
        }

        // Placeholder function - replace with actual sound loading
        /*
        async function loadSound(name, url) {
            if (!isAudioInitialized) return;
            try {
                const response = await fetch(url);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                soundBuffers[name] = audioBuffer;
                console.log(`Sound loaded: ${name}`);
            } catch (e) {
                console.error(`Error loading sound ${name}:`, e);
            }
        }
        */

        function playSound(name, volume = 1.0, playbackRate = 1.0, sourcePos = null, loop = false) {
          if (!isAudioInitialized || masterGain.gain.value === 0) return null;
          
          let effectiveVolume = volume;
          let panner = null;
          let distanceGain = null;
          
          // Basic placeholder synth/log if buffer not loaded
          if (!soundBuffers[name]) {
            if (DEBUG) {
              console.log(`SOUND (Placeholder): ${name}, Vol: ${volume.toFixed(2)}`, sourcePos ? `Pos: (${sourcePos.x.toFixed(1)},${sourcePos.y.toFixed(1)})` : '');
            }
            
            // Optional: Basic Beep for feedback
            /*
            if (audioContext && name.includes('shoot')) { // Only beep for shooting for now
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.type = 'triangle';
                osc.frequency.value = name === 'shootShotgun' ? 440 : 880; // Different pitch
                gain.gain.setValueAtTime(0.3 * volume, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
                osc.connect(gain).connect(masterGain);
                osc.start();
                osc.stop(audioContext.currentTime + 0.1);
                 return null; // Indicate no buffer source node
            }
            */
            return null;
          }
          
          // --- Positional Audio & Attenuation ---
          if (sourcePos && player) {
            const dx = sourcePos.x - player.x;
            const dy = sourcePos.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Distance Attenuation (Inverse square, clamped)
            const refDistance = 1.0; // Distance at which volume is 1.0
            const rolloffFactor = 1.5; // How quickly volume drops off
            const calculatedVolume = refDistance / (refDistance + rolloffFactor * (Math.max(0, distance - refDistance)));
            effectiveVolume *= Math.max(0, Math.min(1, calculatedVolume));
            
            // Panning (Stereo)
            panner = audioContext.createStereoPanner();
            const sourceAngle = Math.atan2(dy, dx);
            let relativeAngle = sourceAngle - player.angle;
            // Normalize angle to [-PI, PI]
            while (relativeAngle <= -Math.PI) relativeAngle += 2 * Math.PI;
            while (relativeAngle > Math.PI) relativeAngle -= 2 * Math.PI;
            
            // Map angle to pan value [-1, 1] - adjust FOV influence as needed
            const maxPanAngle = FOV * 0.8; // Don't pan fully at edge of FOV
            panner.pan.value = Math.max(-1, Math.min(1, relativeAngle / maxPanAngle));
            
            // Gain node for distance calculation
            distanceGain = audioContext.createGain();
            distanceGain.gain.value = effectiveVolume;
            
          } else {
            // Non-positional sound uses only the master gain and requested volume
            distanceGain = audioContext.createGain();
            distanceGain.gain.value = effectiveVolume;
          }
          
          
          // --- Play the Sound ---
          const source = audioContext.createBufferSource();
          source.buffer = soundBuffers[name];
          source.playbackRate.value = playbackRate;
          source.loop = loop;
          
          let currentNode = source;
          if (panner) {
            currentNode = currentNode.connect(panner);
          }
          currentNode = currentNode.connect(distanceGain);
          distanceGain.connect(masterGain);
          
          source.start();
          
          const soundInstance = {
            source,
            distanceGain,
            panner,
            name,
            startTime: audioContext.currentTime
          };
          activeSounds.add(soundInstance);
          source.onended = () => {
            activeSounds.delete(soundInstance);
          };
          return soundInstance; // Return node if needed for manipulation
        }

        function stopSound(soundInstance) {
          if (soundInstance && soundInstance.source) {
            try {
              soundInstance.source.stop();
              activeSounds.delete(soundInstance);
            } catch (e) {
              console.error("Error stopping sound:", e);
            }
          }
        }

        function updatePositionalSound(soundInstance, newSourcePos) {
          if (!isAudioInitialized || !soundInstance || !newSourcePos || !player || masterGain.gain.value === 0) return;
          if (!soundInstance.panner || !soundInstance.distanceGain) return; // Not a positional sound
          
          const dx = newSourcePos.x - player.x;
          const dy = newSourcePos.y - player.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          // Update Gain (Volume based on distance)
          const refDistance = 1.0;
          const rolloffFactor = 1.5;
          const calculatedVolume = refDistance / (refDistance + rolloffFactor * (Math.max(0, distance - refDistance)));
          soundInstance.distanceGain.gain.setTargetAtTime(Math.max(0, Math.min(1, calculatedVolume)), audioContext.currentTime, 0.05); // Smooth change
          
          // Update Panner (Stereo position)
          const sourceAngle = Math.atan2(dy, dx);
          let relativeAngle = sourceAngle - player.angle;
          while (relativeAngle <= -Math.PI) relativeAngle += 2 * Math.PI;
          while (relativeAngle > Math.PI) relativeAngle -= 2 * Math.PI;
          const maxPanAngle = FOV * 0.8;
          const panValue = Math.max(-1, Math.min(1, relativeAngle / maxPanAngle));
          soundInstance.panner.pan.setTargetAtTime(panValue, audioContext.currentTime, 0.05); // Smooth change
        }


        // --- Input Handlers ---
        function setupInputHandlers() {
          document.addEventListener('keydown', (e) => {
            if (e.key in keys) keys[e.key.toLowerCase()] = true; // Handle WASD case insensitivity
            if (e.key === 'Escape') {
              if (gameStarted && !isGameOver) togglePause();
            }
            if (e.key >= '1' && e.key <= '9') { // Weapon switch keys
              switchWeapon(parseInt(e.key));
            }
            // Init audio on first keydown
            initAudio();
          });
          document.addEventListener('keyup', (e) => {
            if (e.key in keys) keys[e.key.toLowerCase()] = false;
          });
          canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0 && gameStarted && !isPaused && !isGameOver) { // Left click
              isMouseDown = true;
              // Request pointer lock for better mouse control
              if (!document.pointerLockElement) {
                canvas.requestPointerLock().catch(err => console.error("Pointer lock failed:", err));
              }
            }
            initAudio(); // Init audio on first click
          });
          canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) isMouseDown = false;
          });
          canvas.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === canvas) {
              mouseDeltaX += e.movementX; // Accumulate movementX when locked
            } else {
              // Keep track even if not locked for UI interaction?
              // Maybe not needed if UI buttons handle clicks directly
            }
          });
          
          // UI Button Listeners
          startButton.addEventListener('click', startGame);
          resumeButton.addEventListener('click', togglePause);
          restartButton.addEventListener('click', () => {
            initializeGame();
            gameOverScreen.classList.remove('show');
            gameStarted = true; // Assume restart means start game
            lastTimestamp = performance.now(); // Reset timer
            requestAnimationFrame(gameLoop); // Resume loop immediately
          });
        }

        function processInput(dt) {
          if (isPaused || isGameOver) return;
          
          let forwardMove = 0;
          let strafeMove = 0;
          let rotateMove = 0;
          
          // Keyboard Movement
          if (keys.w || keys.ArrowUp) forwardMove += 1;
          if (keys.s || keys.ArrowDown) forwardMove -= 1;
          if (keys.a) strafeMove -= 1;
          if (keys.d) strafeMove += 1;
          if (keys.ArrowLeft) rotateMove -= 1;
          if (keys.ArrowRight) rotateMove += 1;
          
          player.isMoving = (forwardMove !== 0 || strafeMove !== 0);
          
          // Apply Rotation
          const finalRotSpeedKey = rotateMove * rotSpeedKey * dt;
          const finalRotSpeedMouse = mouseDeltaX * rotSpeedMouse; // Apply accumulated mouse movement
          player.angle += finalRotSpeedKey + finalRotSpeedMouse;
          player.angle = (player.angle + 2 * Math.PI) % (2 * Math.PI); // Normalize angle
          mouseDeltaX = 0; // Reset accumulated mouse delta
          
          
          // Apply Movement (with simple collision detection)
          const moveStep = moveSpeedBase * dt;
          const moveAngle = player.angle;
          const strafeAngle = player.angle + Math.PI / 2;
          
          const totalMoveX = (Math.cos(moveAngle) * forwardMove + Math.cos(strafeAngle) * strafeMove) * moveStep;
          const totalMoveY = (Math.sin(moveAngle) * forwardMove + Math.sin(strafeAngle) * strafeMove) * moveStep;
          
          const nextPlayerX = player.x + totalMoveX;
          const nextPlayerY = player.y + totalMoveY;
          const collisionRadius = 0.2; // Prevent getting too close to walls
          
          // Check collision for X movement separately
          const nextTileX = Math.floor(nextPlayerX + Math.sign(totalMoveX) * collisionRadius);
          const currentTileY = Math.floor(player.y);
          if (isWall(nextTileX, currentTileY) || isWall(nextTileX, Math.floor(player.y + collisionRadius)) || isWall(nextTileX, Math.floor(player.y - collisionRadius))) {
            // Hit wall in X direction
            player.x += 0; // Stop X movement
          } else {
            player.x = nextPlayerX;
          }
          
          // Check collision for Y movement separately (using the potentially updated X position)
          const nextTileY = Math.floor(nextPlayerY + Math.sign(totalMoveY) * collisionRadius);
          const currentTileX = Math.floor(player.x); // Use current (potentially updated) X
          if (isWall(currentTileX, nextTileY) || isWall(Math.floor(player.x + collisionRadius), nextTileY) || isWall(Math.floor(player.x - collisionRadius), nextTileY)) {
            // Hit wall in Y direction
            player.y += 0; // Stop Y movement
          } else {
            player.y = nextPlayerY;
          }
          
          // Clamp player position to map boundaries (optional, safety net)
          player.x = Math.max(collisionRadius, Math.min(mapWidth - collisionRadius, player.x));
          player.y = Math.max(collisionRadius, Math.min(mapHeight - collisionRadius, player.y));
          
          
          // Shooting (check mouse and spacebar)
          const weapon = player.weapons[player.currentWeapon];
          const canShoot = (isMouseDown || keys[' ']) && (weapon.automatic || (!keys[' '] && !weapon.automatic)); // Handle auto/semi-auto
          
          if (canShoot && !player.isReloading && Date.now() - player.lastShotTimestamp > weapon.fireRate * 1000) {
            if (weapon.ammo > 0) {
              shoot();
            } else {
              tryReload(); // Auto-reload attempt on empty click
              // playSound('emptyClick', 0.8); // TODO: Add sound
            }
          }
          
          // Weapon Switching (Handled in keydown)
        }

        function isWall(x, y) {
          if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight) return true; // Treat out of bounds as wall
          const cellType = map[y][x];
          return cellType >= 1 && cellType <= 4; // Check if it's one of the wall types
        }


        // --- Update Logic ---
        function update(dt) {
          if (isPaused || isGameOver) return;
          
          processInput(dt);
          updatePlayer(dt);
          updateEnemies(dt);
          updatePickups(dt);
          updateParticles(dt);
          // updateActiveSounds(); // Update positions for looping sounds
          updateEnemySounds(); // <--- Add this call
        }

        // Modify stopAllSounds() to also clear the proximity instance variable
        function stopAllSounds() {
          if (!isAudioInitialized) return;
          activeSounds.forEach(sound => {
            try {
              sound.source.stop();
            } catch (e) {
              console.error("stopAllSounds - Error:", e);
            }
          });
          activeSounds.clear();
          proximitySoundInstance = null; // Ensure reference is cleared
        }

        // Add this function to load sound files
        async function loadSound(name, url) {
          if (!isAudioInitialized || soundBuffers[name]) return; // Don't reload if already loaded
          try {
            console.log(`Loading sound: ${name} from ${url}`);
            const response = await fetch(url);
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status} for ${url}`);
            }
            const arrayBuffer = await response.arrayBuffer();
            // Decode asynchronously
            audioContext.decodeAudioData(arrayBuffer, (buffer) => {
              soundBuffers[name] = buffer;
              console.log(`Sound decoded and loaded: ${name}`);
            }, (error) => {
              console.error(`Error decoding audio data for ${name} from ${url}:`, error);
            });
          } catch (e) {
            console.error(`Error fetching sound ${name} from ${url}:`, e);
          }
        }

        // Modify initAudio to call loadSound
        async function initAudio() {
          if (isAudioInitialized || !document.hasFocus()) return;
          try {
            audioContext = new(window.AudioContext || window.webkitAudioContext)();
            masterGain = audioContext.createGain();
            masterGain.gain.value = 0.7; // Master volume
            masterGain.connect(audioContext.destination);
            isAudioInitialized = true;
            console.log("Audio Context Initialized.");
            
            var baseUrl = '/3d_shooter/assets'
            // --- Load Specific Sounds ---
            loadSound('shootPistol', baseUrl + '/Pistola22cal.mp3');
            loadSound('shootShotgun', baseUrl + '/Shotgun2.mp3');
            loadSound(ENEMY_PROXIMITY_SOUND_KEY, baseUrl + '/Trol.mp3');
            
            // --- Load other existing sounds (placeholders or actual) ---
            // Example: loadSound('playerHurt', 'assets/player_hurt.wav');
            //          loadSound('pickupHealth', 'assets/pickup.wav'); etc.
            
          } catch (e) {
            console.error("Error initializing Audio Context:", e);
            isAudioInitialized = false;
          }
        }

        // Modify or create updateEnemySounds
        function updateEnemySounds() {
          if (!isAudioInitialized || isPaused || isGameOver) {
            // Ensure sound stops if paused or game over
            if (proximitySoundInstance) {
              stopSound(proximitySoundInstance);
              proximitySoundInstance = null;
            }
            return;
          };
          
          let closestEnemy = null;
          let minDistance = Infinity;
          
          // Find the closest *living* enemy
          enemies.forEach(enemy => {
            if (enemy.state === 'dead') return;
            // Use pre-calculated distance if available (from sprite rendering?) or recalculate
            // Ensure sprite distance is updated frequently enough if relying on that
            const distance = enemy.dist !== undefined ? enemy.dist : Math.sqrt(Math.pow(enemy.x - player.x, 2) + Math.pow(enemy.y - player.y, 2));
            
            if (distance < minDistance) {
              minDistance = distance;
              closestEnemy = enemy;
            }
          });
          
          // Check proximity threshold
          if (closestEnemy && minDistance < ENEMY_PROXIMITY_THRESHOLD) {
            const volume = Math.max(0, Math.min(0.6, 0.6 * (1 - (minDistance / ENEMY_PROXIMITY_THRESHOLD)))); // Volume fades with distance
            
            if (!proximitySoundInstance) {
              // Start the looping sound if it's not playing
              if (DEBUG) {
                console.log(`Starting proximity sound for enemy at (${closestEnemy.x.toFixed(1)}, ${closestEnemy.y.toFixed(1)})`);
              }
              proximitySoundInstance = playSound(ENEMY_PROXIMITY_SOUND_KEY, volume, 1.0, closestEnemy, true); // Loop = true
              // Need to manually set initial volume correctly if playSound doesn't handle it perfectly for loops
              if (proximitySoundInstance && proximitySoundInstance.distanceGain) {
                proximitySoundInstance.distanceGain.gain.setValueAtTime(volume, audioContext.currentTime);
              }
              
            } else {
              // Update position and volume of the existing sound
              updatePositionalSound(proximitySoundInstance, closestEnemy);
              // Adjust volume using the gain node within the sound instance
              if (proximitySoundInstance.distanceGain) {
                // Use setTargetAtTime for smoother volume changes
                proximitySoundInstance.distanceGain.gain.setTargetAtTime(volume, audioContext.currentTime, 0.1); // Smooth transition over 0.1s
              }
            }
          } else {
            // No enemy is close enough, stop the sound if it's playing
            if (proximitySoundInstance) {
              console.log("Stopping proximity sound.");
              stopSound(proximitySoundInstance);
              proximitySoundInstance = null;
            }
          }
        }

        function updatePlayer(dt) {
          // Weapon Bob
          if (player.isMoving) {
            weaponBobAngle += dt * 10; // Adjust speed of bob
          } else {
            // Gently return to center if stopped
            weaponBobAngle += (0 - weaponBobAngle) * dt * 5;
          }
          
          // Recoil Recovery
          currentRecoil -= currentRecoil * recoilRecovery * dt;
          if (currentRecoil < 0.001) currentRecoil = 0;
          
          
          // Reload Timer
          if (player.isReloading) {
            player.reloadTimer -= dt;
            if (player.reloadTimer <= 0) {
              finishReload();
            }
          }
        }

        function updateEnemies(dt) {
          enemies.forEach(enemy => {
            if (enemy.state === 'dead') return;
            
            // Dying state timer
            if (enemy.state === 'dying') {
              enemy.dyingTimer -= dt;
              if (enemy.dyingTimer <= 0) {
                enemy.state = 'dead';
                // playSound(enemy.soundDeath, 1.0, 1.0, enemy); // Play death sound
              }
              return; // No other actions while dying
            }
            
            // Hit flash timer
            if (enemy.isHit && Date.now() - enemy.lastHitTimestamp > 150) {
              enemy.isHit = false;
            }
            
            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            const distanceToPlayer = Math.sqrt(dx * dx + dy * dy);
            const angleToPlayer = Math.atan2(dy, dx);
            
            // Check Line of Sight (simple raycast from enemy to player)
            // TODO: Implement more robust LoS check if needed
            let hasLineOfSight = false;
            if (distanceToPlayer < enemy.sightRange) {
              const ray = castRayEnemy(enemy.x, enemy.y, angleToPlayer);
              if (ray.distance >= distanceToPlayer - 0.1) { // Allow slight tolerance
                hasLineOfSight = true;
              }
            }
            
            // State transitions
            if (hasLineOfSight) {
              if (enemy.state === 'idle') {
                enemy.state = 'chase';
                // playSound(enemy.soundAlert, 0.8, 1.0, enemy); // Play alert sound
              }
              if (distanceToPlayer <= enemy.attackRange) {
                enemy.state = 'attack';
              } else if (enemy.state === 'attack') { // Move back to chase if player moves out of range
                enemy.state = 'chase';
              }
              enemy.targetPos = {
                x: player.x,
                y: player.y
              }; // Update target while visible
            } else {
              // If lost sight, maybe stay chasing for a bit or return to idle
              if (enemy.state === 'chase' || enemy.state === 'attack') {
                // TODO: Implement a "lost sight" timer or patrol behavior?
                // For now, revert to idle if far enough
                if (distanceToPlayer > enemy.sightRange * 1.2) {
                  enemy.state = 'idle';
                }
              }
            }
            
            
            // --- Actions based on state ---
            switch (enemy.state) {
              case 'chase':
                if (enemy.targetPos) {
                  const angleToTarget = Math.atan2(enemy.targetPos.y - enemy.y, enemy.targetPos.x - enemy.x);
                  enemy.angle = angleToTarget; // Face target while chasing
                  moveEnemy(enemy, enemy.angle, enemy.speed * dt);
                }
                break;
              case 'attack':
                enemy.angle = angleToPlayer; // Face player while attacking
                if (Date.now() - enemy.lastAttackTimestamp > 1000) { // Attack cooldown
                  player.health -= enemy.damage;
                  enemy.lastAttackTimestamp = Date.now();
                  triggerDamageOverlay();
                  // playSound('playerHurt', 1.0); // Play player hurt sound
                  // console.log(`Player Health: ${player.health}`);
                  if (player.health <= 0) {
                    triggerGameOver();
                  }
                  updateHUD(); // Update health display
                }
                break;
              case 'idle':
                // Maybe occasional random movement or turning?
                break;
            }
          });
        }

        function moveEnemy(enemy, angle, step) {
          const moveX = Math.cos(angle) * step;
          const moveY = Math.sin(angle) * step;
          const nextX = enemy.x + moveX;
          const nextY = enemy.y + moveY;
          const collisionRadius = enemy.size * 0.5;
          
          // Simplified collision check (similar to player)
          const nextTileX = Math.floor(nextX + Math.sign(moveX) * collisionRadius);
          const currentTileY = Math.floor(enemy.y);
          let collisionOccurredX = false;
          if (isWall(nextTileX, currentTileY) || isWall(nextTileX, Math.floor(enemy.y + collisionRadius)) || isWall(nextTileX, Math.floor(enemy.y - collisionRadius))) {
            collisionOccurredX = true;
          }
          
          const nextTileY = Math.floor(nextY + Math.sign(moveY) * collisionRadius);
          const currentTileX = Math.floor(enemy.x);
          let collisionOccurredY = false;
          if (isWall(currentTileX, nextTileY) || isWall(Math.floor(enemy.x + collisionRadius), nextTileY) || isWall(Math.floor(enemy.x - collisionRadius), nextTileY)) {
            collisionOccurredY = true;
          }
          
          if (!collisionOccurredX) enemy.x = nextX;
          if (!collisionOccurredY) enemy.y = nextY;
          
          // Basic enemy-enemy collision avoidance (very simple push apart)
          enemies.forEach(other => {
            if (enemy === other || other.state === 'dead') return;
            const dx = other.x - enemy.x;
            const dy = other.y - enemy.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const minDist = (enemy.size + other.size) * 0.5;
            if (dist < minDist && dist > 0.01) {
              const overlap = minDist - dist;
              const pushX = (dx / dist) * overlap * 0.5; // Push half the overlap distance
              const pushY = (dy / dist) * overlap * 0.5;
              // Check if pushing enemy is valid before applying
              if (!isWall(Math.floor(enemy.x - pushX), Math.floor(enemy.y - pushY))) {
                enemy.x -= pushX;
                enemy.y -= pushY;
              }
              if (!isWall(Math.floor(other.x + pushX), Math.floor(other.y + pushY))) {
                other.x += pushX;
                other.y += pushY;
              }
            }
          });
        }

        function updatePickups(dt) {
          pickups.forEach((pickup, index) => {
            // Simple distance check for pickup
            const dx = pickup.x - player.x;
            const dy = pickup.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const pickupRadius = pickup.size + 0.3; // Player collision radius
            
            if (distance < pickupRadius) {
              let pickedUp = false;
              if (pickup.target === 'health') {
                if (player.health < player.maxHealth) {
                  player.health = Math.min(player.maxHealth, player.health + pickup.amount);
                  pickedUp = true;
                }
              } else if (pickup.target === 'ammo') {
                const weapon = player.weapons[player.currentWeapon];
                if (weapon.ammo < weapon.maxAmmo) {
                  weapon.ammo = Math.min(weapon.maxAmmo, weapon.ammo + pickup.amount);
                  pickedUp = true;
                }
                // Alternative: give ammo for all weapons?
              }
              
              if (pickedUp) {
                // playSound(pickup.sound, 0.9);
                console.log(`Picked up ${pickup.target}`);
                pickups.splice(index, 1); // Remove pickup
                updateHUD();
              }
            }
          });
        }

        function updateParticles(dt) {
          particles = particles.filter(p => {
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.alpha -= p.decay * dt;
            return p.alpha > 0;
          });
        }

        // --- Rendering ---
        function render() {
          ctx.clearRect(0, 0, screenWidth, screenHeight);
          zBuffer.fill(Infinity);
          
          renderBackgroundAndFloor(); // Optimized version called here
          
          // --- Wall Casting & Rendering ---
          for (let x = 0; x < screenWidth; x++) {
            const rayAngle = player.angle - FOV / 2 + x * angleStep;
            // Using bitwise OR 0 for faster floor on map coords access? Maybe minor.
            const playerMapX = player.x | 0;
            const playerMapY = player.y | 0;
            const ray = castRay(player.x, player.y, rayAngle);
            
            zBuffer[x] = ray.perpWallDist;
            
            // Use Math.round once? Check performance vs floor. Use bitwise |0 potentially.
            const lineHeight = (screenHeight * wallHeightMultiplier / ray.perpWallDist) | 0; // Use bitwise floor
            const drawStart = Math.max(0, ((screenHeight - lineHeight) / 2) | 0); // Use bitwise floor
            const drawEnd = Math.min(screenHeight - 1, ((screenHeight + lineHeight) / 2) | 0); // Use bitwise floor
            
            const wallType = map[ray.mapY]?.[ray.mapX];
            
            if (wallType >= 1 && wallType <= 4) { // Valid wall check
              const wallStyle = wallColors[wallType];
              const distanceFade = Math.min(1, ray.perpWallDist / fogDepth);
              let shadeFactor = (ray.side === 1) ? 0.8 : 1.0;
              let baseWallColor = shadeColor(wallStyle.base, distanceFade * -80, shadeFactor);
              
              // OPTIMIZATION: Check if strip is too small before complex calcs / drawing
              if (drawEnd > drawStart) {
                ctx.fillStyle = baseWallColor;
                ctx.fillRect(x, drawStart, 1, drawEnd - drawStart);
                
                // Calculate wallX only if needed for pattern
                if (OPTIMIZE_MODE < 2) { // Don't calc/apply pattern in max perf mode?
                  let wallX;
                  if (ray.side === 0) {
                    wallX = player.y + ray.perpWallDist * Math.sin(rayAngle);
                  } else {
                    wallX = player.x + ray.perpWallDist * Math.cos(rayAngle);
                  }
                  wallX -= Math.floor(wallX); // Fractional part
                  applyWallPattern(x, drawStart, drawEnd, wallX, wallStyle, baseWallColor); // Optimized version called here
                }
              }
            } else if (drawEnd > drawStart) { // Draw error color only if strip has height
              ctx.fillStyle = '#FF00FF';
              ctx.fillRect(x, drawStart, 1, drawEnd - drawStart);
            }
          }
          
          // --- Render Sprites, Particles, Weapon, HUD (Assume these functions are relatively less demanding, or optimize separately) ---
          if (OPTIMIZE_MODE < 2) { // Maybe skip sprites/particles in max performance? Check impact.
            renderSprites();
            renderParticles();
          } else {
            // Maybe render simplified sprites (solid color blocks?) or fewer particles
            renderSpritesSimple(); // Create a simpler version of renderSprites if needed
            // Skip renderParticles() ?
          }
          
          renderWeapon(); // HUD elements are usually less costly
          renderHUD();
          renderDamageOverlay();
          renderCrosshair();
        }

        // IF using renderSpritesSimple, add health bar there too:
        function renderSpritesSimple() {
          const sprites = [ /* ... get/sort sprites ... */ ];
          sprites.forEach(sprite => {
            if (!sprite.isVisible || sprite.dist < 0.1) return;
            // ... calculate perpDist, spriteHeight, spriteWidth, screenX, drawStartX/Y ...
            const perpDist = sprite.dist * Math.cos(sprite.angle);
            const spriteHeight = (screenHeight / perpDist * (sprite.size || 0.5)) | 0;
            if (spriteHeight <= 0) return;
            const spriteWidth = (spriteHeight * 0.8) | 0;
            const screenX = Math.tan(sprite.angle) * (screenWidth / 2) / Math.tan(FOV / 2) + screenWidth / 2;
            const drawStartY = ((screenHeight - spriteHeight) / 2) | 0;
            const drawStartX = (screenX - spriteWidth / 2) | 0;
            const drawEndX = drawStartX + spriteWidth;
            const intScreenX = Math.floor(screenX);
            
            let isPickup = Object.values(pickupTypes).find(pt => pt.type === sprite.type);
            let isEnemy = !isPickup && sprite.currentHealth !== undefined;
            
            // Draw Simple Rectangle (as before)
            let spriteColor = '#FF00FF';
            if (isPickup) {
              spriteColor = sprite.color;
            } else if (isEnemy) {
              spriteColor = sprite.color;
              if (sprite.isHit && Date.now() - sprite.lastHitTimestamp < 80) spriteColor = '#FFFFFF';
            }
            const distanceFade = Math.min(1, perpDist / fogDepth);
            const finalColor = shadeColor(spriteColor, distanceFade * -80);
            ctx.fillStyle = finalColor;
            
            for (let stripe = drawStartX; stripe < drawEndX; stripe++) {
              if (stripe >= 0 && stripe < screenWidth && perpDist < zBuffer[stripe]) {
                const clampedDrawStartY = Math.max(0, drawStartY);
                const clampedDrawEndY = Math.min(screenHeight, drawStartY + spriteHeight);
                if (clampedDrawEndY > clampedDrawStartY) {
                  ctx.fillRect(stripe, clampedDrawStartY, 1, clampedDrawEndY - clampedDrawStartY);
                }
              }
            }
            
            // --- Draw Health Bar (Simplified version) ---
            if (isEnemy && sprite.state !== 'dying' && intScreenX >= 0 && intScreenX < screenWidth && perpDist < zBuffer[intScreenX]) {
              const healthPercent = Math.max(0, sprite.currentHealth) / sprite.health;
              const barHeight = 4; // Fixed small height in simple mode
              const barWidth = Math.max(15, Math.floor(spriteWidth * 0.6)); // Slightly smaller width
              const barYOffset = -barHeight * 1.8;
              const barX = Math.floor(screenX - barWidth / 2);
              const barY = Math.floor(drawStartY + barYOffset); // Use drawStartY, not finalDrawStartY (no bobbing in simple)
              
              const clampedBarY = Math.max(0, barY);
              const clampedBarHeight = Math.min(barHeight, screenHeight - clampedBarY);
              
              if (clampedBarHeight > 0) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(barX, clampedBarY, barWidth, clampedBarHeight);
                const healthColor = healthPercent > 0.6 ? '#33FF33' : (healthPercent > 0.3 ? '#FFFF33' : '#FF3333');
                ctx.fillStyle = healthColor;
                ctx.fillRect(barX, clampedBarY, Math.floor(barWidth * healthPercent), clampedBarHeight); // Fill from left
              }
            }
          });
        }

        // --- Optimized Floor/Ceiling Rendering ---
        function renderBackgroundAndFloor() {
          // OPTIMIZED: Simple gradients, no per-pixel calculation
          
          // Sky gradient (unchanged is fine)
          const skyGradient = ctx.createLinearGradient(0, 0, 0, screenHeight / 2);
          skyGradient.addColorStop(0, ceilingColor1); // Darker at top
          skyGradient.addColorStop(1, ceilingColor2); // Lighter near horizon
          ctx.fillStyle = skyGradient;
          ctx.fillRect(0, 0, screenWidth, screenHeight / 2);
          
          // Floor gradient
          const floorGradient = ctx.createLinearGradient(0, screenHeight / 2, 0, screenHeight);
          // Adjust colors slightly based on simple distance fog approximation (can be precalculated)
          const horizonFloorColor = lerpColor(floorColor2, "#202020", 0.1); // Slightly fogged near horizon
          const nearFloorColor = lerpColor(floorColor1, "#202020", 0.5); // More fogged near bottom
          floorGradient.addColorStop(0, horizonFloorColor); // Lighter (less fog) near horizon
          floorGradient.addColorStop(1, nearFloorColor); // Darker (more fog) closer
          ctx.fillStyle = floorGradient;
          ctx.fillRect(0, screenHeight / 2, screenWidth, screenHeight / 2);
          
          // --- Optional: Simple Horizon Line ---
          // ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
          // ctx.fillRect(0, screenHeight / 2 - 1, screenWidth, 2);
        }


        // --- Optimized Wall Pattern Application ---
        function applyWallPattern(screenX, drawStart, drawEnd, wallX, wallStyle, baseColor) {
          // Optimization: Reduce pattern complexity or disable in lower performance modes
          if (OPTIMIZE_MODE > 0) {
            // --- Simpler/Faster Patterns ---
            const textureSize = 32; // Smaller virtual texture for less variation detail
            const texX = (wallX * textureSize) | 0; // Use bitwise floor
            const darkColor = shadeColor(baseColor, -18); // Consistent darker shade
            
            if (wallStyle.pattern === 'lines' || wallStyle.pattern === 'grid') {
              // Simple vertical lines only
              if ((texX & 7) < 1) { // Use bitwise AND for modulo check (if textureSize is power of 2) - slightly faster? Check perf.
                ctx.fillStyle = darkColor;
                ctx.fillRect(screenX, drawStart, 1, drawEnd - drawStart);
              }
            } else if (wallStyle.pattern === 'noise') {
              // Faster noise (avoid sin) - simple hash like
              let hash = (texX * 2654435761 | 0) ^ (screenX * 2654435761 | 0); // Basic XOR hash based on coords
              hash = ((hash >> 16) ^ hash) * 0x45d9f3b;
              hash = ((hash >> 16) ^ hash) * 0x45d9f3b;
              hash = (hash >> 16) ^ hash;
              if ((hash & 255) < 50) { // Check lower bits for pseudo-randomness
                ctx.fillStyle = darkColor;
                ctx.fillRect(screenX, drawStart, 1, drawEnd - drawStart);
              }
            }
            // Skip 'slime' or other complex patterns in optimized modes
            
            // Disable patterns entirely in max performance mode?
            // if (OPTIMIZE_MODE === 2) { return; } // Uncomment to completely disable patterns
            
          } else {
            // --- Original High Quality Pattern Logic (Keep as before for reference) ---
            const textureSize = 64; // Virtual texture size
            const texX = Math.floor(wallX * textureSize);
            const brightColor = shadeColor(baseColor, 15);
            const darkColor = shadeColor(baseColor, -15);
            
            if (wallStyle.pattern === 'lines') {
              if (texX % 16 < 2 || texX % 16 > 14) {
                ctx.fillStyle = darkColor;
                ctx.fillRect(screenX, drawStart, 1, drawEnd - drawStart);
              }
            } else if (wallStyle.pattern === 'grid') {
              // Vertical and Horizontal lines
              const lineThickness = 2;
              if (texX % 16 < lineThickness || texX % 16 >= (16 - lineThickness)) {
                ctx.fillStyle = darkColor; // Vertical lines
                ctx.fillRect(screenX, drawStart, 1, drawEnd - drawStart);
              } else {
                // Faint horizontal lines
                const approxTexY = (screenX % 16);
                if (approxTexY < lineThickness || approxTexY >= (16 - lineThickness)) {
                  ctx.fillStyle = darkColor;
                  // Draw less often maybe
                  if ((screenX % 4) === 0) {
                    ctx.fillRect(screenX, drawStart + (drawEnd - drawStart) * 0.25, 1, Math.max(1, (drawEnd - drawStart) * 0.05));
                    ctx.fillRect(screenX, drawStart + (drawEnd - drawStart) * 0.75, 1, Math.max(1, (drawEnd - drawStart) * 0.05));
                  }
                }
              }
            } else if (wallStyle.pattern === 'noise') {
              const noiseVal = Math.abs((Math.sin(wallX * 10 + screenX * 0.1) * 43758.5453) % 1);
              if (noiseVal < 0.3) {
                ctx.fillStyle = darkColor;
                ctx.fillRect(screenX, drawStart, 1, drawEnd - drawStart);
              } else if (noiseVal > 0.7) {
                ctx.fillStyle = brightColor;
                ctx.fillRect(screenX, drawStart, 1, drawEnd - drawStart);
              }
            } else if (wallStyle.pattern === 'slime') {
              // Original slime code... kept for completeness if needed
              const dripSeed = Math.floor(wallX * 5);
              const dripVal = Math.abs((Math.sin(dripSeed * 12.9898 + screenX * 78.233) * 43758.5453) % 1);
              if (dripVal < 0.1) {
                const dripHeightFactor = 0.2 + Math.abs((Math.sin(wallX * 15 + screenX * 0.2) * 43758.5453) % 1) * 0.8;
                ctx.fillStyle = shadeColor(wallStyle.color2, 10);
                ctx.fillRect(screenX, drawStart, 1, (drawEnd - drawStart) * dripHeightFactor);
              }
              const noiseVal = Math.abs((Math.sin(wallX * 11 + screenX * 0.15) * 33758.5453) % 1);
              if (noiseVal < 0.4) {
                ctx.fillStyle = shadeColor(baseColor, -10);
                ctx.fillRect(screenX, drawStart, 1, drawEnd - drawStart);
              }
            }
          }
        }

        function renderSprites() {
          // Combine enemies and pickups into one list for Z-sorting
          const sprites = [
            ...enemies.filter(e => e.state !== 'dead'),
            ...pickups
          ];
          
          // Calculate distance and angle for each sprite
          sprites.forEach(sprite => {
            sprite.dist = Math.sqrt(Math.pow(sprite.x - player.x, 2) + Math.pow(sprite.y - player.y, 2));
            let angle = Math.atan2(sprite.y - player.y, sprite.x - player.x) - player.angle;
            // Normalize angle relative to player's view [-PI, PI]
            while (angle < -Math.PI) angle += 2 * Math.PI;
            while (angle > Math.PI) angle -= 2 * Math.PI;
            sprite.angle = angle;
            sprite.isVisible = Math.abs(angle) < FOV / 1.8; // Slightly narrower than FOV to avoid edge issues
          });
          
          // Sort sprites by distance (far to near)
          sprites.sort((a, b) => b.dist - a.dist);
          
          // Draw sprites
          sprites.forEach(sprite => {
            if (!sprite.isVisible || sprite.dist < 0.1) return; // Skip if not visible or too close
            
            const perpDist = sprite.dist * Math.cos(sprite.angle); // Correct for fish-eye on sprites
            const spriteHeight = Math.min(screenHeight * 1.5, screenHeight / perpDist * (sprite.size || 0.5)); // Use sprite specific size
            const spriteWidth = spriteHeight * 0.8; // Assume width is related to height
            
            const screenX = Math.tan(sprite.angle) * (screenWidth / 2) / Math.tan(FOV / 2) + screenWidth / 2;
            const drawStartY = (screenHeight - spriteHeight) / 2;
            const drawEndY = drawStartY + spriteHeight;
            const drawStartX = Math.floor(screenX - spriteWidth / 2);
            const drawEndX = Math.floor(screenX + spriteWidth / 2);
            
            const intScreenX = Math.floor(screenX); // Center X coordinate (integer)
            
            // Bobbing for pickups
            let bobOffset = 0;
            if (sprite.bob) {
              // Use timestamp and sprite position for varied bobbing
              const bobTime = Date.now() / (250 / pickupBobSpeed);
              bobOffset = Math.sin(bobTime + sprite.x * 0.5 + sprite.y * 0.3) * spriteHeight * pickupBobAmount;
            }
            const finalDrawStartY = drawStartY + bobOffset;
            const finalDrawEndY = drawEndY + bobOffset;
            
            let isPickup = Object.values(pickupTypes).find(pt => pt.type === sprite.type);
            let isEnemy = !isPickup && sprite.currentHealth !== undefined;
            
            // Render the main sprite stripes first (as before)
            for (let stripe = drawStartX; stripe < drawEndX; stripe++) {
              if (stripe >= 0 && stripe < screenWidth && perpDist < zBuffer[stripe]) {
                // --- Existing stripe rendering logic for pickups OR enemies ---
                const stripeStartYClamped = Math.max(0, Math.floor(finalDrawStartY));
                const stripeEndYClamped = Math.min(screenHeight, Math.floor(finalDrawStartY + spriteHeight));
                const stripeHeight = stripeEndYClamped - stripeStartYClamped;
                if (stripeHeight <= 0) continue;
                
                if (isPickup) {
                  // ... existing pickup stripe rendering ...
                  const basePickupColor = sprite.color; // Already has 'color' property
                  const distanceFade = Math.min(1, perpDist / fogDepth);
                  const finalPickupColor = shadeColor(basePickupColor, distanceFade * -80);
                  ctx.fillStyle = finalPickupColor;
                  ctx.fillRect(stripe, stripeStartYClamped, 1, stripeHeight);
                  // ... optional pickup details (shading, shine) ...
                } else if (isEnemy) {
                  // ... existing enemy stripe rendering (color, alpha, shading, eyes) ...
                  let enemyColor;
                  let alpha = 1.0;
                  if (sprite.state === 'dying') {
                    /* dying fade/color */
                    alpha = Math.max(0, 1.0 - (sprite.dyingTimer / 0.5));
                    enemyColor = lerpColor(sprite.color, '#444444', 1.0 - alpha);
                  } else if (sprite.isHit && Date.now() - sprite.lastHitTimestamp < 80) {
                    enemyColor = '#FFFFFF';
                  } else {
                    const distanceFade = Math.min(1, perpDist / fogDepth);
                    enemyColor = shadeColor(sprite.color, distanceFade * -80);
                  }
                  const finalEnemyColorWithAlpha = `rgba(${hexToRgb(enemyColor).r}, ${hexToRgb(enemyColor).g}, ${hexToRgb(enemyColor).b}, ${alpha.toFixed(2)})`;
                  // Apply shading based on spriteProgressX
                  const spriteProgressX = (stripe - drawStartX) / spriteWidth;
                  const shadeAmount = -40 * Math.abs(spriteProgressX - 0.5) * 2;
                  const shadedColor = shadeColor(enemyColor, shadeAmount);
                  const finalShadedColorWithAlpha = `rgba(${hexToRgb(shadedColor).r}, ${hexToRgb(shadedColor).g}, ${hexToRgb(shadedColor).b}, ${alpha.toFixed(2)})`;
                  ctx.fillStyle = finalShadedColorWithAlpha;
                  ctx.fillRect(stripe, stripeStartYClamped, 1, stripeHeight);
                  
                  // ... Eye rendering logic ...
                  // Draw "Eyes" - more distinct
                  if (sprite.state !== 'dying' && spriteHeight > 20) { // Only if large enough
                    const eyeHeightRatio = 0.25; // Vertical position from top
                    const eyeZoneStartRatio = 0.2; // Horizontal start within sprite width
                    const eyeZoneEndRatio = 0.8;
                    const eyeSeparationRatio = 0.3; // Space between eyes
                    const eyeWidthRatio = 0.15; // Width of each eye relative to sprite width
                    
                    const eyeY = stripeStartYClamped + stripeHeight * eyeHeightRatio;
                    const eyeH = Math.max(1, Math.floor(spriteHeight * 0.1));
                    
                    // Calculate positions for left and right eyes
                    const leftEyeStripeStart = Math.floor(drawStartX + spriteWidth * eyeZoneStartRatio);
                    const leftEyeStripeEnd = Math.floor(leftEyeStripeStart + spriteWidth * eyeWidthRatio);
                    const rightEyeStripeStart = Math.floor(drawStartX + spriteWidth * (eyeZoneEndRatio - eyeWidthRatio));
                    const rightEyeStripeEnd = Math.floor(rightEyeStripeStart + spriteWidth * eyeWidthRatio);
                    
                    // Check if current stripe falls within either eye's zone
                    if ((stripe >= leftEyeStripeStart && stripe < leftEyeStripeEnd) || (stripe >= rightEyeStripeStart && stripe < rightEyeStripeEnd)) {
                      const pupilStripeOffset = Math.floor(spriteWidth * eyeWidthRatio * 0.3); // Indent pupil slightly
                      const isPupil = (stripe > leftEyeStripeStart + pupilStripeOffset && stripe < leftEyeStripeEnd - pupilStripeOffset) ||
                        (stripe > rightEyeStripeStart + pupilStripeOffset && stripe < rightEyeStripeEnd - pupilStripeOffset);
                      
                      let eyeColor = (sprite.isHit && Date.now() - sprite.lastHitTimestamp < 150) ? '#FF5555' : '#FFFACD'; // Pale yellow default, redder when hit recently
                      if (isPupil) {
                        eyeColor = '#111111'; // Black pupil
                      }
                      
                      ctx.fillStyle = `rgba(${hexToRgb(eyeColor).r}, ${hexToRgb(eyeColor).g}, ${hexToRgb(eyeColor).b}, ${alpha.toFixed(2)})`;
                      ctx.fillRect(stripe, Math.floor(eyeY), 1, eyeH);
                    }
                  }
                }
              }
            } // End stripe loop
            
            // --- Now, draw Health Bar if it's an enemy AND bar is visible ---
            if (isEnemy && sprite.state !== 'dying' && intScreenX >= 0 && intScreenX < screenWidth && perpDist < zBuffer[intScreenX]) {
              const healthPercent = Math.max(0, sprite.currentHealth) / sprite.health; // Use base health
              const barMaxHeight = 8; // Max pixel height of the bar
              const barHeight = Math.min(barMaxHeight, Math.max(2, Math.floor(spriteHeight * 0.08))); // Scale slightly with sprite height, but clamp
              const barWidth = Math.min(80, Math.max(20, Math.floor(spriteWidth * 0.7))); // Scale slightly, clamp width
              const barYOffset = -barHeight * 1.5; // Position above the sprite's head
              const barX = Math.floor(screenX - barWidth / 2);
              const barY = Math.floor(finalDrawStartY + barYOffset);
              
              // Ensure bar is drawn within screen bounds vertically
              const clampedBarY = Math.max(0, barY);
              const clampedBarHeight = Math.min(barHeight, screenHeight - clampedBarY);
              
              if (clampedBarHeight > 0) { // Only draw if bar has visible height
                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(barX, clampedBarY, barWidth, clampedBarHeight);
                
                // Health Fill
                const healthColor = healthPercent > 0.6 ? '#33FF33' : (healthPercent > 0.3 ? '#FFFF33' : '#FF3333'); // Brighter colors
                ctx.fillStyle = healthColor;
                ctx.fillRect(barX + 1, clampedBarY + 1, Math.floor((barWidth - 2) * healthPercent), clampedBarHeight - 2);
              }
            }
            
            
            // Iterate through vertical stripes of the sprite
            for (let stripe = drawStartX; stripe < drawEndX; stripe++) {
              // Check if stripe is on screen and in front of wall
              if (stripe >= 0 && stripe < screenWidth && perpDist < zBuffer[stripe]) {
                
                // --- Determine Color & Details based on Sprite Type ---
                // Is it a Pickup? (Check if sprite has a 'type' matching pickupTypes)
                const pickupInfo = Object.values(pickupTypes).find(pt => pt.type === sprite.type);
                
                if (pickupInfo) {
                  // --- PICKUP RENDERING ---
                  const basePickupColor = pickupInfo.color;
                  const distanceFade = Math.min(1, perpDist / fogDepth);
                  const finalPickupColor = shadeColor(basePickupColor, distanceFade * -80); // Apply fog
                  
                  // Calculate vertical texture coordinate (0 to 1)
                  const stripeStartYClamped = Math.max(0, Math.floor(finalDrawStartY));
                  const stripeEndYClamped = Math.min(screenHeight, Math.floor(finalDrawEndY));
                  const stripeHeight = stripeEndYClamped - stripeStartYClamped;
                  
                  if (stripeHeight <= 0) continue; // Skip if stripe has no height                                
                  
                  // Draw the main color stripe
                  ctx.fillStyle = finalPickupColor;
                  ctx.fillRect(stripe, stripeStartYClamped, 1, stripeHeight);
                  
                  // Add subtle lighting/shading
                  const spriteProgressX = (stripe - drawStartX) / spriteWidth; // 0 to 1 across sprite width
                  if (spriteProgressX < 0.15 || spriteProgressX > 0.85) {
                    // Darker edges
                    ctx.fillStyle = shadeColor(finalPickupColor, -25);
                    ctx.fillRect(stripe, stripeStartYClamped, 1, stripeHeight);
                  } else if (spriteProgressX > 0.4 && spriteProgressX < 0.6) {
                    // Slightly lighter center column for roundness feel
                    ctx.fillStyle = shadeColor(finalPickupColor, 15);
                    ctx.fillRect(stripe, stripeStartYClamped, 1, stripeHeight);
                  }
                  
                  // Add a shine effect based on angle/position
                  const shinePos = 0.3; // Where the shine line appears vertically (0 to 1)
                  const shineThickness = 0.08;
                  const shineStartY = stripeStartYClamped + stripeHeight * shinePos;
                  const shineEndY = shineStartY + stripeHeight * shineThickness;
                  if (shineEndY > shineStartY) { // Only draw if thick enough
                    ctx.fillStyle = shadeColor(finalPickupColor, 50); // Brighter shine color
                    ctx.fillRect(stripe, Math.floor(shineStartY), 1, Math.ceil(shineEndY - shineStartY));
                  }
                  
                  
                } else { // --- ENEMY RENDERING ---
                  let enemyColor;
                  let alpha = 1.0; // Default alpha
                  
                  if (sprite.state === 'dying') {
                    // Fade out effect while dying
                    const dyingProgress = 1.0 - (sprite.dyingTimer / 0.5); // 0 to 1 as timer decreases
                    alpha = Math.max(0, 1.0 - dyingProgress);
                    // Maybe slightly change color too? e.g., lerp to grey or red
                    enemyColor = lerpColor(sprite.color, '#444444', dyingProgress * 0.8);
                  } else if (sprite.isHit && Date.now() - sprite.lastHitTimestamp < 80) { // Shorter hit flash
                    enemyColor = '#FFFFFF'; // Bright white flash
                  } else {
                    const distanceFade = Math.min(1, perpDist / fogDepth);
                    enemyColor = shadeColor(sprite.color, distanceFade * -80); // Apply fog
                  }
                  
                  const finalEnemyColorWithAlpha = `rgba(${hexToRgb(enemyColor).r}, ${hexToRgb(enemyColor).g}, ${hexToRgb(enemyColor).b}, ${alpha.toFixed(2)})`;
                  ctx.fillStyle = finalEnemyColorWithAlpha;
                  
                  // Clamp Y drawing coordinates
                  const stripeStartYClamped = Math.max(0, Math.floor(finalDrawStartY));
                  const stripeEndYClamped = Math.min(screenHeight, Math.floor(finalDrawEndY));
                  const stripeHeight = stripeEndYClamped - stripeStartYClamped;
                  
                  if (stripeHeight <= 0) continue; // Skip zero-height stripes
                  
                  // Draw main enemy stripe
                  ctx.fillRect(stripe, stripeStartYClamped, 1, stripeHeight);
                  
                  
                  // Add simple shading for roundness
                  const spriteProgressX = (stripe - drawStartX) / spriteWidth;
                  const shadeAmount = -40 * Math.abs(spriteProgressX - 0.5) * 2; // Darker towards edges
                  const shadedColor = shadeColor(enemyColor, shadeAmount);
                  const finalShadedColorWithAlpha = `rgba(${hexToRgb(shadedColor).r}, ${hexToRgb(shadedColor).g}, ${hexToRgb(shadedColor).b}, ${alpha.toFixed(2)})`;
                  ctx.fillStyle = finalShadedColorWithAlpha;
                  ctx.fillRect(stripe, stripeStartYClamped, 1, stripeHeight);
                  
                  
                  // Draw "Eyes" - more distinct
                  if (sprite.state !== 'dying' && spriteHeight > 20) { // Only if large enough
                    const eyeHeightRatio = 0.25; // Vertical position from top
                    const eyeZoneStartRatio = 0.2; // Horizontal start within sprite width
                    const eyeZoneEndRatio = 0.8;
                    const eyeSeparationRatio = 0.3; // Space between eyes
                    const eyeWidthRatio = 0.15; // Width of each eye relative to sprite width
                    
                    const eyeY = stripeStartYClamped + stripeHeight * eyeHeightRatio;
                    const eyeH = Math.max(1, Math.floor(spriteHeight * 0.1));
                    
                    // Calculate positions for left and right eyes
                    const leftEyeStripeStart = Math.floor(drawStartX + spriteWidth * eyeZoneStartRatio);
                    const leftEyeStripeEnd = Math.floor(leftEyeStripeStart + spriteWidth * eyeWidthRatio);
                    const rightEyeStripeStart = Math.floor(drawStartX + spriteWidth * (eyeZoneEndRatio - eyeWidthRatio));
                    const rightEyeStripeEnd = Math.floor(rightEyeStripeStart + spriteWidth * eyeWidthRatio);
                    
                    // Check if current stripe falls within either eye's zone
                    if ((stripe >= leftEyeStripeStart && stripe < leftEyeStripeEnd) || (stripe >= rightEyeStripeStart && stripe < rightEyeStripeEnd)) {
                      const pupilStripeOffset = Math.floor(spriteWidth * eyeWidthRatio * 0.3); // Indent pupil slightly
                      const isPupil = (stripe > leftEyeStripeStart + pupilStripeOffset && stripe < leftEyeStripeEnd - pupilStripeOffset) ||
                        (stripe > rightEyeStripeStart + pupilStripeOffset && stripe < rightEyeStripeEnd - pupilStripeOffset);
                      
                      let eyeColor = (sprite.isHit && Date.now() - sprite.lastHitTimestamp < 150) ? '#FF5555' : '#FFFACD'; // Pale yellow default, redder when hit recently
                      if (isPupil) {
                        eyeColor = '#111111'; // Black pupil
                      }
                      
                      ctx.fillStyle = `rgba(${hexToRgb(eyeColor).r}, ${hexToRgb(eyeColor).g}, ${hexToRgb(eyeColor).b}, ${alpha.toFixed(2)})`;
                      ctx.fillRect(stripe, Math.floor(eyeY), 1, eyeH);
                    }
                  }
                }
              }
            } // End for loop (stripes)
          }); // End forEach (sprites)
        } // End renderSprites function

        // ==========================================
        //  The rest of the code (unchanged from previous correct parts) follows...
        //  Ensure all previous functions like renderParticles, renderWeapon, renderHUD, etc.
        //  and utility functions (castRay, shadeColor, hexToRgb, lerpColor, ...)
        //  and game logic (update, input handlers, state management, loop start) are present.
        // ==========================================

        function renderParticles() {
          particles.forEach(p => {
            if (p.alpha <= 0) return;
            
            // Convert world particle pos to screen pos (similar to sprites)
            const dx = p.x - player.x;
            const dy = p.y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            let angle = Math.atan2(dy, dx) - player.angle;
            while (angle < -Math.PI) angle += 2 * Math.PI;
            while (angle > Math.PI) angle -= 2 * Math.PI;
            
            if (dist > 0.1 && Math.abs(angle) < FOV / 1.8) { // Check if in view
              const perpDist = dist * Math.cos(angle);
              const screenX = Math.tan(angle) * (screenWidth / 2) / Math.tan(FOV / 2) + screenWidth / 2;
              
              // Ensure particle is not behind a wall
              const screenXInt = Math.floor(screenX);
              if (screenXInt >= 0 && screenXInt < screenWidth && perpDist < zBuffer[screenXInt]) {
                // Determine screen Y based on perspective (simple midpoint for now)
                // A more accurate Y would require projecting particle height. Let's place near center vertically.
                const particleBaseHeight = 0.5; // Assumed height of particle source off ground
                const projectedY = screenHeight / 2 + (particleBaseHeight / perpDist) * (screenHeight / 2 / Math.tan(FOV / 2));
                
                const particleSize = Math.max(1, Math.min(5, (3 / perpDist) * p.size)); // Size depends on distance
                // const screenY = screenHeight / 2; // Simpler: Place around horizon
                
                ctx.fillStyle = `rgba(${p.r}, ${p.g}, ${p.b}, ${p.alpha.toFixed(2)})`;
                // Draw particle (maybe as a small circle or rotated square?)
                // ctx.fillRect(screenX - particleSize / 2, projectedY - particleSize / 2, particleSize, particleSize);
                // Draw circle particle:
                ctx.beginPath();
                ctx.arc(screenX, projectedY, particleSize / 2, 0, Math.PI * 2);
                ctx.fill();
              }
            }
          });
        }

        function renderWeapon() {
          const weapon = player.weapons[player.currentWeapon];
          if (!weapon || !weapon.sprite) return; // Safety check
          
          const sprite = weapon.sprite;
          // More pronounced bobbing effect
          const bobSpeedMultiplier = player.isMoving ? 12 : 4; // Faster bob when moving
          const bobAmplitudeX = player.isMoving ? 15 : 3;
          const bobAmplitudeY = player.isMoving ? 8 : 2;
          const weaponBobAngleRad = weaponBobAngle * (Math.PI / 180); // Convert bob angle to radians if using degrees
          
          const bobX = Math.sin(Date.now() / (1000 / bobSpeedMultiplier)) * bobAmplitudeX;
          const bobY = Math.abs(Math.cos(Date.now() / (1000 / bobSpeedMultiplier))) * bobAmplitudeY; // Absolute value for up/down
          
          // Apply recoil effect (pushes weapon up/back slightly)
          const recoilY = currentRecoil * -200; // Push up more
          const recoilX = (Math.random() - 0.5) * currentRecoil * 50; // Slight sideways shake on recoil
          
          const weaponScale = 1.2; // Make weapon slightly larger on screen
          const scaledW = sprite.w * weaponScale;
          const scaledH = sprite.h * weaponScale;
          
          const weaponBaseX = screenWidth / 2 - scaledW / 2;
          const weaponBaseY = screenHeight - scaledH * 0.9; // Position slightly lower
          
          const finalX = weaponBaseX + bobX + recoilX;
          const finalY = weaponBaseY + bobY + recoilY;
          
          // --- Simple Rectangular Weapon Sprite w/ details ---
          ctx.save(); // Save context state
          ctx.translate(finalX + scaledW / 2, finalY + scaledH / 2); // Move origin to center for rotation/scaling later? No rotation for now.
          ctx.translate(-(finalX + scaledW / 2), -(finalY + scaledH / 2));
          
          // Outline
          ctx.fillStyle = '#111'; // Dark outline
          ctx.fillRect(finalX - 2, finalY - 2, scaledW + 4, scaledH + 4);
          
          // Main Body
          ctx.fillStyle = sprite.color1;
          ctx.fillRect(finalX, finalY, scaledW, scaledH);
          
          // Secondary Color Detail
          ctx.fillStyle = sprite.color2;
          ctx.fillRect(finalX + scaledW * 0.1, finalY + scaledH * 0.6, scaledW * 0.8, scaledH * 0.3); // Grip area?
          ctx.fillRect(finalX + scaledW * 0.2, finalY + scaledH * 0.1, scaledW * 0.6, scaledH * 0.2); // Barrel/top area?
          
          // Metallic Shine/Highlight
          ctx.fillStyle = 'rgba(200, 200, 200, 0.5)';
          ctx.fillRect(finalX + scaledW * 0.1, finalY + scaledH * 0.05, scaledW * 0.8, scaledH * 0.08); // Top highlight
          
          ctx.restore(); // Restore context state
          
          
          // --- Muzzle Flash ---
          if (Date.now() - player.lastShotTimestamp < 50) { // Flash duration 50ms
            const flashSizeBase = 35;
            const flashVariation = 15;
            const flashSize = flashSizeBase + Math.random() * flashVariation;
            // Position flash near where the weapon "muzzle" would be
            const muzzleOffsetX = 0; // Center X for now
            const muzzleOffsetY = -scaledH * 0.1; // Slightly above the weapon base position
            
            const flashX = screenWidth / 2 + muzzleOffsetX + recoilX; // Add recoil shake to flash pos
            const flashY = finalY + muzzleOffsetY + recoilY * 0.5; // Add some recoil offset to flash Y
            
            // Draw multiple layers for a better flash effect
            // Layer 1: Outer Glow (Yellow/Orange)
            let gradient = ctx.createRadialGradient(flashX, flashY, flashSize * 0.2, flashX, flashY, flashSize);
            gradient.addColorStop(0, 'rgba(255, 220, 100, 0.8)');
            gradient.addColorStop(0.6, 'rgba(255, 180, 0, 0.4)');
            gradient.addColorStop(1, 'rgba(255, 150, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(flashX - flashSize, flashY - flashSize, flashSize * 2, flashSize * 2);
            
            // Layer 2: Inner Core (Bright White/Yellow)
            const coreSize = flashSize * 0.4;
            gradient = ctx.createRadialGradient(flashX, flashY, 0, flashX, flashY, coreSize);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
            gradient.addColorStop(0.8, 'rgba(255, 255, 200, 0.5)');
            gradient.addColorStop(1, 'rgba(255, 220, 100, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(flashX - coreSize, flashY - coreSize, coreSize * 2, coreSize * 2);
            
          }
        } // End renderWeapon

        function renderHUD() {
          const margin = 15;
          const barHeight = 22;
          const barWidth = 180;
          const fontSize = 16;
          const fontFace = `bold ${fontSize}px 'Lucida Console', Monaco, monospace`; // Monospaced font
          
          ctx.font = fontFace;
          ctx.textAlign = 'left';
          ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
          ctx.shadowBlur = 3;
          ctx.shadowOffsetX = 1;
          ctx.shadowOffsetY = 1;
          
          
          // --- Health ---
          const healthX = margin;
          const healthY = screenHeight - margin - barHeight;
          // Background
          ctx.fillStyle = 'rgba(40, 40, 40, 0.7)';
          ctx.fillRect(healthX, healthY, barWidth, barHeight);
          // Border
          ctx.strokeStyle = 'rgba(10, 10, 10, 0.9)';
          ctx.lineWidth = 2;
          ctx.strokeRect(healthX, healthY, barWidth, barHeight);
          // Bar
          const healthPercent = player.health / player.maxHealth;
          const healthColor = healthPercent > 0.6 ? '#4CAF50' : (healthPercent > 0.3 ? '#FFC107' : '#F44336'); // Green/Yellow/Red
          ctx.fillStyle = healthColor;
          ctx.fillRect(healthX + 3, healthY + 3, Math.max(0, Math.floor((barWidth - 6) * healthPercent)), barHeight - 6);
          // Text
          ctx.fillStyle = 'white';
          ctx.fillText(`HEALTH: ${player.health}%`, healthX + 8, healthY + barHeight / 2 + fontSize / 2.8);
          
          
          // --- Ammo ---
          const weapon = player.weapons[player.currentWeapon];
          const ammoX = screenWidth - margin - barWidth;
          const ammoY = screenHeight - margin - barHeight;
          // Background
          ctx.fillStyle = 'rgba(40, 40, 40, 0.7)';
          ctx.fillRect(ammoX, ammoY, barWidth, barHeight);
          // Border
          ctx.strokeStyle = 'rgba(10, 10, 10, 0.9)';
          ctx.strokeRect(ammoX, ammoY, barWidth, barHeight);
          // Text
          ctx.textAlign = 'right';
          let ammoText = `${weapon.name.toUpperCase()} | ${weapon.ammo}`;
          if (player.isReloading) {
            ammoText = `RELOADING... [${weapon.name.toUpperCase()}]`;
            ctx.fillStyle = '#FFC107'; // Yellow text while reloading
          } else if (weapon.ammo === 0) {
            ctx.fillStyle = '#F44336'; // Red text if empty
          } else {
            ctx.fillStyle = 'white';
          }
          ctx.fillText(ammoText, ammoX + barWidth - 8, ammoY + barHeight / 2 + fontSize / 2.8);
          
          
          // --- Score ---
          ctx.textAlign = 'center';
          ctx.fillStyle = '#FFEB3B'; // Bright Yellow Score
          ctx.font = `bold ${fontSize * 1.4}px 'Lucida Console', Monaco, monospace`;
          ctx.fillText(`SCORE ${player.score}`, screenWidth / 2, margin + fontSize * 1.2);
          
          
          // Reset styles
          ctx.shadowBlur = 0;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 0;
          ctx.textAlign = 'left';
          ctx.lineWidth = 1; // Reset line width
        }

        function renderCrosshair() {
          const size = 6;
          const gap = 5;
          const thick = 2;
          const color = 'rgba(255, 255, 255, 0.6)'; // Slightly more transparent
          const outlineColor = 'rgba(0, 0, 0, 0.6)';
          const x = screenWidth / 2;
          const y = screenHeight / 2;
          
          // Dynamic gap based on movement/recoil (optional)
          const dynamicGap = gap + currentRecoil * 30 + (player.isMoving ? 2 : 0);
          
          ctx.lineWidth = thick + 1; // Outline thickness
          ctx.strokeStyle = outlineColor;
          
          // Outline
          ctx.beginPath();
          ctx.moveTo(x, y - dynamicGap - size);
          ctx.lineTo(x, y - dynamicGap); // Top
          ctx.moveTo(x, y + dynamicGap);
          ctx.lineTo(x, y + dynamicGap + size); // Bottom
          ctx.moveTo(x - dynamicGap - size, y);
          ctx.lineTo(x - dynamicGap, y); // Left
          ctx.moveTo(x + dynamicGap, y);
          ctx.lineTo(x + dynamicGap + size, y); // Right
          ctx.stroke();
          
          // Inner fill
          ctx.lineWidth = thick;
          ctx.strokeStyle = color;
          ctx.beginPath();
          ctx.moveTo(x, y - dynamicGap - size);
          ctx.lineTo(x, y - dynamicGap); // Top
          ctx.moveTo(x, y + dynamicGap);
          ctx.lineTo(x, y + dynamicGap + size); // Bottom
          ctx.moveTo(x - dynamicGap - size, y);
          ctx.lineTo(x - dynamicGap, y); // Left
          ctx.moveTo(x + dynamicGap, y);
          ctx.lineTo(x + dynamicGap + size, y); // Right
          ctx.stroke();
          
          // Reset line width
          ctx.lineWidth = 1;
        }

        function renderDamageOverlay() {
          if (damageOverlayAlpha > 0) {
            // Vignette effect: darkens corners more
            const gradient = ctx.createRadialGradient(
              screenWidth / 2, screenHeight / 2, screenWidth * 0.2, // Inner radius
              screenWidth / 2, screenHeight / 2, screenWidth * 0.8 // Outer radius
            );
            gradient.addColorStop(0, `rgba(255, 0, 0, ${damageOverlayAlpha * 0.3})`); // Center less red
            gradient.addColorStop(1, `rgba(180, 0, 0, ${damageOverlayAlpha * 0.8})`); // Edges more red and opaque
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, screenWidth, screenHeight);
            
            // Fade out faster initially, then slower
            damageOverlayAlpha -= deltaTime * (1.5 + damageOverlayAlpha * 2.0);
            if (damageOverlayAlpha < 0) damageOverlayAlpha = 0;
          }
        }

        // --- Game Actions (shoot, reload, etc.) - Mostly unchanged, ensure they exist ---
        function shoot() {
          const weapon = player.weapons[player.currentWeapon];
          player.lastShotTimestamp = Date.now();
          weapon.ammo--;
          playSound(weapon.sound, 0.9, 1.0 + (Math.random() - 0.5) * 0.1);
          
          currentRecoil = maxRecoil;
          
          for (let i = 0; i < weapon.projectiles; i++) {
            const spreadAngle = (Math.random() - 0.5) * weapon.spread * 2;
            const shotAngle = player.angle + spreadAngle;
            const ray = castRay(player.x, player.y, shotAngle);
            
            let hitEnemy = null;
            let minDistToEnemy = ray.distance;
            
            // Refined hit detection for multiple enemies
            const potentialHits = enemies
              .filter(e => e.state !== 'dead' && e.dist < minDistToEnemy && e.isVisible) // Use pre-calculated visibility/dist
              .sort((a, b) => a.dist - b.dist); // Sort nearby visible enemies by distance
            
            for (const enemy of potentialHits) {
              const angleDiff = Math.abs(enemy.angle - spreadAngle);
              // Check if angle is within enemy's apparent size at that distance
              const apparentSizeAngle = Math.atan(enemy.size / enemy.dist); // angle subtended by enemy size
              if (angleDiff < apparentSizeAngle * 0.8) { // Allow hitting if shot angle is within ~80% of enemy visual angle
                hitEnemy = enemy;
                minDistToEnemy = enemy.dist; // Track closest hit
                break; // Hit the first enemy in the sorted list
              }
            }
            
            
            if (hitEnemy) {
              // Hit Enemy
              hitEnemy.currentHealth -= weapon.damage;
              hitEnemy.lastHitTimestamp = Date.now();
              hitEnemy.isHit = true;
              playSound(hitEnemy.soundHurt, 0.8, 1.0 + (Math.random() - 0.5) * 0.1, hitEnemy);
              createImpactParticles(hitEnemy.x, hitEnemy.y, '#C80815'); // More fleshy red color
              
              if (hitEnemy.currentHealth <= 0 && hitEnemy.state !== 'dying') { // Prevent multiple death triggers
                triggerEnemyDeath(hitEnemy);
              }
            } else {
              // Hit Wall - More noticeable sparks
              const hitX = player.x + Math.cos(shotAngle) * ray.distance * 0.99; // Position slightly before wall
              const hitY = player.y + Math.sin(shotAngle) * ray.distance * 0.99;
              createImpactParticles(hitX, hitY, '#FFFF88'); // Brighter yellow/white sparks
              playSound('impactWall', 0.5, 1.0 + (Math.random() - 0.5) * 0.2, {
                x: hitX,
                y: hitY
              });
            }
          }
          updateHUD();
        }
        // tryReload, finishReload, switchWeapon, triggerDamageOverlay, triggerEnemyDeath, triggerGameOver, togglePause, stopAllSounds...
        // These functions should remain mostly the same as the logic is sound.
        function tryReload() {
          const weapon = player.weapons[player.currentWeapon];
          if (!player.isReloading && weapon.ammo < weapon.maxAmmo) {
            player.isReloading = true;
            player.reloadTimer = weapon.reloadTime;
            playSound('reloadSound', 0.8);
            updateHUD();
          }
        }

        function finishReload() {
          const weapon = player.weapons[player.currentWeapon];
          player.isReloading = false;
          weapon.ammo = weapon.maxAmmo; // Simple full reload for now
          updateHUD();
        }

        function switchWeapon(num) {
          const weaponKeys = Object.keys(player.weapons);
          if (num >= 1 && num <= weaponKeys.length) {
            const newWeaponKey = weaponKeys[num - 1];
            if (newWeaponKey !== player.currentWeapon) {
              player.currentWeapon = newWeaponKey;
              player.isReloading = false;
              player.reloadTimer = 0;
              playSound('weaponSwitch', 0.7);
              console.log(`Switched to ${player.weapons[player.currentWeapon].name}`);
              updateHUD();
            }
          }
        }

        function triggerDamageOverlay() {
          damageOverlayAlpha = 0.7; // Slightly more opaque
        }

        function triggerEnemyDeath(enemy) {
          enemy.state = 'dying';
          enemy.dyingTimer = 0.5; // Duration of death fade/animation
          // Optionally stop any looping sounds for this enemy
          player.score += enemy.scoreValue;
          console.log(`Enemy down! Score: ${player.score}`);
          playSound(enemy.soundDeath, 0.9, 1.0, enemy); // Play death sound immediately
          updateHUD();
        }

        function triggerGameOver() {
          if (isGameOver) return;
          console.log("GAME OVER");
          isGameOver = true;
          stopAllSounds();
          playSound('playerDeath', 1.0);
          finalScoreElement.textContent = `Final Score: ${player.score}`;
          gameOverScreen.classList.add('show');
          adContainer.style.display = 'block'; // Use 'block' or 'flex' depending on desired layout
          document.exitPointerLock();
        }

        function togglePause() {
          isPaused = !isPaused;
          if (isPaused) {
            // Pause All Sounds might be too abrupt, maybe just mute masterGain or looping sounds
            masterGain.gain.setTargetAtTime(0, audioContext.currentTime, 0.1); // Fade out master gain
            pauseScreen.classList.add('show');
            document.exitPointerLock();
          } else {
            // Unmute master gain
            masterGain.gain.setTargetAtTime(0.7, audioContext.currentTime, 0.1); // Fade in master gain (restore original volume)
            pauseScreen.classList.remove('show');
            canvas.requestPointerLock().catch(err => console.error("Pointer lock failed on resume:", err));
            lastTimestamp = performance.now(); // Reset timer on resume
          }
          console.log(isPaused ? "Game Paused" : "Game Resumed");
        }

        function stopAllSounds() { // Stops BufferSourceNodes immediately
          if (!isAudioInitialized) return;
          activeSounds.forEach(sound => {
            try {
              sound.source.stop();
            } catch (e) {
              /* May already be stopped or invalid */ }
          });
          activeSounds.clear();
        }

        // --- Ray Casting Optimization (Minor) ---
        function castRay(originX, originY, angle) {
          // Normalize angle (no change needed here usually)
          angle = (angle + 2 * Math.PI) % (2 * Math.PI);
          
          const dirX = Math.cos(angle);
          const dirY = Math.sin(angle);
          // Use bitwise OR 0 for potential faster floor conversion (benchmark may vary by browser/context)
          let mapX = originX | 0;
          let mapY = originY | 0;
          
          // Avoid Infinity for deltaDist if possible, use a very large number, though Infinity is often handled well now.
          const deltaDistX = (dirX === 0) ? 1e30 : Math.abs(1 / dirX);
          const deltaDistY = (dirY === 0) ? 1e30 : Math.abs(1 / dirY);
          let stepX, stepY;
          let sideDistX, sideDistY;
          
          if (dirX < 0) {
            stepX = -1;
            sideDistX = (originX - mapX) * deltaDistX;
          } else {
            stepX = 1;
            sideDistX = (mapX + 1 - originX) * deltaDistX;
          }
          if (dirY < 0) {
            stepY = -1;
            sideDistY = (originY - mapY) * deltaDistY;
          } else {
            stepY = 1;
            sideDistY = (mapY + 1 - originY) * deltaDistY;
          }
          
          let hit = false;
          let side = 0;
          const maxDist = 30;
          let distance = 0;
          let hitDist = maxDist; // Store exact hit distance
          
          // Optimized DDA loop: Check for Infinity conditions early
          while (!hit && distance < maxDist) {
            let stepOnX = sideDistX < sideDistY;
            
            if (stepOnX) {
              if (deltaDistX === 1e30) break; // Cannot hit a vertical wall if ray is perfectly horizontal
              distance = sideDistX;
              sideDistX += deltaDistX;
              mapX += stepX;
              side = 0;
            } else {
              if (deltaDistY === 1e30) break; // Cannot hit a horizontal wall if ray is perfectly vertical
              distance = sideDistY;
              sideDistY += deltaDistY;
              mapY += stepY;
              side = 1;
            }
            if (isWall(mapX, mapY)) {
              hit = true;
              hitDist = distance; // Record the distance at which the wall was hit
            }
          }
          
          distance = hit ? hitDist : maxDist;
          
          // Perpendicular distance - calculation remains the same conceptually
          const perpWallDist = Math.max(0.01, distance * Math.cos(angle - player.angle));
          
          // Return necessary info - Use bitwise floor | 0
          return {
            distance: distance,
            perpWallDist: perpWallDist,
            side: side,
            mapX: mapX | 0, // Ensure integer map coords
            mapY: mapY | 0,
            angle: angle
          };
        }

        function castRayEnemy(originX, originY, angle) {
          // Simplified version of castRay just for checking Line of Sight between points
          // Only checks for wall hits, doesn't need all rendering details
          angle = (angle + 2 * Math.PI) % (2 * Math.PI); // Normalize angle
          const dirX = Math.cos(angle);
          const dirY = Math.sin(angle);
          let mapX = Math.floor(originX);
          let mapY = Math.floor(originY);
          const deltaDistX = (dirX === 0) ? Infinity : Math.abs(1 / dirX);
          const deltaDistY = (dirY === 0) ? Infinity : Math.abs(1 / dirY);
          let stepX, stepY;
          let sideDistX, sideDistY;
          
          if (dirX < 0) {
            stepX = -1;
            sideDistX = (originX - mapX) * deltaDistX;
          } else {
            stepX = 1;
            sideDistX = (mapX + 1 - originX) * deltaDistX;
          }
          if (dirY < 0) {
            stepY = -1;
            sideDistY = (originY - mapY) * deltaDistY;
          } else {
            stepY = 1;
            sideDistY = (mapY + 1 - originY) * deltaDistY;
          }
          
          let hit = false;
          const maxDist = 30;
          let distance = 0;
          
          while (!hit && distance < maxDist) {
            if (sideDistX < sideDistY) {
              if (deltaDistX === Infinity) break; // Cannot proceed
              distance = sideDistX;
              sideDistX += deltaDistX;
              mapX += stepX;
            } else {
              if (deltaDistY === Infinity) break; // Cannot proceed
              distance = sideDistY;
              sideDistY += deltaDistY;
              mapY += stepY;
            }
            if (isWall(mapX, mapY)) {
              hit = true;
            }
          }
          // Returns distance to the first wall hit along the angle, or maxDist if no hit
          return {
            distance: distance
          };
        }


        function createImpactParticles(x, y, baseColorHex) {
          const numParticles = 8 + Math.floor(Math.random() * 8); // 8-15 particles
          const baseSpeed = 2 + Math.random() * 3; // Base speed 2-5
          const life = 0.3 + Math.random() * 0.5; // Lifespan 0.3-0.8s
          
          const baseColor = hexToRgb(baseColorHex);
          
          for (let i = 0; i < numParticles; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = baseSpeed * (0.5 + Math.random() * 1.0); // Vary speed
            const particle = {
              x: x + (Math.random() - 0.5) * 0.1, // Slightly offset start pos
              y: y + (Math.random() - 0.5) * 0.1,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              r: Math.max(0, Math.min(255, baseColor.r + Math.random() * 60 - 30)), // Color variation
              g: Math.max(0, Math.min(255, baseColor.g + Math.random() * 60 - 30)),
              b: Math.max(0, Math.min(255, baseColor.b + Math.random() * 60 - 30)),
              alpha: 0.8 + Math.random() * 0.2, // Start fairly opaque
              decay: 1.0 / life, // Calculate decay rate based on desired lifespan
              size: 1.5 + Math.random() * 1.5, // Particle size 1.5-3
            };
            particles.push(particle);
          }
        }

        function shadeColor(hexColor, percent, multiplier = 1.0) {
          if (!hexColor || hexColor.length < 7) return '#000000'; // Basic error check
          let {
            r,
            g,
            b
          } = hexToRgb(hexColor);
          
          // Apply percentage adjustment
          const change = percent / 100;
          r = Math.round(r * (1 + change));
          g = Math.round(g * (1 + change));
          b = Math.round(b * (1 + change));
          
          // Apply multiplier
          r = Math.round(r * multiplier);
          g = Math.round(g * multiplier);
          b = Math.round(b * multiplier);
          
          // Clamp values
          r = Math.min(255, Math.max(0, r));
          g = Math.min(255, Math.max(0, g));
          b = Math.min(255, Math.max(0, b));
          
          // Convert back to hex
          const rr = r.toString(16).padStart(2, '0');
          const gg = g.toString(16).padStart(2, '0');
          const bb = b.toString(16).padStart(2, '0');
          return `#${rr}${gg}${bb}`;
        }

        function hexToRgb(hex) {
          if (!hex) return {
            r: 0,
            g: 0,
            b: 0
          };
          const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
          } : {
            r: 0,
            g: 0,
            b: 0
          };
        }

        function lerpColor(hexColorA, hexColorB, amount) {
          const rgbA = hexToRgb(hexColorA);
          const rgbB = hexToRgb(hexColorB);
          const amountClamped = Math.max(0, Math.min(1, amount));
          
          const r = Math.round(rgbA.r + (rgbB.r - rgbA.r) * amountClamped);
          const g = Math.round(rgbA.g + (rgbB.g - rgbA.g) * amountClamped);
          const b = Math.round(rgbA.b + (rgbB.b - rgbA.b) * amountClamped);
          
          // Convert back to hex
          const rr = r.toString(16).padStart(2, '0');
          const gg = g.toString(16).padStart(2, '0');
          const bb = b.toString(16).padStart(2, '0');
          return `#${rr}${gg}${bb}`;
        }

        function updateHUD() { // Call this when player stats change
          // This is implicitly called by the main renderHUD now
          // Can leave it empty or add specific logic if HUD render isn't always running
        }

        // --- Game Loop ---
        function gameLoop(timestamp) {
          deltaTime = (timestamp - lastTimestamp) / 1000; // Delta time in seconds
          lastTimestamp = timestamp;
          
          // Limit max deltaTime to prevent physics jumps after long pauses/lag
          deltaTime = Math.min(deltaTime, 0.1); // Max 100ms step
          
          if (gameStarted) {
            if (!isPaused && !isGameOver) {
              update(deltaTime); // Update game logic
            }
            render(); // Always render (render includes drawing pause/game over screens)
          } else {
            // Keep drawing start screen while not started
            renderStartScreen(); // Need a specific function to draw *only* the start screen UI
          }
          
          requestAnimationFrame(gameLoop);
        }

        function startGame() {
          console.log("Starting game...");
          startScreen.classList.remove('show');
          adContainer.style.display = 'none'; // Hide ad on start
          gameStarted = true;
          initializeGame(); // Set initial game state
          initAudio(); // Ensure audio is ready
          // Reset timestamps for smooth start
          lastTimestamp = performance.now();
          // Attempt pointer lock
          canvas.requestPointerLock().catch(err => console.error("Pointer lock failed on start:", err));
          requestAnimationFrame(gameLoop); // Start the main loop properly
        }

        function renderStartScreen() {
          // Simple background clear for standalone rendering
          // ctx.fillStyle = "#111";
          // ctx.fillRect(0,0, screenWidth, screenHeight);
          // UI is handled by HTML/CSS overlay
        }


        // --- Initialization ---
        console.log("Setting up game...");
        // No need to call initializeGame here, called on startGame click
        setupInputHandlers();
        // Initial display of start screen is handled by CSS
        adContainer.style.display = 'block'; // Show ad initially

        // Request first frame to draw the start screen initially
        requestAnimationFrame(gameLoop);

    </script>
</body>
</html>