<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KM6SHZXP');
    </script>
    <!-- End Google Tag Manager -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Shooter Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #game-container {
            position: relative;
            width: 600px;
            height: 400px;
            border: 2px solid #333;
            background-color: #050510;
            overflow: hidden;
        }
        #player {
            position: absolute;
            width: 40px;
            height: 40px;
            bottom: 20px;
            left: 280px;
            transition: opacity 0.15s ease-in-out;
        }
        #player polygon {
            fill: #3498db;
        }
        #player rect {
            animation: thrust 0.1s infinite alternate;
        }
        @keyframes thrust {
            from { fill: #e74c3c; }
            to { fill: #ff7f50; }
        }
        .enemy {
            position: absolute;
            width: 30px;
            height: 30px;
            transition: transform 0.1s ease-out;
        }
        .enemy.hit {
            transform: scale(1.1);
            filter: brightness(1.5);
        }
        .bullet {
            position: absolute;
            width: 10px;
            height: 20px;
            background-color: #f1c40f;
            border-radius: 3px;
            box-shadow: 0 0 4px #f1c40f;
        }
        .special-bullet {
            position: absolute;
            width: 10px;
            height: 20px;
            background-color: #00ffff;
            box-shadow: 0 0 8px #00ffff, 0 0 4px #ffffff inset;
            border-radius: 3px;
        }
        .star {
            position: absolute;
            width: 2px;
            height: 2px;
            background-color: white;
            border-radius: 50%;
            pointer-events: none;
        }
        .star-layer1 {
            width: 2px;
            height: 2px;
            opacity: 0.9;
        }
        .star-layer2 {
            width: 1.5px;
            height: 1.5px;
            opacity: 0.6;
        }
        .star-layer3 {
            width: 1px;
            height: 1px;
            opacity: 0.4;
        }
        #score {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        #player-hp-bar-container {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 100px;
            height: 15px;
            background-color: #555;
            border: 1px solid #888;
            border-radius: 3px;
        }
        #player-hp-bar-fill {
            height: 100%;
            width: 100%;
            background-color: #e74c3c;
            border-radius: 2px;
            transition: width 0.2s ease-out;
        }
        #special-charges {
            position: absolute;
            top: 40px;
            right: 10px;
            color: #00ffff;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        #phase-display {
            position: absolute;
            top: 40px;
            left: 10px;
            color: #ff9900;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        #special-active {
            position: absolute;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            color: #00ffff;
            font-size: 16px;
            display: none;
        }
        #special-bar {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 10px;
            background-color: #333;
            border-radius: 5px;
        }
        #special-bar-fill {
            height: 100%;
            width: 100%;
            background-color: #00ffff;
            border-radius: 5px;
            transition: width 0.1s;
        }
        #player.invulnerable {
            opacity: 0.5;
            animation: blink 0.15s linear infinite;
        }
        @keyframes blink {
            50% { opacity: 0.2; }
        }
        button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 18px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        .explosion {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: orange;
            border-radius: 50%;
            pointer-events: none;
            animation: explode 0.3s ease-out forwards;
            z-index: 5;
        }
        @keyframes explode {
            0% { transform: scale(0.1); opacity: 1; background-color: yellow; }
            50% { background-color: orange; }
            100% { transform: scale(1.5); opacity: 0; background-color: darkred; }
        }
        #game-container.shake {
            animation: screenShake 0.15s linear;
        }
        @keyframes screenShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px) rotate(-0.5deg); }
            50% { transform: translateX(3px) rotate(0.5deg); }
            75% { transform: translateX(-2px) rotate(-0.2deg); }
        }
        #boss {
            position: absolute;
            width: 100px;
            height: 100px;
            top: 30px;
            left: calc(50% - 50px);
            z-index: 3;
        }
        #boss svg {
            width: 100%;
            height: 100%;
        }
        #boss-hp-bar-container {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            background-color: #444;
            border: 1px solid #ccc;
            border-radius: 5px;
            z-index: 10;
            text-align: center;
        }
        #boss-hp-bar-fill {
            height: 100%;
            width: 100%;
            background-color: #e74c3c;
            border-radius: 4px;
            transition: width 0.3s ease-out;
        }
        #boss-name {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            line-height: 20px;
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
        }
        #high-score {
            margin-top: 10px;
            font-size: 18px;
            color: #f1c40f;
        }
        .enemy-bullet {
            position: absolute;
            width: 8px;
            height: 15px;
            background-color: #e74c3c;
            border-radius: 4px;
            box-shadow: 0 0 3px #e74c3c;
        }
        .powerup {
            position: absolute;
            width: 25px;
            height: 25px;
            animation: pulse 1s infinite alternate;
            z-index: 2;
        }
        .powerup svg {
            width: 100%;
            height: 100%;
        }
        @keyframes pulse {
            from { transform: scale(1); filter: brightness(1); }
            to { transform: scale(1.2); filter: brightness(1.3); }
        }
        #player.shielded::after {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            width: calc(100% + 20px);
            height: calc(100% + 20px);
            border-radius: 50%;
            border: 2px solid #3498db;
            box-shadow: 0 0 10px #3498db;
            animation: shield-pulse 1s infinite alternate;
            pointer-events: none;
        }
        @keyframes shield-pulse {
            from { transform: scale(1); opacity: 0.5; }
            to { transform: scale(1.1); opacity: 0.8; }
        }
        .bullet.homing {
            width: 12px;
            height: 12px;
            background-color: #e67e22;
            border-radius: 50%;
            box-shadow: 0 0 8px #e67e22;
        }
    </style>
</head>
<body>
<!-- Google Tag Manager (noscript) -->
<noscript>
    <iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KM6SHZXP"
            height="0" width="0" style="display:none;visibility:hidden"></iframe>
</noscript>
<!-- End Google Tag Manager (noscript) -->

<div id="game-container">
    <div id="score">Score: 0</div>
    <div id="player-hp-bar-container">
        <div id="player-hp-bar-fill"></div>
    </div>
    <div id="phase-display">Fase: 1</div>
    <div id="special-charges">Tiro Especial: 3</div>
    <div id="special-active">TIRO TRIPLO ATIVO!</div>
    <div id="special-bar">
        <div id="special-bar-fill"></div>
    </div>
    <div id="boss-hp-bar-container" style="display: none;">
        <div id="boss-hp-bar-fill"></div>
        <div id="boss-name">Bossnick</div>
    </div>
    <svg id="player" viewBox="0 0 100 100">
        <polygon points="50,0 100,100 50,70 0,100" fill="#3498db"/>
        <rect x="45" y="70" width="10" height="20" fill="#e74c3c"/>
    </svg>
    <div id="boss" style="display: none;">
        <svg viewBox="0 0 150 150">
            <rect x="10" y="10" width="130" height="100" fill="#8e44ad" rx="15"/>
            <circle cx="75" cy="60" r="25" fill="#c0392b"/>
            <rect x="30" y="110" width="20" height="30" fill="#bdc3c7"/>
            <rect x="100" y="110" width="20" height="30" fill="#bdc3c7"/>
        </svg>
    </div>
    <div id="game-over">
        <div>Game Over</div>
        <div id="final-score">Score: 0</div>
        <div id="high-score">High Score: 0</div>
        <button id="restart-button">Play Again</button>
    </div>
</div>

<!-- Efeitos Sonoros e Música -->
<audio id="sfx-shoot" src="../assets/sounds/laser-shoot.mp3" preload="auto"></audio>
<audio id="sfx-special-shoot" src="../assets/sounds/special-shoot.mp3" preload="auto"></audio>
<audio id="sfx-enemy-hit" src="../assets/sounds/enemy_hit.mp3" preload="auto"></audio>
<audio id="sfx-pop" src="../assets/sounds/sfx-pop.mp3" preload="auto"></audio>
<audio id="sfx-explosion" src="../assets/sounds/explosion.mp3" preload="auto"></audio>
<audio id="sfx-player-damage" src="../assets/sounds/player_damage.mp3" preload="auto"></audio>
<audio id="sfx-game-over" src="../assets/sounds/game_over.mp3" preload="auto"></audio>
<audio id="sfx-powerup" src="../assets/sounds/powerup.mp3" preload="auto"></audio>
<audio id="bgm-game" src="../assets/sounds/trl-epica-dramatica-motivacional-arrepiante-202402121831.mp3" loop
       preload="auto"></audio>
<audio id="bgm-game-over" src="../assets/sounds/game_over_bgm.mp3" preload="auto"></audio>

<script>
    const gameContainer = document.getElementById('game-container');
    const player = document.getElementById('player');
    const scoreElement = document.getElementById('score');
    const playerHPBarFill = document.getElementById('player-hp-bar-fill');
    const phaseDisplay = document.getElementById('phase-display');
    const specialChargesElement = document.getElementById('special-charges');
    const specialActiveElement = document.getElementById('special-active');
    const specialBarFill = document.getElementById('special-bar-fill');
    const gameOverScreen = document.getElementById('game-over');
    const finalScoreElement = document.getElementById('final-score');
    const highScoreElement = document.getElementById('high-score');
    const restartButton = document.getElementById('restart-button');
    const bossElement = document.getElementById('boss');
    const bossHPContainer = document.getElementById('boss-hp-bar-container');
    const bossHPFill = document.getElementById('boss-hp-bar-fill');

    const containerWidth = gameContainer.offsetWidth;
    const containerHeight = gameContainer.offsetHeight;
    const playerWidth = 40;
    const playerHeight = 40;

    let playerX = containerWidth / 2 - playerWidth / 2;
    let playerY = containerHeight - playerHeight - 20;
    let bullets = [];
    let enemies = [];
    let enemyBullets = [];
    let stars = [];
    let score = 0;
    let highScore = 0;
    let playerMaxHP = 100;
    let playerCurrentHP = playerMaxHP;
    let isPlayerInvulnerable = false;
    let playerInvulnerableTimer = null;
    const playerInvulnerableDuration = 1500;
    let isGameOver = false;
    let gameLoopId;
    let currentPhase = 1;
    let phaseProgress = 0;
    const phaseGoals = [25, 1, 35, 1, 45, 1, 55, 1, 65, 1, 75, 1, 85, 1, 95, 1];
    let isBossActive = false;
    let bossData = {};
    let specialCharges = 3;
    let isSpecialActive = false;
    let specialTimer = null;
    let specialTimeLeft = 0;

    let isLeftPressed = false;
    let isRightPressed = false;
    let isFirePressed = false;
    let isSpecialPressed = false;
    let lastFireTime = 0;
    let lastEnemySpawnTime = 0;

    const sfxPowerup = document.getElementById('sfx-powerup');
    const sfxShoot = document.getElementById('sfx-shoot');
    const sfxSpecialShoot = document.getElementById('sfx-special-shoot');
    const sfxExplosion = document.getElementById('sfx-explosion');
    const sfxPop = document.getElementById('sfx-pop');
    const sfxPlayerDamage = document.getElementById('sfx-player-damage');
    const sfxGameOver = document.getElementById('sfx-game-over');
    const bgmGame = document.getElementById('bgm-game');
    const bgmGameOver = document.getElementById('bgm-game-over');

    let summonedEnemies = [];
    let lastBossSummonTime = 0;
    let powerups = [];
    let hasShield = 0;

    let isHomingActive = false;
    let homingTimer = null;

    function playSound(audioElement) {
        if (audioElement) {
            audioElement.currentTime = 0;
            audioElement.play().catch(error => {
                console.error("Error playing sound:", error);
            });
        }
    }

    function stopMusic() {
        if (bgmGame) bgmGame.pause();
        if (bgmGameOver) bgmGameOver.pause();
    }

    function createStars() {
        stars.forEach(star => {
            if(star.parentNode === gameContainer) gameContainer.removeChild(star);
        });
        stars = [];

        const starCounts = { layer1: 30, layer2: 40, layer3: 50 };
        const starSpeeds = { layer1: 0.8, layer2: 0.4, layer3: 0.2 };

        for (const layer in starCounts) {
            for (let i = 0; i < starCounts[layer]; i++) {
                const star = document.createElement('div');
                star.className = `star star-${layer}`;
                star.style.left = Math.random() * containerWidth + 'px';
                star.style.top = Math.random() * containerHeight + 'px';
                star.speed = starSpeeds[layer] * (Math.random() * 0.5 + 0.75);
                gameContainer.insertBefore(star, player);
                stars.push(star);
            }
        }
    }

    function updatePlayer() {
        if (isLeftPressed && playerX > 0) {
            playerX -= 7;
        }
        if (isRightPressed && playerX < containerWidth - playerWidth) {
            playerX += 7;
        }
        player.style.left = playerX + 'px';
    }

    function createExplosion(x, y) {
        const explosion = document.createElement('div');
        explosion.className = 'explosion';

        // Obtém a posição do container do jogo
        const containerRect = gameContainer.getBoundingClientRect();

        // Ajusta as coordenadas para serem relativas ao container
        const relativeX = x - containerRect.left;
        const relativeY = y - containerRect.top;

        explosion.style.left = (relativeX - 25) + 'px';
        explosion.style.top = (relativeY - 25) + 'px';
        gameContainer.appendChild(explosion);
        playSound(sfxPop);

        setTimeout(() => {
            if (explosion.parentNode === gameContainer) {
                gameContainer.removeChild(explosion);
            }
        }, 300);
    }

    function fireBullet() {
        const currentTime = Date.now();
        if (currentTime - lastFireTime < 150) return;

        if (isSpecialActive) {
            const bullet1 = document.createElement('div');
            bullet1.className = 'special-bullet';
            bullet1.style.left = (playerX + playerWidth / 2 - 5) + 'px';
            bullet1.style.top = (playerY - 15) + 'px';
            bullet1.speedX = 0;
            bullet1.speedY = -10;
            gameContainer.appendChild(bullet1);
            bullets.push(bullet1);
            playSound(sfxSpecialShoot);

            const bullet2 = document.createElement('div');
            bullet2.className = 'special-bullet';
            bullet2.style.left = (playerX + playerWidth / 2 - 15) + 'px';
            bullet2.style.top = (playerY - 10) + 'px';
            bullet2.speedX = -2;
            bullet2.speedY = -9;
            gameContainer.appendChild(bullet2);
            bullets.push(bullet2);

            const bullet3 = document.createElement('div');
            bullet3.className = 'special-bullet';
            bullet3.style.left = (playerX + playerWidth / 2 + 5) + 'px';
            bullet3.style.top = (playerY - 10) + 'px';
            bullet3.speedX = 2;
            bullet3.speedY = -9;
            gameContainer.appendChild(bullet3);
            bullets.push(bullet3);
        } else {
            const bullet = document.createElement('div');
            bullet.className = isHomingActive ? 'bullet homing' : 'bullet';
            bullet.style.left = (playerX + playerWidth / 2 - 5) + 'px';
            bullet.style.top = (playerY - 15) + 'px';
            bullet.speedX = 0;
            bullet.speedY = -10;
            gameContainer.appendChild(bullet);
            bullets.push(bullet);
            playSound(sfxShoot);
        }

        lastFireTime = currentTime;
    }

    function activateSpecial() {
        if (specialCharges > 0 && !isSpecialActive) {
            isSpecialActive = true;
            specialCharges--;
            specialChargesElement.textContent = `Tiro Especial: ${specialCharges}`;
            specialActiveElement.style.display = 'block';
            specialTimeLeft = 2000;

            if (specialTimer) {
                clearInterval(specialTimer);
            }

            specialTimer = setInterval(() => {
                specialTimeLeft -= 100;
                const percentage = (specialTimeLeft / 2000) * 100;
                specialBarFill.style.width = `${percentage}%`;

                if (specialTimeLeft <= 0) {
                    deactivateSpecial();
                }
            }, 100);
        }
    }

    function deactivateSpecial() {
        isSpecialActive = false;
        specialActiveElement.style.display = 'none';
        specialBarFill.style.width = '0%';

        if (specialTimer) {
            clearInterval(specialTimer);
            specialTimer = null;
        }
    }

    function updateBullets() {
        for (let i = bullets.length - 1; i >= 0; i--) {
            const bullet = bullets[i];
            let x = parseFloat(bullet.style.left);
            let y = parseFloat(bullet.style.top);

            if (isHomingActive && !bullet.classList.contains('special-bullet')) {
                let targetX = null;
                let targetY = null;
                let closestDist = Infinity;

                // Checa o boss primeiro se estiver ativo
                if (isBossActive) {
                    const bossCenterX = parseFloat(bossElement.style.left) + 15;
                    const bossCenterY = parseFloat(bossElement.style.top) + 15;
                    const distToBoss = Math.hypot(bossCenterX - x, bossCenterY - y);

                    if (distToBoss < closestDist) {
                        closestDist = distToBoss;
                        targetX = bossCenterX;
                        targetY = bossCenterY;
                    }
                }

                // Checa inimigos normais e invocados
                const allEnemies = enemies.concat(summonedEnemies);
                for (const enemy of allEnemies) {
                    const enemyX = parseFloat(enemy.style.left) + 15;
                    const enemyY = parseFloat(enemy.style.top) + 15;
                    const dist = Math.hypot(enemyX - x, enemyY - y);

                    if (dist < closestDist) {
                        closestDist = dist;
                        targetX = enemyX;
                        targetY = enemyY;
                    }
                }

                // Se encontrou um alvo, ajusta a trajetória
                if (targetX !== null && targetY !== null) {
                    const angle = Math.atan2(targetY - y, targetX - x);
                    bullet.speedX = Math.cos(angle) * 8;
                    bullet.speedY = Math.sin(angle) * 8;
                }
            }

            x += (bullet.speedX || 0);
            y += (bullet.speedY || -10);

            if (y < 0 || x < 0 || x > containerWidth || y > containerHeight) {
                gameContainer.removeChild(bullet);
                bullets.splice(i, 1);
            } else {
                bullet.style.left = x + 'px';
                bullet.style.top = y + 'px';
            }
        }
    }

    function createEnemy(forceSpawn = false, optionalX, optionalY) {
            if (isBossActive && !forceSpawn) return;

            const now = Date.now();
            const timeSinceLastSpawn = now - lastEnemySpawnTime;

            const baseSpawnInterval = 1500 - (currentPhase * 100);
            const spawnInterval = Math.max(300, baseSpawnInterval);
            const maxEnemiesAllowed = 6 + currentPhase * 2;

            let shouldSpawn = forceSpawn;
            if (!forceSpawn) {
                shouldSpawn = timeSinceLastSpawn > spawnInterval && enemies.length < maxEnemiesAllowed;
            }

            if (shouldSpawn) {
                if (!forceSpawn) {
                    lastEnemySpawnTime = now;
                }

                const enemy = document.createElement('div');
                enemy.className = 'enemy';

                let enemyType = 0;
                if (currentPhase >= 2) {
                    // Gera aleatoriamente os inimigos de tipo 0, 1 ou 2
                    enemyType = Math.floor(Math.random() * 3);
                }

                // Corrige o visual para garantir que o inimigo do tipo 2 tenha a forma correta
                enemy.innerHTML = `<svg viewBox="0 0 100 100">
                    ${enemyType === 0 ? '<circle cx="50" cy="50" r="40" fill="#e74c3c"/><circle cx="30" cy="40" r="10" fill="#000"/><circle cx="70" cy="40" r="10" fill="#000"/>' :
                      enemyType === 1 ? '<polygon points="10,50 50,10 90,50 50,90" fill="#9b59b6"/><circle cx="35" cy="45" r="8" fill="#000"/><circle cx="65" cy="45" r="8" fill="#000"/>' :
                      // Novo inimigo atirador, com uma forma de cruz e cor roxa
                      '<rect x="20" y="40" width="60" height="20" fill="#9b59b6"/><rect x="40" y="20" width="20" height="60" fill="#9b59b6"/>'}
                </svg>`;

                const x = optionalX !== undefined ? optionalX : Math.random() * (containerWidth - 30);
                const y = optionalY !== undefined ? optionalY : -30;
                enemy.style.left = x + 'px';
                enemy.style.top = y + 'px';

                const baseSpeed = 0.5 + (currentPhase * 0.15);
                enemy.speed = forceSpawn ? baseSpeed * 0.8 : Math.random() * 1 + baseSpeed;

                enemy.movementType = 0;
                if (currentPhase >= 2 && Math.random() < 0.4) {
                    enemy.movementType = 1;
                    enemy.amplitude = Math.random() * 20 + 10;
                    enemy.frequency = Math.random() * 0.1 + 0.05;
                    enemy.movementOffset = Math.random() * Math.PI * 2;
                }

                // Adicionado: Armazena o tipo do inimigo no próprio objeto. ISSO É ESSENCIAL.
                enemy.type = enemyType;

                gameContainer.appendChild(enemy);
                if (forceSpawn) {
                    summonedEnemies.push(enemy);
                } else {
                    enemies.push(enemy);
                }
            }
        }

    function updateEnemies() {
        if (!isBossActive) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                let x = parseFloat(enemy.style.left);
                let y = parseFloat(enemy.style.top) + enemy.speed;

                if (enemy.movementType === 1) {
                    enemy.movementOffset += enemy.frequency;
                    x += Math.sin(enemy.movementOffset) * 2;
                }

                if (x < 0) x = 0;
                if (x > containerWidth - 30) x = containerWidth - 30;

                if (y > containerHeight) {
                    if (enemy.parentNode === gameContainer) gameContainer.removeChild(enemy);
                    enemies.splice(i, 1);
                    if (currentPhase > 1) {
                        playerTakeDamage(Math.random() * 10 + 5);
                    }
                } else {
                    enemy.style.left = x + 'px';
                    enemy.style.top = y + 'px';
                }
            }
        }

        for (let i = summonedEnemies.length - 1; i >= 0; i--) {
            const enemy = summonedEnemies[i];
            let x = parseFloat(enemy.style.left);
            let y = parseFloat(enemy.style.top) + enemy.speed;

            if (enemy.movementType === 1) {
                enemy.movementOffset += enemy.frequency;
                x += Math.sin(enemy.movementOffset) * 1.5;
            }

            if (x < 0) x = 0;
            if (x > containerWidth - 30) x = containerWidth - 30;

            if (y > containerHeight) {
                if (enemy.parentNode === gameContainer) gameContainer.removeChild(enemy);
                summonedEnemies.splice(i, 1);
            } else {
                enemy.style.left = x + 'px';
                enemy.style.top = y + 'px';
            }
        }
    }

    function updateStars() {
        for (let i = 0; i < stars.length; i++) {
            const star = stars[i];
            let y = parseFloat(star.style.top) + star.speed;

            if (y > containerHeight) {
                y = -5;
                star.style.left = Math.random() * containerWidth + 'px';
            }

            star.style.top = y + 'px';
        }
    }

    function createPowerup(x, y) {
        const powerupChance = (7 - currentPhase) / 10;
        if (Math.random() > powerupChance) return; // 10% de chance de criar powerup

        const powerup = document.createElement('div');
        powerup.className = 'powerup';

        // Determina o tipo do powerup baseado nas probabilidades
        const rand = Math.random();
        let svgContent = '';

        if (rand < 0.1) {
            powerup.type = 'health';
            svgContent = `
                <svg viewBox="0 0 50 50">
                    <circle cx="25" cy="25" r="20" fill="#2ecc71"/>
                    <rect x="15" y="22" width="20" height="6" fill="white"/>
                    <rect x="22" y="15" width="6" height="20" fill="white"/>
                    <circle cx="25" cy="25" r="12" fill="none" stroke="white" stroke-width="2"/>
                </svg>
            `;
        } else if (rand < 0.5) {
            powerup.type = 'shield';
            svgContent = `
                <svg viewBox="0 0 50 50">
                    <path d="M25 5 L45 15 L45 30 C45 40 35 45 25 45 C15 45 5 40 5 30 L5 15 Z"
                          fill="#3498db"/>
                    <path d="M25 10 L40 18 L40 30 C40 38 32 42 25 42 C18 42 10 38 10 30 L10 18 Z"
                          fill="#2980b9"/>
                </svg>
            `;
        } else if (rand < 0.7) {
            powerup.type = 'special';
            svgContent = `
                <svg viewBox="0 0 50 50">
                    <circle cx="25" cy="25" r="20" fill="#9b59b6"/>
                    <path d="M25 10 L30 20 L40 20 L32 28 L35 38 L25 32 L15 38 L18 28 L10 20 L20 20 Z"
                          fill="white"/>
                </svg>
            `;
        } else {
            powerup.type = 'homing';
            svgContent = `
                <svg viewBox="0 0 50 50">
                    <circle cx="25" cy="25" r="20" fill="#e67e22"/>
                    <path d="M25 5 L30 20 L45 25 L30 30 L25 45 L20 30 L5 25 L20 20 Z"
                          fill="white"/>
                </svg>
            `;
        }

        powerup.innerHTML = svgContent;
        powerup.style.left = (x - 400) + 'px';
        powerup.style.top = (y - 290) + 'px';
        powerup.speedY = 2;
        gameContainer.appendChild(powerup);
        powerups.push(powerup);
    }

    function updatePowerups() {
        for (let i = powerups.length - 1; i >= 0; i--) {
            const powerup = powerups[i];
            const y = parseFloat(powerup.style.top) + powerup.speedY;

            if (y > containerHeight) {
                if (powerup.parentNode === gameContainer) {
                    gameContainer.removeChild(powerup);
                }
                powerups.splice(i, 1);
            } else {
                powerup.style.top = y + 'px';
            }
        }
    }
    // Função para fazer os inimigos atirarem
    function enemiesFireBullets() {
            const now = Date.now();
            const fireInterval = 2000 - (currentPhase * 100);
            const allEnemies = enemies.concat(summonedEnemies);

            for (const enemy of allEnemies) {
                // Se for um inimigo atirador e o tempo de recarga já passou
                if (enemy.type === 2 && now - (enemy.lastFireTime || 0) > fireInterval) {
                    enemy.lastFireTime = now;
                    const enemyRect = enemy.getBoundingClientRect();
                    const startX = enemyRect.left + enemyRect.width / 2;
                    const startY = enemyRect.top + enemyRect.height;

                    const playerRect = player.getBoundingClientRect();
                    const playerCenterX = playerRect.left + playerRect.width / 2;

                    const angle = Math.atan2(playerRect.top - startY, playerCenterX - startX);
                    const speed = 3 + (currentPhase * 0.2);
                    const speedX = Math.cos(angle) * speed;
                    const speedY = Math.sin(angle) * speed;

                    const bullet = document.createElement('div');
                    bullet.className = 'enemy-bullet';
                    const containerRect = gameContainer.getBoundingClientRect();
                    const relativeX = startX - containerRect.left;
                    const relativeY = startY - containerRect.top;
                    bullet.style.left = relativeX + 'px';
                    bullet.style.top = relativeY + 'px';
                    bullet.speedX = speedX;
                    bullet.speedY = speedY;
                    gameContainer.appendChild(bullet);
                    enemyBullets.push(bullet);
                }
            }
        }
    function checkCollisions() {
        // 1. Colisões Bala do Jogador -> Inimigo/Chefe/Invocados
        for (let i = bullets.length - 1; i >= 0; i--) { // Iterar de trás para frente
            const bullet = bullets[i];
            if (!bullet || !bullet.parentNode) continue; // Verifica se a bala ainda existe no DOM
            const bulletRect = bullet.getBoundingClientRect();
            let hit = false; // Flag para esta bala específica

            // --- Checa Chefe ---
            if (isBossActive) {
                updateBoss();
                const bossRect = bossElement.getBoundingClientRect();
                if (
                    bulletRect.left < bossRect.right &&
                    bulletRect.right > bossRect.left &&
                    bulletRect.top < bossRect.bottom &&
                    bulletRect.bottom > bossRect.top // Simplificado, colide com toda a área do chefe
                ) {
                    bossTakeDamage(bullet.classList.contains('special-bullet') ? 3 : 1);
                    hit = true; // Marca que a bala atingiu algo
                    // Não use 'break' aqui, a bala será removida no final se 'hit' for true
                }
            }

            // --- Checa Inimigos Invocados (SEMPRE, mas só se não atingiu o chefe) ---
            if (!hit) { // Só verifica se não atingiu o chefe
                for (let j = summonedEnemies.length - 1; j >= 0; j--) {
                    const enemy = summonedEnemies[j];
                    if (!enemy || !enemy.parentNode) continue; // Verifica se o inimigo ainda existe
                    const enemyRect = enemy.getBoundingClientRect();
                    if (
                        bulletRect.left < enemyRect.right &&
                        bulletRect.right > enemyRect.left &&
                        bulletRect.top < enemyRect.bottom &&
                        bulletRect.bottom > enemyRect.top
                    ) {
                        // Destruir inimigo invocado
                        const enemyCenterX = enemyRect.left + (enemyRect.width / 2);
                        const enemyCenterY = enemyRect.top + (enemyRect.height / 2);
                        createExplosion(enemyCenterX, enemyCenterY);
                        createPowerup(enemyCenterX, enemyCenterY);
                        if (enemy.parentNode === gameContainer) gameContainer.removeChild(enemy);
                        summonedEnemies.splice(j, 1);
                        playSound(sfxPop);
                        hit = true; // Marca que a bala atingiu algo
                        break; // Sai do loop INTERNO (j) - bala atinge só UM inimigo invocado
                    }
                }
            }

            // --- Checa Inimigos Normais (SÓ se chefe NÃO ativo E não atingiu nada ainda) ---
            if (!isBossActive && !hit) { // Só verifica se chefe não está ativo E não atingiu invocado/chefe
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                     if (!enemy || !enemy.parentNode) continue; // Verifica se o inimigo ainda existe
                    const enemyRect = enemy.getBoundingClientRect();
                    if (
                        bulletRect.left < enemyRect.right &&
                        bulletRect.right > enemyRect.left &&
                        bulletRect.top < enemyRect.bottom &&
                        bulletRect.bottom > enemyRect.top
                    ) {
                        // Destruir inimigo normal, pontuar, etc.
                        enemy.classList.add('hit');
                        setTimeout(() => enemy.classList.remove('hit'), 100);
                        playSound(sfxPop);
                        const enemyCenterX = enemyRect.left + (enemyRect.width / 2);
                        const enemyCenterY = enemyRect.top + (enemyRect.height / 2);
                        createExplosion(enemyCenterX, enemyCenterY);
                        createPowerup(enemyCenterX, enemyCenterY);
                        if (enemy.parentNode === gameContainer) gameContainer.removeChild(enemy);
                        enemies.splice(j, 1);

                        score += 10 * currentPhase;
                        scoreElement.textContent = `Score: ${score}`;
                        phaseProgress++;
                        const goalIndex = currentPhase - 1;
                        if (goalIndex < phaseGoals.length && typeof phaseGoals[goalIndex] === 'number' && phaseGoals[goalIndex] > 1) {
                            if (phaseProgress >= phaseGoals[goalIndex]) {
                                advancePhase();
                            }
                        }
                        hit = true; // Marca que a bala atingiu algo
                        break; // Sai do loop INTERNO (j) - bala atinge só UM inimigo normal
                    }
                }
            }

            // --- Remove a bala SE atingiu QUALQUER alvo ---
            if (hit) {
                if (bullet.parentNode === gameContainer) {
                    try { // Adiciona try-catch para segurança
                         gameContainer.removeChild(bullet);
                    } catch(e) {
                        console.warn("Error removing bullet after hit:", e, bullet);
                    }
                }
                bullets.splice(i, 1); // Remove do array
                // Não precisa decrementar 'i' porque estamos iterando de trás para frente
            }
        } // Fim do loop das balas (i)

        // 2. Colisões Tiro Inimigo/Chefe -> Jogador
        if (!isPlayerInvulnerable && !isGameOver) {
            const playerRect = player.getBoundingClientRect();
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                 const bullet = enemyBullets[i];
                 if (!bullet || !bullet.parentNode) continue;
                 const bulletRect = bullet.getBoundingClientRect();

                 if (
                     playerRect.left < bulletRect.right &&
                     playerRect.right > bulletRect.left &&
                     playerRect.top < bulletRect.bottom &&
                     playerRect.bottom > bulletRect.top
                 ) {
                     playerTakeDamage(15);
                     if (bullet.parentNode === gameContainer) {
                        try { gameContainer.removeChild(bullet); } catch(e) {}
                     }
                     enemyBullets.splice(i, 1);
                     break;
                 }
            }
        }

        // 3. Colisões Jogador -> Inimigo/Invocado
        if (!isPlayerInvulnerable && !isGameOver) {
            const playerRect = player.getBoundingClientRect();
            const allKillableEnemies = enemies.concat(summonedEnemies);

            for (let i = allKillableEnemies.length - 1; i >= 0; i--) {
                const enemy = allKillableEnemies[i];
                if (!enemy || !enemy.parentNode) continue;
                const enemyRect = enemy.getBoundingClientRect();

                if (
                    playerRect.left < enemyRect.right &&
                    playerRect.right > enemyRect.left &&
                    playerRect.top < enemyRect.bottom &&
                    playerRect.bottom > enemyRect.top
                ) {
                    const enemyCenterX = enemyRect.left + (enemyRect.width / 2);
                    const enemyCenterY = enemyRect.top + (enemyRect.height / 2);
                    createExplosion(enemyCenterX, enemyCenterY);
                    if (enemy.parentNode === gameContainer) {
                        try { gameContainer.removeChild(enemy); } catch(e) {}
                    }

                    const indexInEnemies = enemies.indexOf(enemy);
                    if (indexInEnemies > -1) {
                        enemies.splice(indexInEnemies, 1);
                    } else {
                        const indexInSummoned = summonedEnemies.indexOf(enemy);
                        if (indexInSummoned > -1) {
                            summonedEnemies.splice(indexInSummoned, 1);
                        }
                    }

                    playerTakeDamage(25);
                    break;
                }
            }
        }

        // 4. Colisões Jogador -> Powerups
        const playerRect = player.getBoundingClientRect();
        for (let i = powerups.length - 1; i >= 0; i--) {
            const powerup = powerups[i];
            const powerupRect = powerup.getBoundingClientRect();

            if (
                playerRect.left < powerupRect.right &&
                playerRect.right > powerupRect.left &&
                playerRect.top < powerupRect.bottom &&
                playerRect.bottom > powerupRect.top
            ) {
                // Aplica o efeito do powerup
                switch (powerup.type) {
                    case 'health':
                        playerCurrentHP = Math.min(playerMaxHP, playerCurrentHP + 25);
                        updatePlayerHPBar();
                        break;
                    case 'shield':
                        hasShield += 1;
                        player.classList.add('shielded');
                        break;
                    case 'special':
                        specialCharges += 1;
                        specialChargesElement.textContent = `Tiro Especial: ${specialCharges}`;
                        break;
                    case 'homing':
                        activateHoming();
                        break;
                }

                // Remove o powerup
                if (powerup.parentNode === gameContainer) {
                    gameContainer.removeChild(powerup);
                }
                powerups.splice(i, 1);
                playSound(sfxPowerup);
            }
        }
    }

    function activateHoming() {
        isHomingActive = true;
        if (homingTimer) clearTimeout(homingTimer);

        homingTimer = setTimeout(() => {
            deactivateHoming();
        }, 6000);
    }

    function deactivateHoming() {
        isHomingActive = false;
        if (homingTimer) {
            clearTimeout(homingTimer);
            homingTimer = null;
        }
    }

    function gameOver() {
        if (isGameOver) return;
        isGameOver = true;
        finalScoreElement.textContent = `Score: ${score}`;
        saveHighScore();
        gameOverScreen.style.display = 'flex';
        if(gameLoopId) cancelAnimationFrame(gameLoopId);
        deactivateSpecial();
        player.style.display = 'none';

        playSound(sfxGameOver);
        stopMusic();
        playSound(bgmGameOver);

        isPlayerInvulnerable = false;
        player.classList.remove('invulnerable');
        if (playerInvulnerableTimer) clearTimeout(playerInvulnerableTimer);
        bossElement.style.display = 'none';
        bossHPContainer.style.display = 'none';
    }

    function resetGame() {
        stopMusic();
        loadHighScore();

        bullets.forEach(b => { if(b.parentNode === gameContainer) gameContainer.removeChild(b); });
        bullets = [];
        enemies.forEach(e => { if(e.parentNode === gameContainer) gameContainer.removeChild(e); });
        enemies = [];
        enemyBullets.forEach(eb => { if(eb.parentNode === gameContainer) gameContainer.removeChild(eb); });
        enemyBullets = [];

        summonedEnemies.forEach(e => { if(e.parentNode === gameContainer) gameContainer.removeChild(e); });
        summonedEnemies = [];

        playerX = containerWidth / 2 - playerWidth / 2;
        playerY = containerHeight - playerHeight - 20;
        playerCurrentHP = playerMaxHP;
        isPlayerInvulnerable = false;
        if (playerInvulnerableTimer) clearTimeout(playerInvulnerableTimer);
        score = 0;
        currentPhase = 1;
        phaseProgress = 0;
        isBossActive = false;
        bossData = {};
        specialCharges = 3;
        isGameOver = false;
        isSpecialActive = false;
        lastEnemySpawnTime = 0;

        scoreElement.textContent = `Score: ${score}`;
        updatePlayerHPBar();
        phaseDisplay.textContent = `Fase: ${currentPhase}`;
        specialChargesElement.textContent = `Tiro Especial: ${specialCharges}`;
        gameOverScreen.style.display = 'none';
        specialActiveElement.style.display = 'none';
        specialBarFill.style.width = '0%';
        player.style.display = 'block';
        player.classList.remove('invulnerable');
        bossElement.style.display = 'none';
        bossHPContainer.style.display = 'none';

        createStars();
        if (gameLoopId) cancelAnimationFrame(gameLoopId);
        gameLoopId = null;
        startGame();

        powerups.forEach(p => { if(p.parentNode === gameContainer) gameContainer.removeChild(p); });
        powerups = [];
        hasShield = 0;
        player.classList.remove('shielded');
    }

    function enableAutoFire() {
        setInterval(() => {
            if (!isGameOver) {
                fireBullet();
            }
        }, 300);
    }

    function gameLoop() {
        if (!isGameOver) {
            updatePlayer();
            if (isFirePressed) {
                fireBullet();
            }
            if (isSpecialPressed && !isSpecialActive && specialCharges > 0) {
                activateSpecial();
                isSpecialPressed = false;
            }
            updateBullets();
            updateEnemyBullets();
            enemiesFireBullets();
            createEnemy();
            updateEnemies();
            updateStars();
            checkCollisions();
            updatePowerups();
            gameLoopId = requestAnimationFrame(gameLoop);
        }
    }

    function setupControls() {
        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a') {
                isLeftPressed = true;
            }
            if (e.key === 'ArrowRight' || e.key === 'd') {
                isRightPressed = true;
            }
            if (e.key === 'ArrowUp' || e.key === 'w') {
                isFirePressed = true;
            }
            if (e.key === ' ' && !isSpecialPressed) {
                isSpecialPressed = true;
            }
        });

        window.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a') {
                isLeftPressed = false;
            }
            if (e.key === 'ArrowRight' || e.key === 'd') {
                isRightPressed = false;
            }
            if (e.key === 'ArrowUp' || e.key === 'w') {
                isFirePressed = false;
            }
            if (e.key === ' ') {
                isSpecialPressed = false;
            }
        });

        let touchStartX = 0;
        gameContainer.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const containerRect = gameContainer.getBoundingClientRect();
            touchStartX = touch.clientX - containerRect.left;

            const now = new Date().getTime();
            const timeSince = now - (touch.target.lastTouch || 0);

            if (timeSince < 300 && timeSince > 0) {
                isSpecialPressed = true;
            }

            touch.target.lastTouch = now;
            isFirePressed = true;
        });

        gameContainer.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const containerRect = gameContainer.getBoundingClientRect();
            const touchX = touch.clientX - containerRect.left;

            if (touchX < touchStartX - 20) {
                isLeftPressed = true;
                isRightPressed = false;
            } else if (touchX > touchStartX + 20) {
                isLeftPressed = false;
                isRightPressed = true;
            } else {
                isLeftPressed = false;
                isRightPressed = false;
            }

            playerX = touchX - playerWidth / 2;
            if (playerX < 0) playerX = 0;
            if (playerX > containerWidth - playerWidth) playerX = containerWidth - playerWidth;
        });

        gameContainer.addEventListener('touchend', () => {
            isFirePressed = false;
            isLeftPressed = false;
            isRightPressed = false;
        });

        restartButton.addEventListener('click', resetGame);
    }

    function startGame() {
        if (!window.controlsInitialized) {
            setupControls();
            enableAutoFire();
            window.controlsInitialized = true;
        }
        stopMusic();
        playSound(bgmGame);
        if (!gameLoopId) {
           gameLoopId = requestAnimationFrame(gameLoop);
        }
    }

    function updatePlayerHPBar() {
        const percentage = (playerCurrentHP / playerMaxHP) * 100;
        playerHPBarFill.style.width = `${Math.max(0, percentage)}%`;
    }

    function playerTakeDamage(damage) {
        console.log(`playerTakeDamage called. Damage: ${damage}, isPlayerInvulnerable: ${isPlayerInvulnerable}`);

        if (isPlayerInvulnerable || isGameOver) return;

        if (hasShield > 0) {
            hasShield--;
            if (hasShield <= 0) {
                hasShield = 0;
                player.classList.remove('shielded');
            } else {
                return;
            }
        }

        playerCurrentHP -= damage;
        updatePlayerHPBar();
        playSound(sfxPlayerDamage);
        triggerScreenShake();

        if (playerCurrentHP <= 0) {
            playerCurrentHP = 0;
            updatePlayerHPBar();
            const playerRect = player.getBoundingClientRect();
            createExplosion(playerRect.left + playerWidth / 2, playerRect.top + playerHeight / 2);
            player.style.display = 'none';
            gameOver();
        } else {
            isPlayerInvulnerable = true;
            player.classList.add('invulnerable');

            if (playerInvulnerableTimer) {
                clearTimeout(playerInvulnerableTimer);
            }

            playerInvulnerableTimer = setTimeout(() => {
                isPlayerInvulnerable = false;
                player.classList.remove('invulnerable');
                playerInvulnerableTimer = null;
            }, playerInvulnerableDuration);
        }
    }

    function triggerScreenShake() {
        gameContainer.classList.add('shake');
        setTimeout(() => {
            gameContainer.classList.remove('shake');
        }, 150);
    }

    function spawnBoss() {
        console.log("Spawning Boss for Phase", currentPhase);
        isBossActive = true;
        bossElement.style.display = 'block';
        bossHPContainer.style.display = 'block';

        bossData = {
            maxHP: 300 + (currentPhase * 100),
            currentHP: 0,
            x: containerWidth / 2 - 50,
            y: 30,
            targetY: 30,
            speedX: 1.5 + (currentPhase * 0.2),
            speedY: 0.5 + (currentPhase * 0.1),
            directionX: 1,
            directionY: 1,
            attackTimer: 0,
            attackInterval: 1400 - (currentPhase * 90),
            lastAttackTime: 0,
            summonInterval: 8000 - (currentPhase * 500),
            lastSummonTime: Date.now(),
            attackPattern: 0,
            lastPatternSwitchTime: Date.now()
        };
        bossData.currentHP = bossData.maxHP;
        bossElement.style.left = bossData.x + 'px';
        bossElement.style.top = bossData.y + 'px';
        updateBossHPBar();

        enemies.forEach(enemy => {
            if(enemy.parentNode === gameContainer) gameContainer.removeChild(enemy);
        });
        enemies = [];
        summonedEnemies.forEach(enemy => { if(enemy.parentNode === gameContainer) gameContainer.removeChild(enemy); });
        summonedEnemies = [];
    }

    function updateBossHPBar() {
        const percentage = (bossData.currentHP / bossData.maxHP) * 100;
        bossHPFill.style.width = `${Math.max(0, percentage)}%`;
    }

    function updateBoss() {
        if (!isBossActive) return;
        const now = Date.now();

        bossData.x += bossData.speedX * bossData.directionX;
        if (bossData.x <= 10 || bossData.x >= containerWidth - 110) {
            bossData.directionX *= -1;
            bossData.x = Math.max(10, Math.min(bossData.x, containerWidth - 110));
        }
        bossData.y += bossData.speedY * bossData.directionY;
        if (bossData.y <= 20 || bossData.y >= 60) {
            bossData.directionY *= -1;
            bossData.y = Math.max(20, Math.min(bossData.y, 60));
        }
        bossElement.style.left = bossData.x + 'px';
        bossElement.style.top = bossData.y + 'px';

        if (now - bossData.lastAttackTime > bossData.attackInterval) {
            bossData.lastAttackTime = now;
            const cannonLeftX = bossData.x + 25;
            const cannonRightX = bossData.x + 75;
            const cannonY = bossData.y + 90;

            bossData.attackPattern = (bossData.attackPattern + 1) % 3;

            if (bossData.attackPattern === 0) {
                bossFireBullet(cannonLeftX, cannonY, 0, 4 + currentPhase * 0.5);
                bossFireBullet(cannonRightX, cannonY, 0, 4 + currentPhase * 0.5);
            } else if (bossData.attackPattern === 1) {
                bossFireBullet(cannonLeftX, cannonY, -1, 3.5 + currentPhase * 0.5);
                bossFireBullet(bossData.x + 50, cannonY, 0, 4 + currentPhase * 0.5);
                bossFireBullet(cannonRightX, cannonY, 1, 3.5 + currentPhase * 0.5);
            } else {
                const targetCannonX = Math.random() < 0.5 ? cannonLeftX : cannonRightX;
                for(let i=0; i<3; i++){
                    setTimeout(() => {
                        if(isBossActive) bossFireBullet(targetCannonX, cannonY, 0, 5 + currentPhase * 0.5);
                    }, i * 100);
                }
            }
        }

        if (now - bossData.lastSummonTime > bossData.summonInterval
            && summonedEnemies.length < 4
        ) {
            bossData.lastSummonTime = now;
            console.log("Boss summoning enemies...");
            const summonY = bossData.y + 80;
            createEnemy(true, bossData.x, summonY);
            createEnemy(true, bossData.x + 70, summonY);
        }
    }

    function bossTakeDamage(damage) {
        if (!isBossActive) return;
        bossData.currentHP -= damage;
        updateBossHPBar();

        bossElement.style.filter = 'brightness(1.8)';
        setTimeout(() => { bossElement.style.filter = 'brightness(1)'; }, 100);

        if (bossData.currentHP <= 0) {
            playSound(sfxExplosion);
            defeatBoss();
        }
    }

    function defeatBoss() {
        console.log("Boss Defeated!");
        isBossActive = false;
        createExplosion(bossData.x + 50, bossData.y + 50);
        bossElement.style.display = 'none';
        bossHPContainer.style.display = 'none';

        summonedEnemies.forEach(enemy => { if(enemy.parentNode === gameContainer) gameContainer.removeChild(enemy); });
        summonedEnemies = [];

        score += 500 * currentPhase;
        scoreElement.textContent = `Score: ${score}`;
        if (specialCharges < 3) {
             specialCharges++;
             specialChargesElement.textContent = `Tiro Especial: ${specialCharges}`;
        }
         playerCurrentHP = Math.min(playerMaxHP, playerCurrentHP + 25);
         updatePlayerHPBar();

        advancePhase();
    }

    function advancePhase() {
        // Incrementa a fase atual e reinicia o progresso da fase
        currentPhase++;
        phaseProgress = 0;

        // Atualiza o texto que mostra a fase atual na interface
        phaseDisplay.textContent = `Fase: ${currentPhase}`;
        console.log(`Advanced to Phase ${currentPhase}`);

        // Calcula o índice correspondente no array phaseGoals
        // (phaseGoals contém os objetivos para cada fase)
        const goalIndex = currentPhase - 1;

        // Verifica se:
        // 1. O índice está dentro dos limites do array phaseGoals
        // 2. O valor no array é um número
        // 3. O valor é par (o que indica que é uma fase de chefe)
        if (goalIndex < phaseGoals.length
            && typeof phaseGoals[goalIndex] === 'number'
            && phaseGoals[goalIndex] === 1
        ) {
            // Se o valor for par, significa que esta fase tem um chefe
            spawnBoss();
            if (phaseProgress > 4) {
                spawnBoss();
            }
        } else if (goalIndex >= phaseGoals.length) {
            // Se o índice estiver fora dos limites do array,
            // significa que o jogador completou todas as fases definidas
            console.log("Todas as fases definidas completas!");
        }

        // Mostra uma notificação na tela informando o início da nova fase
        showPhaseNotification(`Fase ${currentPhase} Iniciada!`);
    }

    function showPhaseNotification(message) {
        let notification = document.getElementById('phase-notification');
        if (!notification) {
            notification = document.createElement('div');
            notification.id = 'phase-notification';
            notification.style.position = 'absolute';
            notification.style.top = '40%';
            notification.style.left = '50%';
            notification.style.transform = 'translate(-50%, -50%)';
            notification.style.padding = '15px 30px';
            notification.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            notification.style.color = '#0f0';
            notification.style.fontSize = '24px';
            notification.style.fontWeight = 'bold';
            notification.style.borderRadius = '10px';
            notification.style.zIndex = '20';
            notification.style.display = 'none';
            gameContainer.appendChild(notification);
        }
        notification.textContent = message;
        notification.style.display = 'block';
        setTimeout(() => {
            notification.style.display = 'none';
        }, 2000);
    }

    function loadHighScore() {
        const storedScore = localStorage.getItem('spaceShooterHighScore');
        highScore = storedScore ? parseInt(storedScore, 10) : 0;
        highScoreElement.textContent = `High Score: ${highScore}`;
    }

    function saveHighScore() {
        if (score > highScore) {
            highScore = score;
            localStorage.setItem('spaceShooterHighScore', highScore);
            highScoreElement.textContent = `High Score: ${highScore}`;
        }
    }

    function updateEnemyBullets() {
        for (let i = enemyBullets.length - 1; i >= 0; i--) {
            const bullet = enemyBullets[i];
            const x = parseFloat(bullet.style.left);
            const y = parseFloat(bullet.style.top) + bullet.speedY;

            if (y > containerHeight || y < -20 || x < -10 || x > containerWidth + 10) {
                if (bullet.parentNode === gameContainer) gameContainer.removeChild(bullet);
                enemyBullets.splice(i, 1);
            } else {
                bullet.style.top = y + 'px';
                bullet.style.left = x + (bullet.speedX || 0) + 'px';
            }
        }
    }

    function bossFireBullet(startX, startY, speedX, speedY) {
        const bullet = document.createElement('div');
        bullet.className = 'enemy-bullet';
        bullet.style.left = startX + 'px';
        bullet.style.top = startY + 'px';
        bullet.speedX = speedX;
        bullet.speedY = speedY;
        gameContainer.appendChild(bullet);
        enemyBullets.push(bullet);
    }

    window.controlsInitialized = false;
    loadHighScore();
    resetGame();
</script>
</body>
</html>