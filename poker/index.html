<!DOCTYPE html>
<html lang="pt-br">
<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KM6SHZXP');</script>
    <!-- End Google Tag Manager -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poker Texas Hold'em</title>
    <style>
        :root {
            --primary-color: #1a5e1a;
            --secondary-color: #0f360f;
            --text-color: #ddd;
            --accent-color: #d4af37;
            --card-bg: #fff;
            --card-red: #e44145;
            --card-black: #222;
            --button-primary: #2c7873;
            --button-hover: #1e5350;
            --button-secondary: #a23131;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--primary-color);
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        header {
            margin-bottom: 30px;
            text-align: center;
        }

        h1 {
            font-size: 36px;
            color: var(--accent-color);
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .game-modes {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
        }

        .mode-button {
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            background-color: var(--button-primary);
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .mode-button:hover {
            background-color: var(--button-hover);
        }

        .game-container {
            width: 100%;
            max-width: 1000px;
            background-color: var(--secondary-color);
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            position: relative;
        }

        .table {
            background-color: var(--primary-color);
            border-radius: 100px;
            border: 10px solid #143914;
            padding: 20px;
            margin-bottom: 20px;
            position: relative;
            min-height: 400px;
        }

        .community-cards {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
        }

        .player-area {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            flex-wrap: wrap;
            gap: 20px;
        }

        .player {
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            width: calc(33.33% - 20px);
            min-width: 200px;
            text-align: center;
            position: relative;
        }

        .player.current {
            box-shadow: 0 0 10px var(--accent-color);
        }

        .player.folded {
            opacity: 0.6;
        }

        .player-name {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .player-chips {
            margin-bottom: 10px;
            font-size: 14px;
            color: var(--accent-color);
        }

        .player-bet {
            margin-bottom: 10px;
            font-size: 14px;
        }

        .player-cards {
            display: flex;
            justify-content: center;
            gap: 5px;
            margin-bottom: 10px;
        }

        .card {
            width: 60px;
            height: 90px;
            background-color: var(--card-bg);
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            box-shadow: 1px 1px 4px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .card.red {
            color: var(--card-red);
        }

        .card.black {
            color: var(--card-black);
        }

        .card.facedown {
            background-color: #2b5797;
            background-image: linear-gradient(45deg, #2b5797 25%, #1c4677 25%, #1c4677 50%, #2b5797 50%, #2b5797 75%, #1c4677 75%, #1c4677 100%);
            background-size: 10px 10px;
        }

        .card-value {
            font-size: 20px;
            position: absolute;
            top: 5px;
            left: 5px;
        }

        .card-suit {
            font-size: 24px;
        }

        .community-cards .card {
            width: 70px;
            height: 100px;
        }

        .pot {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 18px;
            color: var(--accent-color);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .control-button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background-color: var(--button-primary);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .control-button:hover {
            background-color: var(--button-hover);
        }

        .control-button.fold {
            background-color: var(--button-secondary);
        }

        .control-button.fold:hover {
            background-color: #7e2424;
        }

        .control-button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        .bet-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .bet-amount {
            width: 100px;
            padding: 8px;
            border-radius: 5px;
            border: 2px solid var(--button-primary);
            text-align: center;
            font-size: 16px;
        }

        .game-message {
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            text-align: center;
            font-size: 18px;
            padding: 15px;
        }

        .game-message-container {
            min-height: 60px;
            margin: 15px 0;
        }

        .mode-select {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            border-radius: 10px;
        }

        .mode-select h2 {
            color: var(--accent-color);
            margin-bottom: 30px;
        }

        .online-options {
            display: none;
            margin-top: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 10px;
            width: 100%;
            max-width: 400px;
        }

        .online-options input,
        .online-options button {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            border: none;
        }

        .online-options button {
            background-color: var(--button-primary);
            color: white;
            cursor: pointer;
        }

        .hand-ranking {
            margin-top: 10px;
            font-style: italic;
            color: #aaa;
        }
        
        .hidden {
            display: none;
        }

        .mode-button.disabled {
            background-color: #555;
            cursor: not-allowed;
            position: relative;
        }
        
        .mode-button.disabled:hover::after {
            content: "Funcionalidade em construção";
            position: absolute;
            bottom: -40px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            white-space: nowrap;
            z-index: 100;
        }

        @keyframes winnerGlow {
            0% { box-shadow: 0 0 5px 2px rgba(212, 175, 55, 0.5); }
            50% { box-shadow: 0 0 20px 10px rgba(212, 175, 55, 0.8); }
            100% { box-shadow: 0 0 5px 2px rgba(212, 175, 55, 0.5); }
        }
        
        @keyframes chipsFly {
            0% { 
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            80% {
                opacity: 0.8;
            }
            100% { 
                transform: translate(var(--target-x), var(--target-y)) scale(0.5);
                opacity: 0;
            }
        }
        
        .winner-highlight {
            animation: winnerGlow 1.5s ease-in-out infinite;
            border: 2px solid #d4af37 !important;
        }
        
        .pot-chip {
            position: absolute;
            width: 30px;
            height: 30px;
            background-color: #d4af37;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #333;
            font-weight: bold;
            font-size: 12px;
            z-index: 100;
            animation: chipsFly 1.5s forwards;
        }
        
        .win-amount {
            position: absolute;
            color: #d4af37;
            font-weight: bold;
            font-size: 24px;
            text-shadow: 0 0 5px black;
            z-index: 101;
            opacity: 0;
            animation: fadeInOut 2s forwards;
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(0); }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translateY(-30px); }
        }

        .history-panel {
            position: absolute;
            right: 20px;
            top: 20px;
            width: 250px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-color);
            border-radius: 10px;
            padding: 15px;
            color: var(--text-color);
            max-height: 80vh;
            overflow-y: auto;
            transition: height 0.3s ease, padding 0.3s ease;
        }

        .history-title {
            color: var(--accent-color);
            font-size: 18px;
            margin-bottom: 10px;
            text-align: center;
            border-bottom: 1px solid var(--accent-color);
            padding-bottom: 5px;
            position: relative;
            cursor: pointer;
            user-select: none;
        }

        .history-toggle {
            position: absolute;
            right: 5px;
            top: 0;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .history-panel.minimized {
            height: 40px;
            padding-bottom: 5px;
            overflow: hidden;
        }

        .history-panel.minimized .history-toggle {
            transform: rotate(180deg);
        }

        .history-entry {
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .history-entry:last-child {
            border-bottom: none;
        }

        .history-round {
            font-weight: bold;
            color: var(--accent-color);
            margin-bottom: 5px;
        }

        .history-winner {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .history-winner-name {
            font-weight: bold;
            margin-right: 5px;
        }

        .history-amount {
            color: #d4af37;
            font-weight: bold;
        }

        .history-hand {
            font-style: italic;
            font-size: 0.9em;
            color: #aaa;
        }
    </style>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KM6SHZXP"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    
    <header>
        <h1>Poker Texas Hold'em</h1>
    </header>

    <div class="game-container">
        <div class="mode-select">
            <h2>Escolha o Modo de Jogo</h2>
            <div class="game-modes">
                <button id="single-player" class="mode-button">Single Player</button>
                <button id="multiplayer" class="mode-button disabled">Multiplayer</button>
            </div>
            <div class="online-options">
                <input type="text" id="player-name" placeholder="Seu nome">
                <input type="text" id="room-id" placeholder="ID da sala (para entrar)">
                <button id="create-room">Criar Sala</button>
                <button id="join-room">Entrar na Sala</button>
            </div>
        </div>

        <div class="table">
            <div class="community-cards">
                <!-- Cartas comunitárias serão adicionadas aqui -->
            </div>
            <div class="pot">Pot: $0</div>
        </div>

        <div class="player-area">
            <!-- Jogadores serão adicionados aqui -->
        </div>

        <div class="game-message-container">
            <div class="game-message"></div>
        </div>

        <div class="controls">
            <button class="control-button check-call">Check/Call</button>
            <button class="control-button bet-raise">Bet/Raise</button>
            <button class="control-button fold">Fold</button>
            <div class="bet-controls">
                <input type="number" class="bet-amount" min="1" value="10">
                <button class="control-button min-bet">Min</button>
                <button class="control-button max-bet">Max</button>
            </div>
        </div>

    </div>
    <div class="history-panel" id="history-panel">
        <div class="history-title" id="history-title">
            Histórico de Rodadas
            <span class="history-toggle" id="history-toggle">▼</span>
        </div>
        <div id="history-container"></div>
    </div>

    <script>
        // Constantes e configurações
        const SUITS = ['♥', '♦', '♠', '♣'];
        const VALUES = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const RED_SUITS = ['♥', '♦'];
        const HAND_RANKINGS = [
            'High Card', 'Pair', 'Two Pair', 'Three of a Kind', 'Straight',
            'Flush', 'Full House', 'Four of a Kind', 'Straight Flush', 'Royal Flush'
        ];
        
        // Estado do jogo
        let gameState = {
            deck: [],
            communityCards: [],
            players: [],
            currentPlayerIndex: 0,
            pot: 0,
            minBet: 10,
            currentBet: 0,
            phase: 'waiting', // waiting, preflop, flop, turn, river, showdown
            isPlayerTurn: false,
            gameMode: null, // singleplayer or multiplayer
            socket: null,
            roomId: null,
            history: [],
            round: 0
        };

        // Elementos do DOM
        const modeSelect = document.querySelector('.mode-select');
        const singlePlayerBtn = document.getElementById('single-player');
        const multiplayerBtn = document.getElementById('multiplayer');
        const onlineOptions = document.querySelector('.online-options');
        const createRoomBtn = document.getElementById('create-room');
        const joinRoomBtn = document.getElementById('join-room');
        const playerNameInput = document.getElementById('player-name');
        const roomIdInput = document.getElementById('room-id');
        const communityCardsEl = document.querySelector('.community-cards');
        const playerAreaEl = document.querySelector('.player-area');
        const potEl = document.querySelector('.pot');
        const gameMessageEl = document.querySelector('.game-message');
        const checkCallBtn = document.querySelector('.check-call');
        const betRaiseBtn = document.querySelector('.bet-raise');
        const foldBtn = document.querySelector('.fold');
        const betAmountInput = document.querySelector('.bet-amount');
        const minBetBtn = document.querySelector('.min-bet');
        const maxBetBtn = document.querySelector('.max-bet');

        // Funções para o baralho
        function createDeck() {
            const deck = [];
            for (const suit of SUITS) {
                for (const value of VALUES) {
                    deck.push({ suit, value });
                }
            }
            return deck;
        }

        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        function dealCards() {
            gameState.deck = shuffleDeck(createDeck());
            gameState.communityCards = [];
            
            // Distribuir 2 cartas para cada jogador
            for (const player of gameState.players) {
                player.cards = [gameState.deck.pop(), gameState.deck.pop()];
                player.folded = false;
                player.bet = 0;
                player.handRanking = '';
            }
            
            updateUI();
        }

        // Funções para classificar mãos de poker
        function getCardValue(card) {
            return VALUES.indexOf(card.value);
        }

        function evaluateHand(cards) {
            const allCards = [...cards];
            
            // Ordenar as cartas pelo valor (do menor para o maior)
            allCards.sort((a, b) => getCardValue(a) - getCardValue(b));
            
            // Verificar cada tipo de mão possível
            if (isRoyalFlush(allCards)) return { rank: 9, name: 'Royal Flush' };
            if (isStraightFlush(allCards)) return { rank: 8, name: 'Straight Flush' };
            if (isFourOfAKind(allCards)) return { rank: 7, name: 'Four of a Kind' };
            if (isFullHouse(allCards)) return { rank: 6, name: 'Full House' };
            if (isFlush(allCards)) return { rank: 5, name: 'Flush' };
            if (isStraight(allCards)) return { rank: 4, name: 'Straight' };
            if (isThreeOfAKind(allCards)) return { rank: 3, name: 'Three of a Kind' };
            if (isTwoPair(allCards)) return { rank: 2, name: 'Two Pair' };
            if (isPair(allCards)) return { rank: 1, name: 'Pair' };
            
            return { rank: 0, name: 'High Card' };
        }

        // Funções simplificadas para verificar os tipos de mãos
        function isRoyalFlush(cards) {
            return isStraightFlush(cards) && cards.some(card => card.value === 'A') && 
                   cards.some(card => card.value === 'K');
        }

        function isStraightFlush(cards) {
            return isFlush(cards) && isStraight(cards);
        }

        function isFourOfAKind(cards) {
            const valueCounts = countValues(cards);
            return Object.values(valueCounts).some(count => count >= 4);
        }

        function isFullHouse(cards) {
            const valueCounts = countValues(cards);
            const counts = Object.values(valueCounts);
            return counts.includes(3) && counts.includes(2);
        }

        function isFlush(cards) {
            const suits = cards.map(card => card.suit);
            return SUITS.some(suit => suits.filter(s => s === suit).length >= 5);
        }

        function isStraight(cards) {
            const values = cards.map(card => getCardValue(card));
            const uniqueValues = [...new Set(values)].sort((a, b) => a - b);
            
            // Verificar sequência normal
            let sequence = 1;
            for (let i = 1; i < uniqueValues.length; i++) {
                if (uniqueValues[i] === uniqueValues[i-1] + 1) {
                    sequence++;
                    if (sequence >= 5) return true;
                } else if (uniqueValues[i] !== uniqueValues[i-1]) {
                    sequence = 1;
                }
            }
            
            // Verificar sequência A-5
            if (uniqueValues.includes(0) && uniqueValues.includes(VALUES.length - 1)) {
                let lowSequence = 1;
                const lowValues = uniqueValues.filter(v => v < 5 || v === VALUES.length - 1);
                lowValues.sort((a, b) => {
                    if (a === VALUES.length - 1) return -1;
                    if (b === VALUES.length - 1) return 1;
                    return a - b;
                });
                
                for (let i = 1; i < lowValues.length; i++) {
                    if (
                        (lowValues[i-1] === VALUES.length - 1 && lowValues[i] === 0) ||
                        (lowValues[i] === lowValues[i-1] + 1)
                    ) {
                        lowSequence++;
                        if (lowSequence >= 5) return true;
                    } else {
                        lowSequence = 1;
                    }
                }
            }
            
            return false;
        }

        function isThreeOfAKind(cards) {
            const valueCounts = countValues(cards);
            return Object.values(valueCounts).some(count => count >= 3);
        }

        function isTwoPair(cards) {
            const valueCounts = countValues(cards);
            const pairs = Object.values(valueCounts).filter(count => count >= 2);
            return pairs.length >= 2;
        }

        function isPair(cards) {
            const valueCounts = countValues(cards);
            return Object.values(valueCounts).some(count => count >= 2);
        }

        function countValues(cards) {
            const valueCounts = {};
            for (const card of cards) {
                valueCounts[card.value] = (valueCounts[card.value] || 0) + 1;
            }
            return valueCounts;
        }

        // Funções de UI
        function updateUI() {
            updateCommunityCards();
            updatePlayers();
            updatePot();
            updateControls();
        }

        function updateCommunityCards() {
            communityCardsEl.innerHTML = '';
            
            if (gameState.phase === 'waiting' || gameState.phase === 'preflop') {
                // No flop phase, placeholders for cards
                for (let i = 0; i < 5; i++) {
                    const cardEl = document.createElement('div');
                    cardEl.className = 'card facedown';
                    communityCardsEl.appendChild(cardEl);
                }
            } else {
                // Show the community cards
                let visibleCards = 0;
                if (gameState.phase === 'flop') visibleCards = 3;
                else if (gameState.phase === 'turn') visibleCards = 4;
                else visibleCards = 5; // river or showdown
                
                for (let i = 0; i < visibleCards; i++) {
                    if (i < gameState.communityCards.length) {
                        const card = gameState.communityCards[i];
                        const cardEl = createCardElement(card);
                        communityCardsEl.appendChild(cardEl);
                    }
                }
                
                // Add face down placeholders for remaining cards
                for (let i = visibleCards; i < 5; i++) {
                    const cardEl = document.createElement('div');
                    cardEl.className = 'card facedown';
                    communityCardsEl.appendChild(cardEl);
                }
            }
        }

        function updatePlayers() {
            playerAreaEl.innerHTML = '';
            
            gameState.players.forEach((player, index) => {
                const playerEl = document.createElement('div');
                playerEl.className = `player ${index === gameState.currentPlayerIndex ? 'current' : ''} ${player.folded ? 'folded' : ''}`;
                
                const nameEl = document.createElement('div');
                nameEl.className = 'player-name';
                nameEl.textContent = player.name + (player.isAI ? ' (AI)' : '');
                
                const chipsEl = document.createElement('div');
                chipsEl.className = 'player-chips';
                chipsEl.textContent = `Fichas: $${player.chips}`;
                
                const betEl = document.createElement('div');
                betEl.className = 'player-bet';
                betEl.textContent = `Aposta: $${player.bet}`;
                
                const cardsEl = document.createElement('div');
                cardsEl.className = 'player-cards';
                
                // Mostrar as cartas do jogador
                if (player.cards) {
                    player.cards.forEach(card => {
                        // Show cards for human player or during showdown for all players
                        if (!player.isAI || gameState.phase === 'showdown' || player.isHuman) {
                            const cardEl = createCardElement(card);
                            cardsEl.appendChild(cardEl);
                        } else {
                            // Face down cards for AI
                            const cardEl = document.createElement('div');
                            cardEl.className = 'card facedown';
                            cardsEl.appendChild(cardEl);
                        }
                    });
                }
                
                // Add hand ranking during showdown
                if (gameState.phase === 'showdown' && player.handRanking) {
                    const rankingEl = document.createElement('div');
                    rankingEl.className = 'hand-ranking';
                    rankingEl.textContent = player.handRanking;
                    playerEl.appendChild(rankingEl);
                }
                
                playerEl.appendChild(nameEl);
                playerEl.appendChild(chipsEl);
                playerEl.appendChild(betEl);
                playerEl.appendChild(cardsEl);
                
                playerAreaEl.appendChild(playerEl);
            });
        }

        function createCardElement(card) {
            const cardEl = document.createElement('div');
            cardEl.className = `card ${RED_SUITS.includes(card.suit) ? 'red' : 'black'}`;
            
            const valueEl = document.createElement('div');
            valueEl.className = 'card-value';
            valueEl.textContent = card.value;
            
            const suitEl = document.createElement('div');
            suitEl.className = 'card-suit';
            suitEl.textContent = card.suit;
            
            cardEl.appendChild(valueEl);
            cardEl.appendChild(suitEl);
            
            return cardEl;
        }

        function updatePot() {
            potEl.textContent = `Pot: $${gameState.pot}`;
        }

        function updateControls() {
            const isActivePlayer = gameState.currentPlayerIndex === 0 && !gameState.players[0].folded;
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            
            checkCallBtn.disabled = !isActivePlayer || gameState.phase === 'waiting' || gameState.phase === 'showdown';
            betRaiseBtn.disabled = !isActivePlayer || gameState.phase === 'waiting' || gameState.phase === 'showdown';
            foldBtn.disabled = !isActivePlayer || gameState.phase === 'waiting' || gameState.phase === 'showdown';
            
            // Atualizar o texto do botão Check/Call
            if (gameState.currentBet === 0 || currentPlayer.bet === gameState.currentBet) {
                checkCallBtn.textContent = 'Check';
            } else {
                const callAmount = gameState.currentBet - currentPlayer.bet;
                checkCallBtn.textContent = `Call $${callAmount}`;
            }
            
            // Atualizar o texto do botão Bet/Raise
            if (gameState.currentBet === 0) {
                betRaiseBtn.textContent = 'Bet';
            } else {
                betRaiseBtn.textContent = 'Raise';
            }
            
            // Definir aposta mínima e máxima
            const minRaise = gameState.currentBet + gameState.minBet;
            betAmountInput.min = minRaise;
            betAmountInput.max = currentPlayer ? currentPlayer.chips : 1000;
            betAmountInput.value = minRaise;
        }

        function showGameMessage(message, duration = 0) {
            gameMessageEl.textContent = message;
            gameMessageEl.classList.remove('hidden');
            
            if (duration > 0) {
                setTimeout(() => {
                    gameMessageEl.classList.add('hidden');
                }, duration);
            }
        }

        // Lógica do jogo
        function startSinglePlayerGame() {
            modeSelect.style.display = 'none';
            gameState.gameMode = 'singleplayer';
            
            // Criar jogador humano e AI
            const playerName = playerNameInput.value.trim() || 'Jogador';
            gameState.players = [
                { name: playerName, chips: 1000, bet: 0, cards: [], folded: false, isHuman: true },
                { name: 'AI 1', chips: 1000, bet: 0, cards: [], folded: false, isAI: true },
                { name: 'AI 2', chips: 1000, bet: 0, cards: [], folded: false, isAI: true },
            ];
            
            startNewHand();
        }

        function setupMultiplayerGame() {
            gameState.gameMode = 'multiplayer';
            onlineOptions.style.display = 'block';
        }

        function createRoom() {
            const playerName = playerNameInput.value.trim();
            if (!playerName) {
                alert('Por favor, digite seu nome');
                return;
            }
            
            // Simulação de criação de sala (em um app real, isso seria feito com WebSockets)
            const roomId = Math.random().toString(36).substring(2, 10);
            modeSelect.style.display = 'none';
            
            // Criar jogador humano
            gameState.players = [
                { name: playerName, chips: 1000, bet: 0, cards: [], folded: false, isHuman: true }
            ];
            
            showGameMessage(`Sala criada! ID: ${roomId} - Aguardando outros jogadores...`);
            
            // Simulação de um jogador se juntando (em um app real, isso seria notificado pelo servidor)
            setTimeout(() => {
                gameState.players.push(
                    { name: 'Jogador Online', chips: 1000, bet: 0, cards: [], folded: false }
                );
                showGameMessage('Jogador entrou na sala!', 2000);
                
                // Iniciar o jogo após alguns segundos
                setTimeout(() => {
                    startNewHand();
                }, 2000);
            }, 3000);
        }

        function joinRoom() {
            const playerName = playerNameInput.value.trim();
            const roomId = roomIdInput.value.trim();
            
            if (!playerName || !roomId) {
                alert('Por favor, digite seu nome e o ID da sala');
                return;
            }
            
            // Simulação de entrada em uma sala (em um app real, isso seria feito com WebSockets)
            modeSelect.style.display = 'none';
            
            // Criar jogador humano e outro já "existente" na sala
            gameState.players = [
                { name: playerName, chips: 1000, bet: 0, cards: [], folded: false, isHuman: true },
                { name: 'Dono da Sala', chips: 1000, bet: 0, cards: [], folded: false }
            ];
            
            showGameMessage('Entrando na sala...', 2000);
            
            // Iniciar o jogo após alguns segundos
            setTimeout(() => {
                startNewHand();
            }, 2000);
        }

        function startNewHand() {
            // Incrementar o contador de rodadas
            gameState.round = (gameState.round || 0) + 1;
            
            gameState.phase = 'preflop';
            gameState.pot = 0;
            gameState.currentBet = gameState.minBet * 2; // Big blind
            
            // Collect blinds
            const smallBlindIdx = 0;
            const bigBlindIdx = 1 % gameState.players.length;
            
            gameState.players[smallBlindIdx].chips -= gameState.minBet;
            gameState.players[smallBlindIdx].bet = gameState.minBet;
            
            gameState.players[bigBlindIdx].chips -= gameState.minBet * 2;
            gameState.players[bigBlindIdx].bet = gameState.minBet * 2;
            
            gameState.pot = gameState.minBet * 3;
            
            // Dealer is after big blind
            gameState.currentPlayerIndex = (bigBlindIdx + 1) % gameState.players.length;
            
            // Deal cards
            dealCards();
            
            showGameMessage('Nova mão iniciada!', 3000);
            
            if (gameState.players[gameState.currentPlayerIndex].isAI) {
                setTimeout(playAITurn, 1500);
            }
        }

        function nextPhase() {
            switch (gameState.phase) {
                case 'preflop':
                    gameState.phase = 'flop';
                    // Deal the flop - 3 community cards
                    gameState.communityCards = [
                        gameState.deck.pop(),
                        gameState.deck.pop(),
                        gameState.deck.pop()
                    ];
                    showGameMessage('Flop!', 2000);
                    break;
                case 'flop':
                    gameState.phase = 'turn';
                    // Deal the turn - 1 more community card
                    gameState.communityCards.push(gameState.deck.pop());
                    showGameMessage('Turn!', 2000);
                    break;
                case 'turn':
                    gameState.phase = 'river';
                    // Deal the river - final community card
                    gameState.communityCards.push(gameState.deck.pop());
                    showGameMessage('River!', 2000);
                    break;
                case 'river':
                    gameState.phase = 'showdown';
                    handleShowdown();
                    return;
            }
            
            // Reset for new betting round
            gameState.currentBet = 0;
            gameState.players.forEach(player => {
                player.bet = 0;
            });
            
            // Start with first active player
            gameState.currentPlayerIndex = 0;
            while (
                gameState.currentPlayerIndex < gameState.players.length && 
                gameState.players[gameState.currentPlayerIndex].folded
            ) {
                gameState.currentPlayerIndex++;
            }
            
            if (gameState.currentPlayerIndex >= gameState.players.length) {
                gameState.currentPlayerIndex = 0;
            }
            
            updateUI();
            
            if (gameState.players[gameState.currentPlayerIndex].isAI) {
                setTimeout(playAITurn, 1500);
            }
        }

        function handleShowdown() {
            // Revelar todas as cartas
            gameState.players.forEach(player => {
                if (!player.isAI) {
                    player.showCards = true;
                }
            });
            
            // Determinar o vencedor e distribuir o pot
            const winner = determineWinner();
            
            // Atualizar a UI
            updateUI();
            
            // Iniciar nova mão após um atraso
            setTimeout(() => {
                startNewHand();
            }, 3000);
        }

        function determineWinner() {
            // Filtrar apenas jogadores que não desistiram
            const activePlayers = gameState.players.filter(player => !player.folded);
            
            // Se apenas um jogador restou (todos os outros desistiram), ele é o vencedor
            if (activePlayers.length === 1) {
                const winner = activePlayers[0];
                const winAmount = gameState.pot;
                winner.chips += winAmount;
                
                // Animar a vitória
                animateWinner(winner, winAmount);
                
                // Adicionar ao histórico - sem informação da mão
                addToHistory({
                    winners: [winner],
                    amount: winAmount,
                    hand: "todos desistiram", // Indicação clara de que venceu por desistência
                    type: 'fold'
                });
                
                showGameMessage(`${winner.name} vence $${winAmount} (todos os outros jogadores desistiram)!`);
                gameState.pot = 0;
                
                // Iniciar nova mão após um atraso
                setTimeout(() => {
                    startNewHand();
                }, 3000);
                
                return winner;
            }
            
            // Avaliar as mãos de todos os jogadores ativos
            activePlayers.forEach(player => {
                const cards = [...player.cards, ...gameState.communityCards];
                const handResult = evaluateHand(cards);
                player.handRanking = handResult.name;
                player.handRank = handResult.rank;
            });
            
            // Ordenar jogadores pelo ranking da mão (do maior para o menor)
            activePlayers.sort((a, b) => b.handRank - a.handRank);
            
            // O jogador com o maior ranking é o vencedor
            const winner = activePlayers[0];
            
            // Verificar se há empate
            const tiedPlayers = activePlayers.filter(player => player.handRank === winner.handRank);
            
            if (tiedPlayers.length > 1) {
                // Lógica de desempate (simplificada)
                // Em caso de empate, dividir o pot igualmente
                const splitAmount = Math.floor(gameState.pot / tiedPlayers.length);
                
                // Animar múltiplos vencedores
                tiedPlayers.forEach(player => {
                    player.chips += splitAmount;
                    animateWinner(player, splitAmount);
                });
                
                // Adicionar ao histórico
                addToHistory({
                    winners: tiedPlayers,
                    amount: gameState.pot,
                    hand: tiedPlayers[0].handRanking,
                    type: 'showdown'
                });
                
                showGameMessage(`Tie! Pot split between ${tiedPlayers.map(p => p.name).join(', ')}!`);
            } else {
                // Sem empate, o vencedor leva tudo
                const winAmount = gameState.pot;
                winner.chips += winAmount;
                
                // Animar o vencedor
                animateWinner(winner, winAmount);
                
                // Adicionar ao histórico
                addToHistory({
                    winners: [winner],
                    amount: winAmount,
                    hand: winner.handRanking,
                    type: 'showdown'
                });
                
                showGameMessage(`${winner.name} wins $${winAmount} with ${winner.handRanking}!`);
            }
            
            // Importante: zerar o pot após distribuir os ganhos
            gameState.pot = 0;
            
            return winner;
        }

        // Função para animar o vencedor e o movimento de fichas
        function animateWinner(player, amount) {
            // Encontrar o elemento do jogador
            const playerIndex = gameState.players.indexOf(player);
            const playerElement = document.querySelector(`.player:nth-child(${playerIndex + 1})`);
            
            if (!playerElement) return;
            
            // Destacar o jogador vencedor
            playerElement.classList.add('winner-highlight');
            
            // Encontrar a posição do pot e do jogador para animar as fichas
            const tableElement = document.querySelector('.table');
            const potPosition = {
                x: tableElement.offsetWidth / 2,
                y: tableElement.offsetHeight / 2
            };
            
            const playerPosition = {
                x: playerElement.offsetLeft + playerElement.offsetWidth / 2,
                y: playerElement.offsetTop + playerElement.offsetHeight / 2
            };
            
            // Criar animação de fichas voando do pot para o jogador
            const chipCount = Math.min(10, Math.max(3, Math.floor(amount / 100)));
            
            for (let i = 0; i < chipCount; i++) {
                setTimeout(() => {
                    const chip = document.createElement('div');
                    chip.className = 'pot-chip';
                    chip.textContent = '$';
                    chip.style.left = `${potPosition.x}px`;
                    chip.style.top = `${potPosition.y}px`;
                    
                    // Calcular a direção para o jogador
                    const targetX = playerPosition.x - potPosition.x;
                    const targetY = playerPosition.y - potPosition.y;
                    
                    chip.style.setProperty('--target-x', `${targetX}px`);
                    chip.style.setProperty('--target-y', `${targetY}px`);
                    
                    tableElement.appendChild(chip);
                    
                    // Remover o chip após a animação
                    setTimeout(() => {
                        chip.remove();
                    }, 1500);
                }, i * 100);
            }
            
            // Mostrar o valor ganho
            const winAmount = document.createElement('div');
            winAmount.className = 'win-amount';
            winAmount.textContent = `+$${amount}`;
            winAmount.style.left = `${playerPosition.x - 40}px`;
            winAmount.style.top = `${playerPosition.y - 30}px`;
            
            tableElement.appendChild(winAmount);
            
            // Remover o destaque e o valor após um tempo
            setTimeout(() => {
                playerElement.classList.remove('winner-highlight');
                winAmount.remove();
            }, 3000);
        }

        // Ações do jogador
        function handleCheckCall() {
            const player = gameState.players[gameState.currentPlayerIndex];
            
            if (gameState.currentBet > player.bet) {
                // Call
                const callAmount = gameState.currentBet - player.bet;
                player.chips -= callAmount;
                player.bet = gameState.currentBet;
                gameState.pot += callAmount;
                showGameMessage(`${player.name} calls $${callAmount}`, 2000);
            } else {
                // Check
                showGameMessage(`${player.name} checks`, 2000);
            }
            
            nextPlayerTurn();
        }

        function handleBetRaise() {
            const player = gameState.players[gameState.currentPlayerIndex];
            const betAmount = parseInt(betAmountInput.value);
            
            if (isNaN(betAmount) || betAmount < gameState.currentBet + gameState.minBet || betAmount > player.chips) {
                alert('Aposta inválida!');
                return;
            }
            
            // Remove previous bet from chips
            player.chips -= (betAmount - player.bet);
            
            // Add to pot
            gameState.pot += (betAmount - player.bet);
            
            // Update current bet
            gameState.currentBet = betAmount;
            player.bet = betAmount;
            
            if (gameState.currentBet === 0) {
                showGameMessage(`${player.name} bets $${betAmount}`, 2000);
            } else {
                showGameMessage(`${player.name} raises to $${betAmount}`, 2000);
            }
            
            nextPlayerTurn();
        }

        function handleFold() {
            const player = gameState.players[gameState.currentPlayerIndex];
            player.folded = true;
            showGameMessage(`${player.name} folds`, 2000);
            
            // Check if only one player left
            const activePlayers = gameState.players.filter(p => !p.folded);
            if (activePlayers.length === 1) {
                // Award pot to last player
                activePlayers[0].chips += gameState.pot;
                showGameMessage(`${activePlayers[0].name} wins $${gameState.pot}!`);
                
                // Start new hand after delay
                setTimeout(() => {
                    startNewHand();
                }, 3000);
                return;
            }
            
            nextPlayerTurn();
        }

        function nextPlayerTurn() {
            // Check if betting round is complete
            let allPlayersBetEqual = true;
            const activePlayers = gameState.players.filter(p => !p.folded);
            
            for (const player of activePlayers) {
                if (player.bet !== gameState.currentBet) {
                    allPlayersBetEqual = false;
                    break;
                }
            }
            
            if (allPlayersBetEqual) {
                // Move to next phase
                nextPhase();
                return;
            }
            
            // Move to next player
            do {
                gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
            } while (gameState.players[gameState.currentPlayerIndex].folded);
            
            updateUI();
            if (gameState.players[gameState.currentPlayerIndex].isAI) {
                setTimeout(playAITurn, 1500);
            }
        }

        // AI logic
        function playAITurn() {
            if (gameState.phase === 'waiting' || gameState.phase === 'showdown') return;
            
            const aiPlayer = gameState.players[gameState.currentPlayerIndex];
            if (!aiPlayer.isAI || aiPlayer.folded) return;
            
            // Simulação de estratégia simples da IA
            // A IA avalia suas cartas e faz uma decisão baseada na força da mão
            const aiCards = [...aiPlayer.cards, ...gameState.communityCards.filter(card => card)];
            const handResult = evaluateHand(aiCards);
            
            // Comportamento baseado na fase do jogo e força da mão
            const callAmount = gameState.currentBet - aiPlayer.bet;
            const aiChips = aiPlayer.chips;
            
            // Calcular probabilidade de ação com base na força da mão
            let foldProb = 0.1;
            let raiseProb = 0.2;
            
            // Ajusta probabilidades com base na força da mão
            if (handResult.rank >= 5) { // Flush ou melhor
                foldProb = 0;
                raiseProb = 0.7;
            } else if (handResult.rank >= 3) { // Three of a kind ou melhor
                foldProb = 0.05;
                raiseProb = 0.5;
            } else if (handResult.rank >= 1) { // Par ou melhor
                foldProb = 0.1;
                raiseProb = 0.3;
            } else {
                foldProb = 0.3;
                raiseProb = 0.1;
            }
            
            // Ajusta probabilidades com base no tamanho da aposta
            const betRatio = callAmount / aiChips;
            if (betRatio > 0.3) {
                foldProb += 0.2;
                raiseProb -= 0.1;
            }
            
            // Tomar decisão
            const rand = Math.random();
            
            if (rand < foldProb && callAmount > 0) {
                // Fold
                handleAIAction('fold');
            } else if (rand < foldProb + raiseProb && aiChips > callAmount + gameState.minBet) {
                // Raise
                const minRaise = gameState.currentBet + gameState.minBet;
                const maxRaise = Math.min(aiChips, gameState.currentBet + aiChips / 3);
                let raiseAmount = Math.floor(Math.random() * (maxRaise - minRaise + 1)) + minRaise;
                
                if (handResult.rank >= 7) { // Four of a kind ou melhor - possível all-in
                    raiseAmount = aiChips;
                }
                
                handleAIAction('raise', raiseAmount);
            } else {
                // Check or call
                handleAIAction('call');
            }
        }

        function handleAIAction(action, amount = 0) {
            const aiPlayer = gameState.players[gameState.currentPlayerIndex];
            
            switch (action) {
                case 'fold':
                    aiPlayer.folded = true;
                    showGameMessage(`${aiPlayer.name} folds`, 2000);
                    break;
                case 'call':
                    if (gameState.currentBet > aiPlayer.bet) {
                        const callAmount = gameState.currentBet - aiPlayer.bet;
                        aiPlayer.chips -= callAmount;
                        aiPlayer.bet = gameState.currentBet;
                        gameState.pot += callAmount;
                        showGameMessage(`${aiPlayer.name} calls $${callAmount}`, 2000);
                    } else {
                        showGameMessage(`${aiPlayer.name} checks`, 2000);
                    }
                    break;
                case 'raise':
                    const raiseAmount = amount;
                    aiPlayer.chips -= (raiseAmount - aiPlayer.bet);
                    gameState.pot += (raiseAmount - aiPlayer.bet);
                    gameState.currentBet = raiseAmount;
                    aiPlayer.bet = raiseAmount;
                    
                    if (aiPlayer.chips === 0) {
                        showGameMessage(`${aiPlayer.name} goes all-in $${raiseAmount}!`, 2000);
                    } else if (gameState.currentBet === raiseAmount) {
                        showGameMessage(`${aiPlayer.name} bets $${raiseAmount}`, 2000);
                    } else {
                        showGameMessage(`${aiPlayer.name} raises to $${raiseAmount}`, 2000);
                    }
                    break;
            }
            
            // Check if only one player left
            const activePlayers = gameState.players.filter(p => !p.folded);
            if (activePlayers.length === 1) {
                // Award pot to last player
                activePlayers[0].chips += gameState.pot;
                showGameMessage(`${activePlayers[0].name} wins $${gameState.pot}!`);
                
                // Start new hand after delay
                setTimeout(() => {
                    startNewHand();
                }, 3000);
                updateUI();
                return;
            }
            
            nextPlayerTurn();
        }

        // Handlers para os botões de aposta
        function handleMinBet() {
            const minRaise = gameState.currentBet + gameState.minBet;
            betAmountInput.value = minRaise;
        }

        function handleMaxBet() {
            const player = gameState.players[gameState.currentPlayerIndex];
            betAmountInput.value = player.chips;
        }

        // Event listeners
        singlePlayerBtn.addEventListener('click', startSinglePlayerGame);
        multiplayerBtn.addEventListener('click', function(e) {
            // Não fazer nada, já que o botão está desabilitado
            e.preventDefault();
            showGameMessage('Modo multiplayer em construção. Por favor, use o modo single player.', 3000);
        });
        createRoomBtn.addEventListener('click', createRoom);
        joinRoomBtn.addEventListener('click', joinRoom);
        
        checkCallBtn.addEventListener('click', handleCheckCall);
        betRaiseBtn.addEventListener('click', handleBetRaise);
        foldBtn.addEventListener('click', handleFold);
        minBetBtn.addEventListener('click', handleMinBet);
        maxBetBtn.addEventListener('click', handleMaxBet);

        // WebSocket Mock (em uma implementação real, isso seria conectado a um servidor)
        class WebSocketMock {
            constructor(url) {
                this.url = url;
                this.callbacks = {};
                
                // Simular conexão bem-sucedida
                setTimeout(() => {
                    if (this.callbacks.open) {
                        this.callbacks.open();
                    }
                }, 500);
            }
            
            send(data) {
                console.log('Enviando dados:', data);
                
                // Simular resposta do servidor
                setTimeout(() => {
                    if (this.callbacks.message) {
                        this.callbacks.message({
                            data: JSON.stringify({
                                type: 'acknowledgment',
                                message: 'Dados recebidos pelo servidor'
                            })
                        });
                    }
                }, 300);
            }
            
            addEventListener(event, callback) {
                this.callbacks[event] = callback;
            }
            
            close() {
                if (this.callbacks.close) {
                    this.callbacks.close();
                }
            }
        }

        // Implementação do modo multiplayer (simulada)
        function connectToServer() {
            const ws = new WebSocketMock('wss://mock-poker-server.com');
            
            ws.addEventListener('open', () => {
                console.log('Conectado ao servidor');
                showGameMessage('Conectado ao servidor', 2000);
                
                // Enviar informações do jogador
                ws.send(JSON.stringify({
                    type: 'join',
                    player: {
                        name: playerNameInput.value.trim() || 'Jogador',
                        chips: 1000
                    }
                }));
            });
            
            ws.addEventListener('message', (event) => {
                const data = JSON.parse(event.data);
                console.log('Mensagem recebida:', data);
                
                // Processar mensagens do servidor
                if (data.type === 'game_state') {
                    // Atualizar estado do jogo com dados do servidor
                    gameState.players = data.players;
                    gameState.communityCards = data.communityCards;
                    gameState.pot = data.pot;
                    gameState.currentBet = data.currentBet;
                    gameState.phase = data.phase;
                    gameState.currentPlayerIndex = data.currentPlayerIndex;
                    
                    updateUI();
                } else if (data.type === 'your_turn') {
                    // Ativar controles para o jogador atual
                    gameState.isPlayerTurn = true;
                    updateControls();
                }
            });
            
            ws.addEventListener('close', () => {
                console.log('Desconectado do servidor');
                showGameMessage('Desconectado do servidor. Reconectando...', 2000);
                
                // Tentar reconectar após 3 segundos
                setTimeout(connectToServer, 3000);
            });
            
            ws.addEventListener('error', (error) => {
                console.error('Erro de WebSocket:', error);
                showGameMessage('Erro de conexão com o servidor', 2000);
            });
            
            gameState.socket = ws;
        }

        // Inicializar a página
        function init() {
            // Desativar elementos da UI até que o jogo comece
            checkCallBtn.disabled = true;
            betRaiseBtn.disabled = true;
            foldBtn.disabled = true;
            
            showGameMessage('Bem-vindo ao Poker Texas Hold\'em! Escolha um modo de jogo.', 0);
            
            gameState.history = [];
            gameState.round = 0;
        }

        // Iniciar o jogo
        init();

        // Função para adicionar uma entrada ao histórico
        function addToHistory(entry) {
            // Limitar o histórico a 7 entradas
            if (gameState.history.length >= 7) {
                gameState.history.pop(); // Remove a entrada mais antiga
            }
            
            // Adicionar nova entrada no início
            gameState.history.unshift({
                ...entry,
                round: gameState.round
            });
            
            // Atualizar a exibição do histórico
            updateHistoryDisplay();
        }

        // Função para atualizar a exibição do histórico
        function updateHistoryDisplay() {
            const historyContainer = document.getElementById('history-container');
            historyContainer.innerHTML = '';
            
            gameState.history.forEach(entry => {
                const historyEntry = document.createElement('div');
                historyEntry.className = 'history-entry';
                
                const roundElement = document.createElement('div');
                roundElement.className = 'history-round';
                roundElement.textContent = `Rodada ${entry.round}`;
                
                const winnerElement = document.createElement('div');
                winnerElement.className = 'history-winner';
                
                if (entry.winners.length === 1) {
                    // Um vencedor
                    const winnerNameElement = document.createElement('span');
                    winnerNameElement.className = 'history-winner-name';
                    winnerNameElement.textContent = entry.winners[0].name;
                    
                    const amountElement = document.createElement('span');
                    amountElement.className = 'history-amount';
                    amountElement.textContent = ` ganhou $${entry.amount}`;
                    
                    winnerElement.appendChild(winnerNameElement);
                    winnerElement.appendChild(amountElement);
                    
                    if (entry.hand) {
                        const handElement = document.createElement('div');
                        handElement.className = 'history-hand';
                        
                        // Verificar se a vitória foi por fold
                        if (entry.type === 'fold' || entry.hand === "todos desistiram") {
                            handElement.textContent = `(todos desistiram)`;
                        } else {
                            handElement.textContent = `com ${entry.hand}`;
                        }
                        
                        historyEntry.appendChild(handElement);
                    }
                } else {
                    // Múltiplos vencedores (empate)
                    winnerElement.textContent = 'Empate entre ';
                    
                    entry.winners.forEach((winner, index) => {
                        const winnerNameElement = document.createElement('span');
                        winnerNameElement.className = 'history-winner-name';
                        winnerNameElement.textContent = winner.name;
                        
                        winnerElement.appendChild(winnerNameElement);
                        
                        if (index < entry.winners.length - 1) {
                            winnerElement.appendChild(document.createTextNode(', '));
                        }
                    });
                    
                    const amountElement = document.createElement('div');
                    amountElement.className = 'history-amount';
                    amountElement.textContent = `Cada um ganhou $${Math.floor(entry.amount / entry.winners.length)}`;
                    historyEntry.appendChild(amountElement);
                    
                    if (entry.hand) {
                        const handElement = document.createElement('div');
                        handElement.className = 'history-hand';
                        handElement.textContent = `com ${entry.hand}`;
                        historyEntry.appendChild(handElement);
                    }
                }
                
                historyEntry.appendChild(roundElement);
                historyEntry.appendChild(winnerElement);
                historyContainer.appendChild(historyEntry);
            });
        }

        // Função para alternar entre minimizado e maximizado
        function toggleHistoryPanel() {
            const historyPanel = document.getElementById('history-panel');
            const historyToggle = document.getElementById('history-toggle');
            
            historyPanel.classList.toggle('minimized');
            
            // Salvar preferência do usuário
            const isMinimized = historyPanel.classList.contains('minimized');
            localStorage.setItem('pokerHistoryMinimized', isMinimized);
        }

        // Adicionar evento de clique ao título do histórico
        document.addEventListener('DOMContentLoaded', function() {
            const historyTitle = document.getElementById('history-title');
            if (historyTitle) {
                historyTitle.addEventListener('click', toggleHistoryPanel);
            }
            
            // Verificar preferência salva
            const historyPanel = document.getElementById('history-panel');
            if (historyPanel) {
                const savedPreference = localStorage.getItem('pokerHistoryMinimized');
                if (savedPreference === 'true') {
                    historyPanel.classList.add('minimized');
                }
            }
        });
    </script>
</body>
</html> 