<!DOCTYPE html>
<html lang="pt-br">
<head>
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KM6SHZXP');</script>
    <!-- End Google Tag Manager -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poker Texas Hold'em</title>
    <style>
        :root {
            --primary-color: #1a5e1a;
            --secondary-color: #0f360f;
            --text-color: #ddd;
            --accent-color: #d4af37;
            --card-bg: #fff;
            --card-red: #e44145;
            --card-black: #222;
            --button-primary: #2c7873;
            --button-hover: #1e5350;
            --button-secondary: #a23131;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--primary-color);
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        header {
            text-align: center;
        }

        h1 {
            font-size: 36px;
            color: var(--accent-color);
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .game-modes {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
        }

        .mode-button {
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            background-color: var(--button-primary);
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .mode-button:hover {
            background-color: var(--button-hover);
        }

        .game-container {
            width: 100%;
            max-width: 1000px;
            background-color: var(--secondary-color);
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            position: relative;
        }

        .table {
            background-color: var(--primary-color);
            border-radius: 100px;
            border: 10px solid #143914;
            padding: 20px;
            margin-bottom: 20px;
            position: relative;
            min-height: 400px;
        }

        .community-cards {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
        }

        .player-area {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            flex-wrap: wrap;
            gap: 20px;
        }

        .player {
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            width: calc(33.33% - 20px);
            min-width: 200px;
            text-align: center;
            position: relative;
        }

        .player.current {
            box-shadow: 0 0 10px var(--accent-color);
        }

        .player.folded {
            opacity: 0.6;
        }

        .player-name {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .player-chips {
            margin-bottom: 10px;
            font-size: 14px;
            color: var(--accent-color);
        }

        .player-bet {
            margin-bottom: 10px;
            font-size: 14px;
        }

        .player-cards {
            display: flex;
            justify-content: center;
            gap: 5px;
            margin-bottom: 10px;
        }

        .card {
            width: 60px;
            height: 90px;
            background-color: var(--card-bg);
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            box-shadow: 1px 1px 4px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .card.red {
            color: var(--card-red);
        }

        .card.black {
            color: var(--card-black);
        }

        .card.facedown {
            background-color: #2b5797;
            background-image: linear-gradient(45deg, #2b5797 25%, #1c4677 25%, #1c4677 50%, #2b5797 50%, #2b5797 75%, #1c4677 75%, #1c4677 100%);
            background-size: 10px 10px;
        }

        .card-value {
            font-size: 20px;
            position: absolute;
            top: 5px;
            left: 5px;
        }

        .card-suit {
            font-size: 24px;
        }

        .community-cards .card {
            width: 70px;
            height: 100px;
        }

        .pot {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 18px;
            color: var(--accent-color);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        .control-button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            background-color: var(--button-primary);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .control-button:hover {
            background-color: var(--button-hover);
        }

        .control-button.fold {
            background-color: var(--button-secondary);
        }

        .control-button.fold:hover {
            background-color: #7e2424;
        }

        .control-button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        .bet-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .bet-amount {
            width: 100px;
            padding: 8px;
            border-radius: 5px;
            border: 2px solid var(--button-primary);
            text-align: center;
            font-size: 16px;
        }

        .game-message {
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            text-align: center;
            font-size: 18px;
            padding: 15px;
        }

        .game-message-container {
            min-height: 60px;
            margin: 15px 0;
        }

        .mode-select {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            border-radius: 10px;
        }

        .mode-select h2 {
            color: var(--accent-color);
            margin-bottom: 30px;
        }

        .online-options {
            display: none;
            margin-top: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 10px;
            width: 100%;
            max-width: 400px;
        }

        .online-options input,
        .online-options button {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            border: none;
        }

        .online-options button {
            background-color: var(--button-primary);
            color: white;
            cursor: pointer;
        }

        .hand-ranking {
            margin-top: 10px;
            font-style: italic;
            color: #aaa;
        }
        
        .hidden {
            display: none;
        }

        .mode-button.disabled {
            background-color: #555;
            cursor: not-allowed;
            position: relative;
        }
        
        .mode-button.disabled:hover::after {
            content: "Funcionalidade em constru√ß√£o";
            position: absolute;
            bottom: -40px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
            white-space: nowrap;
            z-index: 100;
        }

        @keyframes winnerGlow {
            0% { box-shadow: 0 0 5px 2px rgba(212, 175, 55, 0.5); }
            50% { box-shadow: 0 0 20px 10px rgba(212, 175, 55, 0.8); }
            100% { box-shadow: 0 0 5px 2px rgba(212, 175, 55, 0.5); }
        }
        
        @keyframes chipsFly {
            0% { 
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            80% {
                opacity: 0.8;
            }
            100% { 
                transform: translate(var(--target-x), var(--target-y)) scale(0.5);
                opacity: 0;
            }
        }
        
        .winner-highlight {
            animation: winnerGlow 1.5s ease-in-out infinite;
            border: 2px solid #d4af37 !important;
        }
        
        .pot-chip {
            position: absolute;
            width: 30px;
            height: 30px;
            background-color: #d4af37;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #333;
            font-weight: bold;
            font-size: 12px;
            z-index: 100;
            animation: chipsFly 1.5s forwards;
        }
        
        .win-amount {
            position: absolute;
            color: #d4af37;
            font-weight: bold;
            font-size: 24px;
            text-shadow: 0 0 5px black;
            z-index: 101;
            opacity: 0;
            animation: fadeInOut 2s forwards;
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(0); }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translateY(-30px); }
        }

        .history-panel {
            position: absolute;
            right: 20px;
            top: 20px;
            width: 250px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-color);
            border-radius: 10px;
            padding: 15px;
            color: var(--text-color);
            max-height: 80vh;
            overflow-y: auto;
            transition: height 0.3s ease, padding 0.3s ease;
        }

        .history-title {
            color: var(--accent-color);
            font-size: 18px;
            margin-bottom: 10px;
            text-align: center;
            border-bottom: 1px solid var(--accent-color);
            padding-bottom: 5px;
            position: relative;
            cursor: pointer;
            user-select: none;
        }

        .history-toggle {
            position: absolute;
            right: 5px;
            top: 0;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .history-panel.minimized {
            height: 40px;
            padding-bottom: 5px;
            overflow: hidden;
        }

        .history-panel.minimized .history-toggle {
            transform: rotate(180deg);
        }

        .history-entry {
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .history-entry:last-child {
            border-bottom: none;
        }

        .history-round {
            font-weight: bold;
            color: var(--accent-color);
            margin-bottom: 5px;
        }

        .history-winner {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .history-winner-name {
            font-weight: bold;
            margin-right: 5px;
        }

        .history-amount {
            color: #d4af37;
            font-weight: bold;
        }

        .history-hand {
            font-style: italic;
            font-size: 0.9em;
            color: #aaa;
        }

        #background-music {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            display: none; /* Oculto por padr√£o */
        }

        #play-music {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KM6SHZXP"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->

    <audio id="background-music" controls>
        <source src="../assets/sounds/jazz_2.mpeg" type="audio/mpeg" />
        Seu navegador n√£o suporta o elemento de √°udio.
    </audio>

    <button id="play-music" class="mode-button">
        üéµ M√∫sica de Fundo
    </button>
    
    <header>
        <h1>Poker Texas Hold'em</h1>
    </header>

    <div class="game-container">
        <div class="mode-select">
            <h2>Escolha o Modo de Jogo</h2>
            <div class="game-modes">
                <button id="single-player" class="mode-button">Single Player</button>
                <button id="multiplayer" class="mode-button disabled">Multiplayer</button>
            </div>
            <div class="online-options">
                <input type="text" id="player-name" placeholder="Seu nome">
                <input type="text" id="room-id" placeholder="ID da sala (para entrar)">
                <button id="create-room">Criar Sala</button>
                <button id="join-room">Entrar na Sala</button>
            </div>
        </div>

        <div class="table">
            <div class="community-cards">
                <!-- Cartas comunit√°rias ser√£o adicionadas aqui -->
            </div>
            <div class="pot">Pot: $0</div>
        </div>

        <div class="player-area">
            <!-- Jogadores ser√£o adicionados aqui -->
        </div>

        <div class="game-message-container">
            <div class="game-message"></div>
        </div>

        <div class="controls">
            <button class="control-button check-call">Check/Call</button>
            <button class="control-button bet-raise">Bet/Raise</button>
            <button class="control-button fold">Fold</button>
            <div class="bet-controls">
                <input type="number" class="bet-amount" min="1" value="10">
                <button class="control-button min-bet">Min</button>
                <button class="control-button max-bet">Max</button>
            </div>
        </div>

    </div>
    <div class="history-panel" id="history-panel">
        <div class="history-title" id="history-title">
            Hist√≥rico de Rodadas
            <span class="history-toggle" id="history-toggle">‚ñº</span>
        </div>
        <div id="history-container"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const music = document.getElementById('background-music');
            const playButton = document.getElementById('play-music');
            
            // Definir volume inicial para 40%
            music.volume = 0.4;
            
            // Adicionar evento de clique ao bot√£o de m√∫sica
            playButton.addEventListener('click', function() {
                // Mostrar o player e ocultar o bot√£o
                music.style.display = 'block';
                playButton.style.display = 'none';
                
                // Iniciar a reprodu√ß√£o
                music.play().catch(error => {
                    console.log('Reprodu√ß√£o autom√°tica bloqueada pelo navegador:', error);
                    // Se a reprodu√ß√£o autom√°tica for bloqueada, mantenha o bot√£o vis√≠vel
                    playButton.style.display = 'block';
                });
            });
        });
        
        // Constantes e configura√ß√µes
        const SUITS = ['‚ô•', '‚ô¶', '‚ô†', '‚ô£'];
        const VALUES = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const RED_SUITS = ['‚ô•', '‚ô¶'];
        const HAND_RANKINGS = [
            'High Card', 'Pair', 'Two Pair', 'Three of a Kind', 'Straight',
            'Flush', 'Full House', 'Four of a Kind', 'Straight Flush', 'Royal Flush'
        ];
        
        // Estado do jogo
        let gameState = {
            deck: [],
            communityCards: [],
            players: [],
            currentPlayerIndex: 0,
            pot: 0,
            minBet: 10,
            currentBet: 0,
            phase: 'waiting', // waiting, preflop, flop, turn, river, showdown
            isPlayerTurn: false,
            gameMode: null, // singleplayer or multiplayer
            socket: null,
            roomId: null,
            history: [],
            round: 0
        };

        // Elementos do DOM
        const modeSelect = document.querySelector('.mode-select');
        const singlePlayerBtn = document.getElementById('single-player');
        const multiplayerBtn = document.getElementById('multiplayer');
        const onlineOptions = document.querySelector('.online-options');
        const createRoomBtn = document.getElementById('create-room');
        const joinRoomBtn = document.getElementById('join-room');
        const playerNameInput = document.getElementById('player-name');
        const roomIdInput = document.getElementById('room-id');
        const communityCardsEl = document.querySelector('.community-cards');
        const playerAreaEl = document.querySelector('.player-area');
        const potEl = document.querySelector('.pot');
        const gameMessageEl = document.querySelector('.game-message');
        const checkCallBtn = document.querySelector('.check-call');
        const betRaiseBtn = document.querySelector('.bet-raise');
        const foldBtn = document.querySelector('.fold');
        const betAmountInput = document.querySelector('.bet-amount');
        const minBetBtn = document.querySelector('.min-bet');
        const maxBetBtn = document.querySelector('.max-bet');

        // Fun√ß√µes para o baralho
        function createDeck() {
            const deck = [];
            for (const suit of SUITS) {
                for (const value of VALUES) {
                    deck.push({ suit, value });
                }
            }
            return deck;
        }

        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        function dealCards() {
            gameState.deck = shuffleDeck(createDeck());
            gameState.communityCards = [];
            
            // Distribuir 2 cartas para cada jogador
            for (const player of gameState.players) {
                player.cards = [gameState.deck.pop(), gameState.deck.pop()];
                player.folded = false;
                player.bet = 0;
                player.handRanking = '';
            }
            
            updateUI();
        }

        // Fun√ß√µes para classificar m√£os de poker
        function getCardValue(card) {
            return VALUES.indexOf(card.value);
        }

        function evaluateHand(cards) {
            // Ordenar as cartas por valor (do maior para o menor)
            const sortedCards = [...cards].sort((a, b) => b.value - a.value);
            
            // Verificar royal flush, straight flush, etc...
            // (c√≥digo existente)
            
            // Adicionar informa√ß√µes detalhadas para desempate
            const result = {
                name: "High Card", // Nome padr√£o, ser√° substitu√≠do
                rank: 0,           // Ranking da m√£o (0-9)
                primaryValue: 0,   // Valor principal para desempate (ex: valor do par)
                secondaryValue: 0, // Valor secund√°rio para desempate (ex: valor do segundo par)
                kickers: []        // Cartas kicker para desempate adicional
            };
            
            // Verificar Royal Flush
            if (hasRoyalFlush(sortedCards)) {
                result.name = "Royal Flush";
                result.rank = 9;
                return result;
            }
            
            // Verificar Straight Flush
            const straightFlushValue = hasStraightFlush(sortedCards);
            if (straightFlushValue) {
                result.name = "Straight Flush";
                result.rank = 8;
                result.primaryValue = straightFlushValue;
                return result;
            }
            
            // Verificar Four of a Kind (Quadra)
            const fourOfAKind = hasFourOfAKind(sortedCards);
            if (fourOfAKind) {
                result.name = "Four of a Kind";
                result.rank = 7;
                result.primaryValue = fourOfAKind.value;
                result.kickers = fourOfAKind.kickers;
                return result;
            }
            
            // Verificar Full House
            const fullHouse = hasFullHouse(sortedCards);
            if (fullHouse) {
                result.name = "Full House";
                result.rank = 6;
                result.primaryValue = fullHouse.threeValue;
                result.secondaryValue = fullHouse.pairValue;
                return result;
            }
            
            // Verificar Flush
            const flush = hasFlush(sortedCards);
            if (flush) {
                result.name = "Flush";
                result.rank = 5;
                result.kickers = flush.slice(0, 5).map(card => card.value);
                return result;
            }
            
            // Verificar Straight
            const straightValue = hasStraight(sortedCards);
            if (straightValue) {
                result.name = "Straight";
                result.rank = 4;
                result.primaryValue = straightValue;
                return result;
            }
            
            // Verificar Three of a Kind (Trinca)
            const threeOfAKind = hasThreeOfAKind(sortedCards);
            if (threeOfAKind) {
                result.name = "Three of a Kind";
                result.rank = 3;
                result.primaryValue = threeOfAKind.value;
                result.kickers = threeOfAKind.kickers;
                return result;
            }
            
            // Verificar Two Pair (Dois Pares)
            const twoPair = hasTwoPair(sortedCards);
            if (twoPair) {
                result.name = "Two Pair";
                result.rank = 2;
                result.primaryValue = twoPair.highPairValue;
                result.secondaryValue = twoPair.lowPairValue;
                result.kickers = [twoPair.kicker];
                return result;
            }
            
            // Verificar One Pair (Um Par)
            const onePair = hasOnePair(sortedCards);
            if (onePair) {
                result.name = "One Pair";
                result.rank = 1;
                result.primaryValue = onePair.value;
                result.kickers = onePair.kickers;
                return result;
            }
            
            // High Card
            result.name = "High Card";
            result.rank = 0;
            result.kickers = sortedCards.slice(0, 5).map(card => card.value);
            return result;
        }

        // Fun√ß√µes auxiliares para verificar cada tipo de m√£o
        function hasRoyalFlush(cards) {
            // Verificar se h√° um straight flush
            const straightFlushValue = hasStraightFlush(cards);
            
            // Um royal flush √© um straight flush com a carta mais alta sendo um √Ås (valor 14)
            if (straightFlushValue === 14) {
                return true;
            }
            
            return false;
        }

        function hasStraightFlush(cards) {
            // Agrupar cartas por naipe
            const suits = {};
            cards.forEach(card => {
                suits[card.suit] = (suits[card.suit] || 0) + 1;
            });
            
            // Verificar cada naipe que tem pelo menos 5 cartas
            for (const suit in suits) {
                if (suits[suit] >= 5) {
                    // Filtrar apenas as cartas deste naipe
                    const sameSuitCards = cards.filter(card => card.suit === suit);
                    
                    // Verificar se h√° uma sequ√™ncia neste naipe
                    const straightValue = hasStraight(sameSuitCards);
                    if (straightValue) {
                        return straightValue;
                    }
                }
            }
            
            return null;
        }

        function hasFourOfAKind(cards) {
            // Agrupar cartas por valor
            const groups = {};
            cards.forEach(card => {
                groups[card.value] = (groups[card.value] || 0) + 1;
            });
            
            // Procurar por quatro cartas do mesmo valor
            for (const value in groups) {
                if (groups[value] === 4) {
                    // Encontrar o kicker (carta mais alta que n√£o faz parte da quadra)
                    const kickers = cards.filter(card => card.value !== parseInt(value))
                                        .slice(0, 1)
                                        .map(card => card.value);
                    
                    return {
                        value: parseInt(value),
                        kickers: kickers
                    };
                }
            }
            
            return null;
        }

        function hasFullHouse(cards) {
            // Agrupar cartas por valor
            const groups = {};
            cards.forEach(card => {
                groups[card.value] = (groups[card.value] || 0) + 1;
            });
            
            let threeOfAKindValue = null;
            let pairValue = null;
            
            // Procurar por tr√™s cartas do mesmo valor
            for (const value in groups) {
                if (groups[value] >= 3) {
                    threeOfAKindValue = parseInt(value);
                    break;
                }
            }
            
            // Se encontrou tr√™s cartas, procurar por um par
            if (threeOfAKindValue !== null) {
                for (const value in groups) {
                    const cardValue = parseInt(value);
                    if (cardValue !== threeOfAKindValue && groups[value] >= 2) {
                        pairValue = cardValue;
                        break;
                    }
                }
                
                // Se tiver 4 cartas do mesmo valor, podemos usar 3 delas para a trinca
                // e as outras 2 para formar um par
                if (pairValue === null && groups[threeOfAKindValue] >= 5) {
                    pairValue = threeOfAKindValue;
                }
            }
            
            if (threeOfAKindValue !== null && pairValue !== null) {
                return {
                    threeValue: threeOfAKindValue,
                    pairValue: pairValue
                };
            }
            
            return null;
        }

        function hasThreeOfAKind(cards) {
            // Agrupar cartas por valor
            const groups = {};
            cards.forEach(card => {
                groups[card.value] = (groups[card.value] || 0) + 1;
            });
            
            // Procurar por tr√™s cartas do mesmo valor
            for (const value in groups) {
                if (groups[value] === 3) {
                    // Encontrar os kickers (duas cartas mais altas que n√£o fazem parte da trinca)
                    const kickers = cards.filter(card => card.value !== parseInt(value))
                                        .slice(0, 2)
                                        .map(card => card.value);
                    
                    return {
                        value: parseInt(value),
                        kickers: kickers
                    };
                }
            }
            
            return null;
        }

        function hasTwoPair(cards) {
            // Agrupar cartas por valor
            const groups = {};
            cards.forEach(card => {
                groups[card.value] = (groups[card.value] || 0) + 1;
            });
            
            const pairs = [];
            
            // Procurar por pares
            for (const value in groups) {
                if (groups[value] >= 2) {
                    pairs.push(parseInt(value));
                }
            }
            
            // Ordenar pares do maior para o menor
            pairs.sort((a, b) => b - a);
            
            if (pairs.length >= 2) {
                // Encontrar o kicker (carta mais alta que n√£o faz parte dos pares)
                const kicker = cards.filter(card => !pairs.includes(card.value))
                                   .slice(0, 1)
                                   .map(card => card.value)[0] || 0;
                
                return {
                    highPairValue: pairs[0],
                    lowPairValue: pairs[1],
                    kicker: kicker
                };
            }
            
            return null;
        }

        function hasOnePair(cards) {
            // Agrupar cartas por valor
            const groups = {};
            cards.forEach(card => {
                groups[card.value] = (groups[card.value] || 0) + 1;
            });
            
            // Procurar por um par
            for (const value in groups) {
                if (groups[value] === 2) {
                    // Encontrar os kickers (tr√™s cartas mais altas que n√£o fazem parte do par)
                    const kickers = cards.filter(card => card.value !== parseInt(value))
                                        .slice(0, 3)
                                        .map(card => card.value);
                    
                    return {
                        value: parseInt(value),
                        kickers: kickers
                    };
                }
            }
            
            return null;
        }

        // Fun√ß√µes de UI
        function updateUI() {
            updateCommunityCards();
            updatePlayers();
            updatePot();
            updateControls();
        }

        function updateCommunityCards() {
            communityCardsEl.innerHTML = '';
            
            if (gameState.phase === 'waiting' || gameState.phase === 'preflop') {
                // No flop phase, placeholders for cards
                for (let i = 0; i < 5; i++) {
                    const cardEl = document.createElement('div');
                    cardEl.className = 'card facedown';
                    communityCardsEl.appendChild(cardEl);
                }
            } else {
                // Show the community cards
                let visibleCards = 0;
                if (gameState.phase === 'flop') visibleCards = 3;
                else if (gameState.phase === 'turn') visibleCards = 4;
                else visibleCards = 5; // river or showdown
                
                for (let i = 0; i < visibleCards; i++) {
                    if (i < gameState.communityCards.length) {
                        const card = gameState.communityCards[i];
                        const cardEl = createCardElement(card);
                        communityCardsEl.appendChild(cardEl);
                    }
                }
                
                // Add face down placeholders for remaining cards
                for (let i = visibleCards; i < 5; i++) {
                    const cardEl = document.createElement('div');
                    cardEl.className = 'card facedown';
                    communityCardsEl.appendChild(cardEl);
                }
            }
        }

        function updatePlayers() {
            playerAreaEl.innerHTML = '';
            
            gameState.players.forEach((player, index) => {
                const playerEl = document.createElement('div');
                playerEl.className = `player ${index === gameState.currentPlayerIndex ? 'current' : ''} ${player.folded ? 'folded' : ''}`;
                
                const nameEl = document.createElement('div');
                nameEl.className = 'player-name';
                nameEl.textContent = player.name + (player.isAI ? ' (AI)' : '');
                
                const chipsEl = document.createElement('div');
                chipsEl.className = 'player-chips';
                chipsEl.textContent = `Fichas: $${player.chips}`;
                
                const betEl = document.createElement('div');
                betEl.className = 'player-bet';
                betEl.textContent = `Aposta: $${player.bet}`;
                
                const cardsEl = document.createElement('div');
                cardsEl.className = 'player-cards';
                
                // Mostrar as cartas do jogador
                if (player.cards) {
                    player.cards.forEach(card => {
                        // Show cards for human player or during showdown for all players
                        if (!player.isAI || gameState.phase === 'showdown' || player.isHuman) {
                            const cardEl = createCardElement(card);
                            cardsEl.appendChild(cardEl);
                        } else {
                            // Face down cards for AI
                            const cardEl = document.createElement('div');
                            cardEl.className = 'card facedown';
                            cardsEl.appendChild(cardEl);
                        }
                    });
                }
                
                // Add hand ranking during showdown
                if (gameState.phase === 'showdown' && player.handRanking) {
                    const rankingEl = document.createElement('div');
                    rankingEl.className = 'hand-ranking';
                    rankingEl.textContent = player.handRanking;
                    playerEl.appendChild(rankingEl);
                }
                
                playerEl.appendChild(nameEl);
                playerEl.appendChild(chipsEl);
                playerEl.appendChild(betEl);
                playerEl.appendChild(cardsEl);
                
                playerAreaEl.appendChild(playerEl);
            });
        }

        function createCardElement(card) {
            const cardEl = document.createElement('div');
            cardEl.className = `card ${RED_SUITS.includes(card.suit) ? 'red' : 'black'}`;
            
            const valueEl = document.createElement('div');
            valueEl.className = 'card-value';
            valueEl.textContent = card.value;
            
            const suitEl = document.createElement('div');
            suitEl.className = 'card-suit';
            suitEl.textContent = card.suit;
            
            cardEl.appendChild(valueEl);
            cardEl.appendChild(suitEl);
            
            return cardEl;
        }

        function updatePot() {
            potEl.textContent = `Pot: $${gameState.pot}`;
        }

        function updateControls() {
            const isActivePlayer = gameState.currentPlayerIndex === 0 && !gameState.players[0].folded;
            const currentPlayer = gameState.players[gameState.currentPlayerIndex];
            
            checkCallBtn.disabled = !isActivePlayer || gameState.phase === 'waiting' || gameState.phase === 'showdown';
            betRaiseBtn.disabled = !isActivePlayer || gameState.phase === 'waiting' || gameState.phase === 'showdown';
            foldBtn.disabled = !isActivePlayer || gameState.phase === 'waiting' || gameState.phase === 'showdown';
            
            // Atualizar o texto do bot√£o Check/Call
            if (gameState.currentBet === 0 || currentPlayer.bet === gameState.currentBet) {
                checkCallBtn.textContent = 'Check';
            } else {
                const callAmount = gameState.currentBet - currentPlayer.bet;
                checkCallBtn.textContent = `Call $${callAmount}`;
            }
            
            // Atualizar o texto do bot√£o Bet/Raise
            if (gameState.currentBet === 0) {
                betRaiseBtn.textContent = 'Bet';
            } else {
                betRaiseBtn.textContent = 'Raise';
            }
            
            // Definir aposta m√≠nima e m√°xima
            const minRaise = gameState.currentBet + gameState.minBet;
            betAmountInput.min = minRaise;
            betAmountInput.max = currentPlayer ? currentPlayer.chips : 1000;
            betAmountInput.value = minRaise;
        }

        function showGameMessage(message, duration = 0) {
            gameMessageEl.textContent = message;
            gameMessageEl.classList.remove('hidden');
            
            if (duration > 0) {
                setTimeout(() => {
                    gameMessageEl.classList.add('hidden');
                }, duration);
            }
        }

        // L√≥gica do jogo
        function startSinglePlayerGame() {
            modeSelect.style.display = 'none';
            gameState.gameMode = 'singleplayer';
            
            // Criar jogador humano e AI
            const playerName = playerNameInput.value.trim() || 'Jogador';
            gameState.players = [
                { name: playerName, chips: 1000, bet: 0, cards: [], folded: false, isHuman: true },
                { name: 'AI 1', chips: 1000, bet: 0, cards: [], folded: false, isAI: true },
                { name: 'AI 2', chips: 1000, bet: 0, cards: [], folded: false, isAI: true },
            ];
            
            startNewHand();
        }

        function setupMultiplayerGame() {
            gameState.gameMode = 'multiplayer';
            onlineOptions.style.display = 'block';
        }

        function createRoom() {
            const playerName = playerNameInput.value.trim();
            if (!playerName) {
                alert('Por favor, digite seu nome');
                return;
            }
            
            // Simula√ß√£o de cria√ß√£o de sala (em um app real, isso seria feito com WebSockets)
            const roomId = Math.random().toString(36).substring(2, 10);
            modeSelect.style.display = 'none';
            
            // Criar jogador humano
            gameState.players = [
                { name: playerName, chips: 1000, bet: 0, cards: [], folded: false, isHuman: true }
            ];
            
            showGameMessage(`Sala criada! ID: ${roomId} - Aguardando outros jogadores...`);
            
            // Simula√ß√£o de um jogador se juntando (em um app real, isso seria notificado pelo servidor)
            setTimeout(() => {
                gameState.players.push(
                    { name: 'Jogador Online', chips: 1000, bet: 0, cards: [], folded: false }
                );
                showGameMessage('Jogador entrou na sala!', 2000);
                
                // Iniciar o jogo ap√≥s alguns segundos
                setTimeout(() => {
                    startNewHand();
                }, 2000);
            }, 3000);
        }

        function joinRoom() {
            const playerName = playerNameInput.value.trim();
            const roomId = roomIdInput.value.trim();
            
            if (!playerName || !roomId) {
                alert('Por favor, digite seu nome e o ID da sala');
                return;
            }
            
            // Simula√ß√£o de entrada em uma sala (em um app real, isso seria feito com WebSockets)
            modeSelect.style.display = 'none';
            
            // Criar jogador humano e outro j√° "existente" na sala
            gameState.players = [
                { name: playerName, chips: 1000, bet: 0, cards: [], folded: false, isHuman: true },
                { name: 'Dono da Sala', chips: 1000, bet: 0, cards: [], folded: false }
            ];
            
            showGameMessage('Entrando na sala...', 2000);
            
            // Iniciar o jogo ap√≥s alguns segundos
            setTimeout(() => {
                startNewHand();
            }, 2000);
        }

        function startNewHand() {
            // Incrementar o contador de rodadas
            gameState.round = (gameState.round || 0) + 1;
            
            gameState.phase = 'preflop';
            gameState.pot = 0;
            gameState.currentBet = gameState.minBet * 2; // Big blind
            
            // Collect blinds
            const smallBlindIdx = 0;
            const bigBlindIdx = 1 % gameState.players.length;
            
            gameState.players[smallBlindIdx].chips -= gameState.minBet;
            gameState.players[smallBlindIdx].bet = gameState.minBet;
            
            gameState.players[bigBlindIdx].chips -= gameState.minBet * 2;
            gameState.players[bigBlindIdx].bet = gameState.minBet * 2;
            
            gameState.pot = gameState.minBet * 3;
            
            // Dealer is after big blind
            gameState.currentPlayerIndex = (bigBlindIdx + 1) % gameState.players.length;
            
            // Deal cards
            dealCards();
            
            showGameMessage('Nova m√£o iniciada!', 3000);
            
            if (gameState.players[gameState.currentPlayerIndex].isAI) {
                setTimeout(playAITurn, 1500);
            }
        }

        function nextPhase() {
            switch (gameState.phase) {
                case 'preflop':
                    gameState.phase = 'flop';
                    // Deal the flop - 3 community cards
                    gameState.communityCards = [
                        gameState.deck.pop(),
                        gameState.deck.pop(),
                        gameState.deck.pop()
                    ];
                    showGameMessage('Flop!', 2000);
                    break;
                case 'flop':
                    gameState.phase = 'turn';
                    // Deal the turn - 1 more community card
                    gameState.communityCards.push(gameState.deck.pop());
                    showGameMessage('Turn!', 2000);
                    break;
                case 'turn':
                    gameState.phase = 'river';
                    // Deal the river - final community card
                    gameState.communityCards.push(gameState.deck.pop());
                    showGameMessage('River!', 2000);
                    break;
                case 'river':
                    gameState.phase = 'showdown';
                    handleShowdown();
                    return;
            }
            
            // Reset for new betting round
            gameState.currentBet = 0;
            gameState.players.forEach(player => {
                player.bet = 0;
            });
            
            // Start with first active player
            gameState.currentPlayerIndex = 0;
            while (
                gameState.currentPlayerIndex < gameState.players.length && 
                gameState.players[gameState.currentPlayerIndex].folded
            ) {
                gameState.currentPlayerIndex++;
            }
            
            if (gameState.currentPlayerIndex >= gameState.players.length) {
                gameState.currentPlayerIndex = 0;
            }
            
            updateUI();
            
            if (gameState.players[gameState.currentPlayerIndex].isAI) {
                setTimeout(playAITurn, 1500);
            }
        }

        function handleShowdown() {
            // Revelar todas as cartas
            gameState.players.forEach(player => {
                if (!player.isAI) {
                    player.showCards = true;
                }
            });
            
            // Determinar o vencedor e distribuir o pot
            const winner = determineWinner();
            
            // Atualizar a UI
            updateUI();
            
            // Iniciar nova m√£o ap√≥s um atraso
            setTimeout(() => {
                startNewHand();
            }, 3000);
        }

        function determineWinner() {
            // Filtrar apenas jogadores que n√£o desistiram
            const activePlayers = gameState.players.filter(player => !player.folded);
            
            // Se apenas um jogador restou (todos os outros desistiram), ele √© o vencedor
            if (activePlayers.length === 1) {
                const winner = activePlayers[0];
                const winAmount = gameState.pot;
                winner.chips += winAmount;
                
                // Animar a vit√≥ria
                animateWinner(winner, winAmount);
                
                // Adicionar ao hist√≥rico - sem informa√ß√£o da m√£o
                addToHistory({
                    winners: [winner],
                    amount: winAmount,
                    hand: "todos desistiram", // Indica√ß√£o clara de que venceu por desist√™ncia
                    type: 'fold'
                });
                
                showGameMessage(`${winner.name} vence $${winAmount} (todos os outros jogadores desistiram)!`);
                gameState.pot = 0;
                
                // Iniciar nova m√£o ap√≥s um atraso
                setTimeout(() => {
                    startNewHand();
                }, 3000);
                
                return winner;
            }
            
            // Avaliar as m√£os de todos os jogadores ativos com informa√ß√µes detalhadas
            activePlayers.forEach(player => {
                const cards = [...player.cards, ...gameState.communityCards];
                const handResult = evaluateHand(cards);
                player.handRanking = handResult.name;
                player.handRank = handResult.rank;
                player.handDetails = {
                    primaryValue: handResult.primaryValue,
                    secondaryValue: handResult.secondaryValue,
                    kickers: handResult.kickers
                };
            });
            
            // Ordenar jogadores pelo ranking da m√£o (do maior para o menor)
            activePlayers.sort((a, b) => {
                // Primeiro, comparar pelo rank da m√£o
                if (b.handRank !== a.handRank) {
                    return b.handRank - a.handRank;
                }
                
                // Se o rank for igual, comparar pelo valor prim√°rio
                if (b.handDetails.primaryValue !== a.handDetails.primaryValue) {
                    return b.handDetails.primaryValue - a.handDetails.primaryValue;
                }
                
                // Se o valor prim√°rio for igual, comparar pelo valor secund√°rio
                if (b.handDetails.secondaryValue !== a.handDetails.secondaryValue) {
                    return b.handDetails.secondaryValue - a.handDetails.secondaryValue;
                }
                
                // Se o valor secund√°rio for igual, comparar pelos kickers
                const aKickers = a.handDetails.kickers || [];
                const bKickers = b.handDetails.kickers || [];
                
                // Comparar cada kicker em ordem
                for (let i = 0; i < Math.min(aKickers.length, bKickers.length); i++) {
                    if (bKickers[i] !== aKickers[i]) {
                        return bKickers[i] - aKickers[i];
                    }
                }
                
                // Se todos os kickers forem iguais, √© um empate perfeito
                return 0;
            });
            
            // O jogador com o maior ranking √© o vencedor, mas pode haver empate perfeito
            const winner = activePlayers[0];
            
            // Verificar se h√° empate perfeito (todos os crit√©rios de desempate s√£o iguais)
            const tiedPlayers = activePlayers.filter(player => {
                if (player.handRank !== winner.handRank) return false;
                if (player.handDetails.primaryValue !== winner.handDetails.primaryValue) return false;
                if (player.handDetails.secondaryValue !== winner.handDetails.secondaryValue) return false;
                
                // Comparar kickers
                const playerKickers = player.handDetails.kickers || [];
                const winnerKickers = winner.handDetails.kickers || [];
                
                if (playerKickers.length !== winnerKickers.length) return false;
                
                for (let i = 0; i < playerKickers.length; i++) {
                    if (playerKickers[i] !== winnerKickers[i]) return false;
                }
                
                // Se chegou aqui, √© um empate perfeito
                return true;
            });
            
            // Resto do c√≥digo para distribuir o pot...
        }

        // Fun√ß√£o para animar o vencedor e o movimento de fichas
        function animateWinner(player, amount) {
            // Encontrar o elemento do jogador
            const playerIndex = gameState.players.indexOf(player);
            const playerElement = document.querySelector(`.player:nth-child(${playerIndex + 1})`);
            
            if (!playerElement) return;
            
            // Destacar o jogador vencedor
            playerElement.classList.add('winner-highlight');
            
            // Encontrar a posi√ß√£o do pot e do jogador para animar as fichas
            const tableElement = document.querySelector('.table');
            const potPosition = {
                x: tableElement.offsetWidth / 2,
                y: tableElement.offsetHeight / 2
            };
            
            const playerPosition = {
                x: playerElement.offsetLeft + playerElement.offsetWidth / 2,
                y: playerElement.offsetTop + playerElement.offsetHeight / 2
            };
            
            // Criar anima√ß√£o de fichas voando do pot para o jogador
            const chipCount = Math.min(10, Math.max(3, Math.floor(amount / 100)));
            
            for (let i = 0; i < chipCount; i++) {
                setTimeout(() => {
                    const chip = document.createElement('div');
                    chip.className = 'pot-chip';
                    chip.textContent = '$';
                    chip.style.left = `${potPosition.x}px`;
                    chip.style.top = `${potPosition.y}px`;
                    
                    // Calcular a dire√ß√£o para o jogador
                    const targetX = playerPosition.x - potPosition.x;
                    const targetY = playerPosition.y - potPosition.y;
                    
                    chip.style.setProperty('--target-x', `${targetX}px`);
                    chip.style.setProperty('--target-y', `${targetY}px`);
                    
                    tableElement.appendChild(chip);
                    
                    // Remover o chip ap√≥s a anima√ß√£o
                    setTimeout(() => {
                        chip.remove();
                    }, 1500);
                }, i * 100);
            }
            
            // Mostrar o valor ganho
            const winAmount = document.createElement('div');
            winAmount.className = 'win-amount';
            winAmount.textContent = `+$${amount}`;
            winAmount.style.left = `${playerPosition.x - 40}px`;
            winAmount.style.top = `${playerPosition.y - 30}px`;
            
            tableElement.appendChild(winAmount);
            
            // Remover o destaque e o valor ap√≥s um tempo
            setTimeout(() => {
                playerElement.classList.remove('winner-highlight');
                winAmount.remove();
            }, 3000);
        }

        // A√ß√µes do jogador
        function handleCheckCall() {
            const player = gameState.players[gameState.currentPlayerIndex];
            
            if (gameState.currentBet > player.bet) {
                // Call
                const callAmount = gameState.currentBet - player.bet;
                player.chips -= callAmount;
                player.bet = gameState.currentBet;
                gameState.pot += callAmount;
                showGameMessage(`${player.name} calls $${callAmount}`, 2000);
            } else {
                // Check
                showGameMessage(`${player.name} checks`, 2000);
            }
            
            nextPlayerTurn();
        }

        function handleBetRaise() {
            const player = gameState.players[gameState.currentPlayerIndex];
            const betAmount = parseInt(betAmountInput.value);
            
            if (isNaN(betAmount) || betAmount < gameState.currentBet + gameState.minBet || betAmount > player.chips) {
                alert('Aposta inv√°lida!');
                return;
            }
            
            // Remove previous bet from chips
            player.chips -= (betAmount - player.bet);
            
            // Add to pot
            gameState.pot += (betAmount - player.bet);
            
            // Update current bet
            gameState.currentBet = betAmount;
            player.bet = betAmount;
            
            if (gameState.currentBet === 0) {
                showGameMessage(`${player.name} bets $${betAmount}`, 2000);
            } else {
                showGameMessage(`${player.name} raises to $${betAmount}`, 2000);
            }
            
            nextPlayerTurn();
        }

        function handleFold() {
            const player = gameState.players[gameState.currentPlayerIndex];
            player.folded = true;
            showGameMessage(`${player.name} folds`, 2000);
            
            // Check if only one player left
            const activePlayers = gameState.players.filter(p => !p.folded);
            if (activePlayers.length === 1) {
                // Award pot to last player
                activePlayers[0].chips += gameState.pot;
                showGameMessage(`${activePlayers[0].name} wins $${gameState.pot}!`);
                
                // Start new hand after delay
                setTimeout(() => {
                    startNewHand();
                }, 3000);
                return;
            }
            
            nextPlayerTurn();
        }

        function nextPlayerTurn() {
            // Check if betting round is complete
            let allPlayersBetEqual = true;
            const activePlayers = gameState.players.filter(p => !p.folded);
            
            for (const player of activePlayers) {
                if (player.bet !== gameState.currentBet) {
                    allPlayersBetEqual = false;
                    break;
                }
            }
            
            if (allPlayersBetEqual) {
                // Move to next phase
                nextPhase();
                return;
            }
            
            // Move to next player
            do {
                gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
            } while (gameState.players[gameState.currentPlayerIndex].folded);
            
            updateUI();
            if (gameState.players[gameState.currentPlayerIndex].isAI) {
                setTimeout(playAITurn, 1500);
            }
        }

        // AI logic
        function playAITurn() {
            if (gameState.phase === 'waiting' || gameState.phase === 'showdown') return;
            
            const aiPlayer = gameState.players[gameState.currentPlayerIndex];
            if (!aiPlayer.isAI || aiPlayer.folded) return;
            
            // Simula√ß√£o de estrat√©gia simples da IA
            // A IA avalia suas cartas e faz uma decis√£o baseada na for√ßa da m√£o
            const aiCards = [...aiPlayer.cards, ...gameState.communityCards.filter(card => card)];
            const handResult = evaluateHand(aiCards);
            
            // Comportamento baseado na fase do jogo e for√ßa da m√£o
            const callAmount = gameState.currentBet - aiPlayer.bet;
            const aiChips = aiPlayer.chips;
            
            // Calcular probabilidade de a√ß√£o com base na for√ßa da m√£o
            let foldProb = 0.1;
            let raiseProb = 0.2;
            
            // Ajusta probabilidades com base na for√ßa da m√£o
            if (handResult.rank >= 5) { // Flush ou melhor
                foldProb = 0;
                raiseProb = 0.7;
            } else if (handResult.rank >= 3) { // Three of a kind ou melhor
                foldProb = 0.05;
                raiseProb = 0.5;
            } else if (handResult.rank >= 1) { // Par ou melhor
                foldProb = 0.1;
                raiseProb = 0.3;
            } else {
                foldProb = 0.3;
                raiseProb = 0.1;
            }
            
            // Ajusta probabilidades com base no tamanho da aposta
            const betRatio = callAmount / aiChips;
            if (betRatio > 0.3) {
                foldProb += 0.2;
                raiseProb -= 0.1;
            }
            
            // Tomar decis√£o
            const rand = Math.random();
            
            if (rand < foldProb && callAmount > 0) {
                // Fold
                handleAIAction('fold');
            } else if (rand < foldProb + raiseProb && aiChips > callAmount + gameState.minBet) {
                // Raise
                const minRaise = gameState.currentBet + gameState.minBet;
                const maxRaise = Math.min(aiChips, gameState.currentBet + aiChips / 3);
                let raiseAmount = Math.floor(Math.random() * (maxRaise - minRaise + 1)) + minRaise;
                
                if (handResult.rank >= 7) { // Four of a kind ou melhor - poss√≠vel all-in
                    raiseAmount = aiChips;
                }
                
                handleAIAction('raise', raiseAmount);
            } else {
                // Check or call
                handleAIAction('call');
            }
        }

        function handleAIAction(action, amount = 0) {
            const aiPlayer = gameState.players[gameState.currentPlayerIndex];
            
            switch (action) {
                case 'fold':
                    aiPlayer.folded = true;
                    showGameMessage(`${aiPlayer.name} folds`, 2000);
                    break;
                case 'call':
                    if (gameState.currentBet > aiPlayer.bet) {
                        const callAmount = gameState.currentBet - aiPlayer.bet;
                        aiPlayer.chips -= callAmount;
                        aiPlayer.bet = gameState.currentBet;
                        gameState.pot += callAmount;
                        showGameMessage(`${aiPlayer.name} calls $${callAmount}`, 2000);
                    } else {
                        showGameMessage(`${aiPlayer.name} checks`, 2000);
                    }
                    break;
                case 'raise':
                    const raiseAmount = amount;
                    aiPlayer.chips -= (raiseAmount - aiPlayer.bet);
                    gameState.pot += (raiseAmount - aiPlayer.bet);
                    gameState.currentBet = raiseAmount;
                    aiPlayer.bet = raiseAmount;
                    
                    if (aiPlayer.chips === 0) {
                        showGameMessage(`${aiPlayer.name} goes all-in $${raiseAmount}!`, 2000);
                    } else if (gameState.currentBet === raiseAmount) {
                        showGameMessage(`${aiPlayer.name} bets $${raiseAmount}`, 2000);
                    } else {
                        showGameMessage(`${aiPlayer.name} raises to $${raiseAmount}`, 2000);
                    }
                    break;
            }
            
            // Check if only one player left
            const activePlayers = gameState.players.filter(p => !p.folded);
            if (activePlayers.length === 1) {
                // Award pot to last player
                activePlayers[0].chips += gameState.pot;
                showGameMessage(`${activePlayers[0].name} wins $${gameState.pot}!`);
                
                // Start new hand after delay
                setTimeout(() => {
                    startNewHand();
                }, 3000);
                updateUI();
                return;
            }
            
            nextPlayerTurn();
        }

        // Handlers para os bot√µes de aposta
        function handleMinBet() {
            const minRaise = gameState.currentBet + gameState.minBet;
            betAmountInput.value = minRaise;
        }

        function handleMaxBet() {
            const player = gameState.players[gameState.currentPlayerIndex];
            betAmountInput.value = player.chips;
        }

        // Event listeners
        singlePlayerBtn.addEventListener('click', startSinglePlayerGame);
        multiplayerBtn.addEventListener('click', function(e) {
            // N√£o fazer nada, j√° que o bot√£o est√° desabilitado
            e.preventDefault();
            showGameMessage('Modo multiplayer em constru√ß√£o. Por favor, use o modo single player.', 3000);
        });
        createRoomBtn.addEventListener('click', createRoom);
        joinRoomBtn.addEventListener('click', joinRoom);
        
        checkCallBtn.addEventListener('click', handleCheckCall);
        betRaiseBtn.addEventListener('click', handleBetRaise);
        foldBtn.addEventListener('click', handleFold);
        minBetBtn.addEventListener('click', handleMinBet);
        maxBetBtn.addEventListener('click', handleMaxBet);

        // WebSocket Mock (em uma implementa√ß√£o real, isso seria conectado a um servidor)
        class WebSocketMock {
            constructor(url) {
                this.url = url;
                this.callbacks = {};
                
                // Simular conex√£o bem-sucedida
                setTimeout(() => {
                    if (this.callbacks.open) {
                        this.callbacks.open();
                    }
                }, 500);
            }
            
            send(data) {
                console.log('Enviando dados:', data);
                
                // Simular resposta do servidor
                setTimeout(() => {
                    if (this.callbacks.message) {
                        this.callbacks.message({
                            data: JSON.stringify({
                                type: 'acknowledgment',
                                message: 'Dados recebidos pelo servidor'
                            })
                        });
                    }
                }, 300);
            }
            
            addEventListener(event, callback) {
                this.callbacks[event] = callback;
            }
            
            close() {
                if (this.callbacks.close) {
                    this.callbacks.close();
                }
            }
        }

        // Implementa√ß√£o do modo multiplayer (simulada)
        function connectToServer() {
            const ws = new WebSocketMock('wss://mock-poker-server.com');
            
            ws.addEventListener('open', () => {
                console.log('Conectado ao servidor');
                showGameMessage('Conectado ao servidor', 2000);
                
                // Enviar informa√ß√µes do jogador
                ws.send(JSON.stringify({
                    type: 'join',
                    player: {
                        name: playerNameInput.value.trim() || 'Jogador',
                        chips: 1000
                    }
                }));
            });
            
            ws.addEventListener('message', (event) => {
                const data = JSON.parse(event.data);
                console.log('Mensagem recebida:', data);
                
                // Processar mensagens do servidor
                if (data.type === 'game_state') {
                    // Atualizar estado do jogo com dados do servidor
                    gameState.players = data.players;
                    gameState.communityCards = data.communityCards;
                    gameState.pot = data.pot;
                    gameState.currentBet = data.currentBet;
                    gameState.phase = data.phase;
                    gameState.currentPlayerIndex = data.currentPlayerIndex;
                    
                    updateUI();
                } else if (data.type === 'your_turn') {
                    // Ativar controles para o jogador atual
                    gameState.isPlayerTurn = true;
                    updateControls();
                }
            });
            
            ws.addEventListener('close', () => {
                console.log('Desconectado do servidor');
                showGameMessage('Desconectado do servidor. Reconectando...', 2000);
                
                // Tentar reconectar ap√≥s 3 segundos
                setTimeout(connectToServer, 3000);
            });
            
            ws.addEventListener('error', (error) => {
                console.error('Erro de WebSocket:', error);
                showGameMessage('Erro de conex√£o com o servidor', 2000);
            });
            
            gameState.socket = ws;
        }

        // Inicializar a p√°gina
        function init() {
            // Desativar elementos da UI at√© que o jogo comece
            checkCallBtn.disabled = true;
            betRaiseBtn.disabled = true;
            foldBtn.disabled = true;
            
            showGameMessage('Bem-vindo ao Poker Texas Hold\'em! Escolha um modo de jogo.', 0);
            
            gameState.history = [];
            gameState.round = 0;
        }

        // Iniciar o jogo
        init();

        // Fun√ß√£o para adicionar uma entrada ao hist√≥rico
        function addToHistory(entry) {
            // Limitar o hist√≥rico a 7 entradas
            if (gameState.history.length >= 7) {
                gameState.history.pop(); // Remove a entrada mais antiga
            }
            
            // Adicionar nova entrada no in√≠cio
            gameState.history.unshift({
                ...entry,
                round: gameState.round
            });
            
            // Atualizar a exibi√ß√£o do hist√≥rico
            updateHistoryDisplay();
        }

        // Fun√ß√£o para atualizar a exibi√ß√£o do hist√≥rico
        function updateHistoryDisplay() {
            const historyContainer = document.getElementById('history-container');
            historyContainer.innerHTML = '';
            
            gameState.history.forEach(entry => {
                const historyEntry = document.createElement('div');
                historyEntry.className = 'history-entry';
                
                const roundElement = document.createElement('div');
                roundElement.className = 'history-round';
                roundElement.textContent = `Rodada ${entry.round}`;
                
                const winnerElement = document.createElement('div');
                winnerElement.className = 'history-winner';
                
                if (entry.winners.length === 1) {
                    // Um vencedor
                    const winnerNameElement = document.createElement('span');
                    winnerNameElement.className = 'history-winner-name';
                    winnerNameElement.textContent = entry.winners[0].name;
                    
                    const amountElement = document.createElement('span');
                    amountElement.className = 'history-amount';
                    amountElement.textContent = ` ganhou $${entry.amount}`;
                    
                    winnerElement.appendChild(winnerNameElement);
                    winnerElement.appendChild(amountElement);
                    
                    if (entry.hand) {
                        const handElement = document.createElement('div');
                        handElement.className = 'history-hand';
                        
                        // Verificar se a vit√≥ria foi por fold
                        if (entry.type === 'fold' || entry.hand === "todos desistiram") {
                            handElement.textContent = `(todos desistiram)`;
                        } else {
                            handElement.textContent = `com ${entry.hand}`;
                        }
                        
                        historyEntry.appendChild(handElement);
                    }
                } else {
                    // M√∫ltiplos vencedores (empate)
                    winnerElement.textContent = 'Empate entre ';
                    
                    entry.winners.forEach((winner, index) => {
                        const winnerNameElement = document.createElement('span');
                        winnerNameElement.className = 'history-winner-name';
                        winnerNameElement.textContent = winner.name;
                        
                        winnerElement.appendChild(winnerNameElement);
                        
                        if (index < entry.winners.length - 1) {
                            winnerElement.appendChild(document.createTextNode(', '));
                        }
                    });
                    
                    const amountElement = document.createElement('div');
                    amountElement.className = 'history-amount';
                    amountElement.textContent = `Cada um ganhou $${Math.floor(entry.amount / entry.winners.length)}`;
                    historyEntry.appendChild(amountElement);
                    
                    if (entry.hand) {
                        const handElement = document.createElement('div');
                        handElement.className = 'history-hand';
                        handElement.textContent = `com ${entry.hand}`;
                        historyEntry.appendChild(handElement);
                    }
                }
                
                historyEntry.appendChild(roundElement);
                historyEntry.appendChild(winnerElement);
                historyContainer.appendChild(historyEntry);
            });
        }

        // Fun√ß√£o para alternar entre minimizado e maximizado
        function toggleHistoryPanel() {
            const historyPanel = document.getElementById('history-panel');
            const historyToggle = document.getElementById('history-toggle');
            
            historyPanel.classList.toggle('minimized');
            
            // Salvar prefer√™ncia do usu√°rio
            const isMinimized = historyPanel.classList.contains('minimized');
            localStorage.setItem('pokerHistoryMinimized', isMinimized);
        }

        // Adicionar evento de clique ao t√≠tulo do hist√≥rico
        document.addEventListener('DOMContentLoaded', function() {
            const historyTitle = document.getElementById('history-title');
            if (historyTitle) {
                historyTitle.addEventListener('click', toggleHistoryPanel);
            }
            
            // Verificar prefer√™ncia salva
            const historyPanel = document.getElementById('history-panel');
            if (historyPanel) {
                const savedPreference = localStorage.getItem('pokerHistoryMinimized');
                if (savedPreference === 'true') {
                    historyPanel.classList.add('minimized');
                }
            }
        });

        // Adicionar a fun√ß√£o hasFlush que est√° faltando
        function hasFlush(cards) {
            // Agrupar cartas por naipe
            const suits = {};
            cards.forEach(card => {
                suits[card.suit] = (suits[card.suit] || 0) + 1;
            });
            
            // Verificar se h√° pelo menos 5 cartas do mesmo naipe
            for (const suit in suits) {
                if (suits[suit] >= 5) {
                    // Filtrar apenas as cartas deste naipe e ordenar por valor
                    const flushCards = cards
                        .filter(card => card.suit === suit)
                        .sort((a, b) => b.value - a.value)
                        .slice(0, 5); // Pegar as 5 cartas mais altas
                    
                    return flushCards;
                }
            }
            
            return null;
        }

        // Tamb√©m precisamos implementar as fun√ß√µes para straight e straight flush
        function hasStraight(cards) {
            // Ordenar cartas por valor (do maior para o menor) e remover duplicatas
            const uniqueValues = [...new Set(cards.map(card => card.value))].sort((a, b) => b - a);
            
            // Caso especial: A-5-4-3-2 (√Ås pode ser 1)
            if (uniqueValues.includes(14)) { // √Ås
                uniqueValues.push(1); // Adicionar √Ås como 1 tamb√©m
            }
            
            // Procurar por 5 valores consecutivos
            for (let i = 0; i < uniqueValues.length - 4; i++) {
                if (uniqueValues[i] - uniqueValues[i + 4] === 4) {
                    // Encontrou uma sequ√™ncia
                    return uniqueValues[i]; // Retorna o valor mais alto da sequ√™ncia
                }
            }
            
            return null;
        }

        function hasStraightFlush(cards) {
            // Agrupar cartas por naipe
            const suits = {};
            cards.forEach(card => {
                suits[card.suit] = (suits[card.suit] || 0) + 1;
            });
            
            // Verificar cada naipe que tem pelo menos 5 cartas
            for (const suit in suits) {
                if (suits[suit] >= 5) {
                    // Filtrar apenas as cartas deste naipe
                    const sameSuitCards = cards.filter(card => card.suit === suit);
                    
                    // Verificar se h√° uma sequ√™ncia neste naipe
                    const straightValue = hasStraight(sameSuitCards);
                    if (straightValue) {
                        return straightValue;
                    }
                }
            }
            
            return null;
        }
    </script>
</body>
</html> 